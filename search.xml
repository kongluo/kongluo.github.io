<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Scala集合操作手册</title>
      <link href="/2018/12/14/BigData-Scala9-1/"/>
      <url>/2018/12/14/BigData-Scala9-1/</url>
      <content type="html"><![CDATA[<p><img src="/2018/12/14/BigData-Scala9-1/Scala9.png" alt="Scala集合库简介"><br><a id="more"></a></p><h1 id="Scala集合库简介"><a href="#Scala集合库简介" class="headerlink" title="Scala集合库简介"></a>Scala集合库简介</h1><hr><h2 id="可变集合和不可变集合的特质"><a href="#可变集合和不可变集合的特质" class="headerlink" title="可变集合和不可变集合的特质"></a>可变集合和不可变集合的特质</h2><center><br>  <img src="/2018/12/14/BigData-Scala9-1/Scala9.png" alt="Scala集合库简介"><br></center><h2 id="不可变集合的特质个具体实现类"><a href="#不可变集合的特质个具体实现类" class="headerlink" title="不可变集合的特质个具体实现类"></a>不可变集合的特质个具体实现类</h2><h2 id="可变集合的特质和具体实现类"><a href="#可变集合的特质和具体实现类" class="headerlink" title="可变集合的特质和具体实现类"></a>可变集合的特质和具体实现类</h2><h2 id="只包含Set和Map类"><a href="#只包含Set和Map类" class="headerlink" title="只包含Set和Map类"></a>只包含Set和Map类</h2><h1 id="Traversable"><a href="#Traversable" class="headerlink" title="Traversable"></a>Traversable</h1><hr><center><br>  <img src="/2018/12/14/BigData-Scala9-1/Scala9.png" alt="Scala集合库简介"><br></center><h4 id="flatten-平展"><a href="#flatten-平展" class="headerlink" title="flatten 平展"></a>flatten 平展</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s1 = <span class="type">Traversable</span>(<span class="type">Traversable</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),<span class="type">Traversable</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>),</span><br><span class="line">          <span class="type">Traversable</span>(<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>))</span><br><span class="line"><span class="keyword">val</span> s2 = s1.flatten</span><br><span class="line">println(s2)</span><br></pre></td></tr></table></figure><h4 id="transpose-转置"><a href="#transpose-转置" class="headerlink" title="transpose 转置"></a>transpose 转置</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> matrix = <span class="type">Traversable</span>(<span class="type">Traversable</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),<span class="type">Traversable</span>(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>),</span><br><span class="line">            <span class="type">Traversable</span>(<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>))</span><br><span class="line">println(matrix)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result = matrix.transpose</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure><h4 id="unzip-unzip3-拉链操作"><a href="#unzip-unzip3-拉链操作" class="headerlink" title="unzip/unzip3 拉链操作"></a>unzip/unzip3 拉链操作</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t = <span class="type">Traversable</span>(<span class="string">"a"</span>-&gt;<span class="number">1</span>,<span class="string">"b"</span>-&gt;<span class="number">2</span>,<span class="string">"c"</span>-&gt;<span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> (a,b) = t.unzip</span><br><span class="line">println(a)</span><br><span class="line">println(b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> s = <span class="type">Traversable</span>(<span class="string">"电影ID,评分,电影名"</span>,<span class="string">"20645098,8.2,小王子"</span>,</span><br><span class="line"><span class="string">"26259677,8.3,垫底"</span>,<span class="string">"11808948,7.2,海绵宝宝"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> (a,b,c) = s.unzip3(x=&gt;&#123;</span><br><span class="line"><span class="keyword">val</span> a = x.split(<span class="string">","</span>);</span><br><span class="line">(a(<span class="number">0</span>),a(<span class="number">1</span>),a(<span class="number">2</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">println(a)</span><br><span class="line">println(b)</span><br><span class="line">println(c)</span><br></pre></td></tr></table></figure><h4 id="连接两个Traversable到一个新的Traversable"><a href="#连接两个Traversable到一个新的Traversable" class="headerlink" title="++ 连接两个Traversable到一个新的Traversable"></a>++ 连接两个Traversable到一个新的Traversable</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> movieNames = <span class="type">Traversable</span>(<span class="string">"小王子"</span>,<span class="string">"垫底辣妹"</span>,<span class="string">"海绵宝宝"</span>)</span><br><span class="line"><span class="keyword">val</span> movieIDs = mutable.<span class="type">HashSet</span>(<span class="number">20645098</span>,<span class="number">26259677</span>,<span class="number">11808948</span>)</span><br><span class="line"><span class="keyword">val</span> movie s= movieNames++movieIDs</span><br><span class="line">println(movies)</span><br></pre></td></tr></table></figure><p><font color="red">注意:</font><br>++ 结果的类型和左边保持一致<br>++: 结果的类型和右边保持一致</p><h4 id="concat-连接多个Traversable到一个新的Traversable"><a href="#concat-连接多个Traversable到一个新的Traversable" class="headerlink" title="concat 连接多个Traversable到一个新的Traversable"></a>concat 连接多个Traversable到一个新的Traversable</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = <span class="type">Traversable</span>.concat(<span class="type">Traversable</span>(<span class="number">1</span> to <span class="number">3</span>:_*),<span class="type">Traversable</span>(<span class="number">4</span> to <span class="number">5</span>:_*),</span><br><span class="line">              <span class="type">Traversable</span>(<span class="number">6</span> to <span class="number">8</span>:_*))</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure><p><font color="red">注意:</font><br>concat会预先计算出所需的集合的大小，然后生成一个集合，减少了中间无用的临时集合，所以更加有效</p><h4 id="collect-收集数据"><a href="#collect-收集数据" class="headerlink" title="collect 收集数据"></a>collect 收集数据</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t = <span class="type">Traversable</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>)</span><br><span class="line">deffilterEven:<span class="type">PartialFunction</span>[<span class="type">Int</span>,<span class="type">Int</span>]=&#123;</span><br><span class="line"> <span class="keyword">case</span> x <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span> =&gt; x</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> result2 = t collect(filterEven)</span><br><span class="line">println(result2)</span><br></pre></td></tr></table></figure><p>PartialFunction：偏函数类型是一个特质，它的定义为：<br>trait PartialFunction[-A,+B] extends (A)=&gt;B<br>它的函数功能是一个一元函数，这个一元函数只处理了定义域上的一部分，可以根据isDefinedAt来判断一个元素能否被这个偏函数处理。例如，只处理偶数的偏函数：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> isEven:<span class="type">PartialFunction</span>[<span class="type">Int</span>,<span class="type">String</span>]=&#123;</span><br><span class="line"><span class="keyword">case</span>  x <span class="keyword">if</span> x%<span class="number">2</span> ==<span class="number">0</span>  =&gt; x + <span class="string">" is Even"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="map-flatMap操作"><a href="#map-flatMap操作" class="headerlink" title="map/flatMap操作"></a>map/flatMap操作</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t = <span class="type">Traversable</span>(<span class="number">1</span>to5:_*)</span><br><span class="line"><span class="keyword">val</span> result = t.map(x =&gt; x*x)</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure><p>flatMap 操作 -&gt; map + flatten</p><h4 id="scan-scanLeft-scanRight"><a href="#scan-scanLeft-scanRight" class="headerlink" title="scan/scanLeft/scanRight"></a>scan/scanLeft/scanRight</h4><p>利用scan计算Traversable元素的阶乘<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t3 = <span class="type">Traversable</span>(<span class="number">1</span> to <span class="number">5</span>:_*)</span><br><span class="line">println(t3)</span><br><span class="line">valresul t3 = t.scan(<span class="number">1</span>)(_*_)</span><br><span class="line">println(result3.tail)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> t4 = <span class="type">Traversable</span>( <span class="number">1</span> to <span class="number">5</span>:_*)</span><br><span class="line">println(t4)</span><br><span class="line"><span class="keyword">val</span> result4 = t4.scanRight(<span class="number">1</span>)(_*_)</span><br><span class="line">println(result4)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> t5 = <span class="type">Traversable</span>(<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"D"</span>,<span class="string">"E"</span>)</span><br><span class="line">println(t5)</span><br><span class="line"><span class="keyword">val</span> result5 = t5.fold(<span class="string">"z"</span>)(_+_)</span><br><span class="line">println(result5)</span><br></pre></td></tr></table></figure></p><p>foldLeft 等价于 /:<br>foldRight 等价于 :\</p><p>foldRight方法是通过递归的方法实现的，对于包含大量元素的集合对象来说，这很容易导致栈溢出。(早期)<br>现在，foldRight利用foldLeft来实现</p><p><font color="green">利用fold方法实现的一些方法</font></p><ul><li><p>求和sum<br>  t.foldLeft(0)(_+_)</p></li><li><p>求积product<br>  t.foldLeft(1)(_*_)</p></li><li><p>计数count<br>  t.foldLeft(0)((sum,_)=&gt;sum+1)</p></li><li><p>倒数第二个值penultimate<br>  t.foldLeft((t.head,t.tail.head))((r,c)=&gt;(r._2,c))._1</p></li><li><p>包含contains<br>  t.foldLeft(false)(_ || _==item)</p></li></ul><h4 id="isEmpty-nonEmpty-size-hasDefiniteSize-判断一个Traversable非空"><a href="#isEmpty-nonEmpty-size-hasDefiniteSize-判断一个Traversable非空" class="headerlink" title="isEmpty/nonEmpty/size/hasDefiniteSize 判断一个Traversable非空"></a>isEmpty/nonEmpty/size/hasDefiniteSize 判断一个Traversable非空</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t = <span class="type">Traversable</span>.empty</span><br><span class="line">println(t.isEmpty)</span><br><span class="line">println(t.nonEmpty)</span><br><span class="line">println(!t.isEmpty)  <span class="comment">//不推荐使用，size也不推荐使用</span></span><br></pre></td></tr></table></figure><h4 id="head、last、headOption、lastOption、find-找到对象的特定的元素"><a href="#head、last、headOption、lastOption、find-找到对象的特定的元素" class="headerlink" title="head、last、headOption、lastOption、find  找到对象的特定的元素"></a>head、last、headOption、lastOption、find  找到对象的特定的元素</h4><ul><li>head、last：返回Traversable的第一个元素和最后一个元素，如果元素不存在，比如空集合，则会抛出异常。</li><li>headOption、lastOption：返回Traversable的第一个元素和最后一个元素，但类型是Option。如果元素存在，则返回Some(head)和Some(last)，如果不存在，则返回None<br>  (对于Traversable来说，默认的last方法实现会遍历所有的元素，直到遍历到最后的元素为止)</li><li>find 查找到第一个满足条件的值，如果没有满足条件的元素，则返回None</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t1 = <span class="type">Traversable</span>(<span class="number">1</span> to <span class="number">10</span>:_*)</span><br><span class="line">println(t1)</span><br><span class="line">println(t1.head)</span><br><span class="line">println(<span class="type">Traversable</span>.empty.headOption.isDefined)</span><br><span class="line"></span><br><span class="line">println(t1.last)</span><br><span class="line">println(<span class="type">Traversable</span>.empty.lastOption.isDefined)</span><br><span class="line">println(t1.find(_%<span class="number">2</span>==<span class="number">0</span>))</span><br></pre></td></tr></table></figure><h4 id="tail、tails、init、inits"><a href="#tail、tails、init、inits" class="headerlink" title="tail、tails、init、inits"></a>tail、tails、init、inits</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t3 = <span class="type">Traversable</span>(<span class="number">1</span>to5:_*)</span><br><span class="line">println(t3)</span><br><span class="line">println(t3.tail)</span><br><span class="line">println(t3 == (t3.head::t3.tail.toList))</span><br><span class="line"><span class="keyword">for</span>(i &lt;- t3.tails) println(i)</span><br><span class="line">println(t3.init)</span><br><span class="line"><span class="keyword">for</span>(i &lt;- t3.inits) println(i)</span><br></pre></td></tr></table></figure><p><font color="red">tail 方法</font>：返回的是Traversable对象中除去第一个元素的其余元素组成的Traversable对象。</p><p><font color="red">init 方法</font>：和tail方法相反，它返回除去最后一个元素的其他元素</p><p><font color="red">总结</font><br>head        <-->      last<br>init        <-->      tail<br>inits       <-->      tails<br>take        <-->      drop<br>takeWhile   <-->      dropWhile</--></--></--></--></--></p><h4 id="slice-截取集合的一部分"><a href="#slice-截取集合的一部分" class="headerlink" title="slice  截取集合的一部分"></a>slice  截取集合的一部分</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t4 = <span class="type">Traversable</span>(<span class="number">1</span> to <span class="number">5</span>:_*)</span><br><span class="line">println(t4.slice(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">println(t4.slice(<span class="number">-100</span>,<span class="number">100</span>))</span><br></pre></td></tr></table></figure><p>Scala集合的索引是从0开始的，和Java数组的下标一样。如果from、until的值超过集合的上下标，则以集合的上下标为准，不会抛出异常</p><h4 id="take、takeWhile-选取traversable的前N个元素"><a href="#take、takeWhile-选取traversable的前N个元素" class="headerlink" title="take、takeWhile  选取traversable的前N个元素"></a>take、takeWhile  选取traversable的前N个元素</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t5 = <span class="type">Traversable</span>(<span class="number">1</span>to10:_*)</span><br><span class="line">println(t5)</span><br><span class="line">println(t5.take(<span class="number">5</span>))</span><br><span class="line">println(t5.takeWhile(_&lt;<span class="number">6</span>))</span><br></pre></td></tr></table></figure><p><font color="blue">take: take(n)</font> 等价于 slice(0,n)</p><p><font color="blue">takeWhile:</font>根据断言从头开始一直选择元素，知道某个元素不满足这个断言为止</p><h4 id="drop、dropWhile-跳过开头的前N个元素，选择剩余的元素"><a href="#drop、dropWhile-跳过开头的前N个元素，选择剩余的元素" class="headerlink" title="drop、dropWhile  跳过开头的前N个元素，选择剩余的元素"></a>drop、dropWhile  跳过开头的前N个元素，选择剩余的元素</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t6 = <span class="type">Traversable</span>(<span class="number">1</span> to <span class="number">10</span>:_*)</span><br><span class="line">println(t6.drop(<span class="number">5</span>))</span><br><span class="line">println(<span class="type">Traversable</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">4</span>).dropWhile(_ &lt; <span class="number">6</span>))</span><br><span class="line">println(t6 == (t6.take(<span class="number">5</span>) ++ t6.drop(<span class="number">5</span>))) <span class="comment">//调用withFilter可以返回FilterMonadic，可以继续调用withFilter</span></span><br></pre></td></tr></table></figure><p>drop: 获取出去开头前N个元素的剩余元素。如果集合的数量小于N，则返回空集合。如果N小于等于0，则返回整个集合的元素</p><ul><li>filter：接受一个断言函数做参数，所有满足断言的元素都在返回的集合中</li><li>filterNot：选择不满足断言的元素</li><li>withFilter：结果是FilterMonadic，它只包含map、flatMap、foreach和withFilter操作</li></ul><p><font color="red">函数式编程有一个重要概念，叫做单子。简单地说，它代表一种特殊的类型，这种类型是一个计算序列，可以让程序员使用管道式的方式处理数据。FilterMonadic就是一个单子类型</font></p><h4 id="filter、filterNot、withFilter-根据条件筛选元素"><a href="#filter、filterNot、withFilter-根据条件筛选元素" class="headerlink" title="filter、filterNot、withFilter 根据条件筛选元素"></a>filter、filterNot、withFilter 根据条件筛选元素</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t7 = <span class="type">Traversable</span>(<span class="number">1</span> to <span class="number">10</span>:_*)</span><br><span class="line">println(t7.filter(_ &gt; <span class="number">6</span>))</span><br><span class="line">println(t7.filterNot(_ &lt; <span class="number">6</span>))</span><br><span class="line">println(t7.withFilter(_ &lt; <span class="number">6</span>).withFilter(_ &gt; <span class="number">2</span>).withFilter(_%<span class="number">2</span> == <span class="number">0</span>).foreach(println))</span><br></pre></td></tr></table></figure><h4 id="splitAt、span、partition、groupBy-对Traversable对象的元素进行分组"><a href="#splitAt、span、partition、groupBy-对Traversable对象的元素进行分组" class="headerlink" title="splitAt、span、partition、groupBy 对Traversable对象的元素进行分组"></a>splitAt、span、partition、groupBy 对Traversable对象的元素进行分组</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t = <span class="type">Traversable</span>(<span class="number">1</span> to <span class="number">10</span>:_*)</span><br><span class="line">println(t.splitAt(<span class="number">5</span>))</span><br><span class="line">println(t.span(_ &lt; <span class="number">6</span>))</span><br><span class="line">println(t.partition(_ % <span class="number">2</span> == <span class="number">0</span>))</span><br><span class="line">println(t.groupBy(_ % <span class="number">3</span>))</span><br></pre></td></tr></table></figure><ul><li>splitAt：根据位置将Traversable对象分成两部分，功能类似(c.take(n),c.drop(n)),但是更加有效</li><li>span：也是将Traversable对象分成两部分，它会一直选取元素，直到某个元素不满足断言，然后将前面的元素分成一组，将后面的元素分成另一组，共两部分，功能        和(c.takewhile(p),c.dropwhile(p))一样，但更加有效</li><li>partition：对所有的元素进行断言，断言结果为true的分成一组，等于false的分成另一组</li><li>groupBy：按照条件将元素分组，它根据提供的函数生成分组关键字</li></ul><h4 id="forall、exists"><a href="#forall、exists" class="headerlink" title="forall、exists"></a>forall、exists</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t2 = <span class="type">Traversable</span>(<span class="number">1</span> to <span class="number">10</span> : _*)</span><br><span class="line">println(t2.forall(_ &lt;= <span class="number">10</span>))</span><br><span class="line">println(t2.forall(_ &gt;= <span class="number">10</span>))</span><br><span class="line">println(t2.exists(_ == <span class="number">5</span>))</span><br></pre></td></tr></table></figure><ul><li>forall：可以测试所有的元素，如果所有的元素使用断言p判断返回的结果都是true，那么forall方法则返回true</li><li>exists：检查某个元素是否满足断言的，只要找到一个元素，那么运用此方法返回的结果就是true</li></ul><h4 id="count-统计满足断言的元素个数"><a href="#count-统计满足断言的元素个数" class="headerlink" title="count 统计满足断言的元素个数"></a>count 统计满足断言的元素个数</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t3 = <span class="type">Traversable</span>(<span class="number">1</span> to <span class="number">10</span> : _*)</span><br><span class="line">println(t3.count(_ % <span class="number">2</span> == <span class="number">0</span>))</span><br><span class="line">println(t3.filter(_ % <span class="number">2</span> == <span class="number">0</span>).size)<span class="comment">//不要使用下面这种方法，尽管它也可以给出正确的结果，但是会额外生成一个Traversable对象，占用更多的空间。</span></span><br></pre></td></tr></table></figure><h4 id="reduce、reduceOption、reduceLeft、reduceLeftOption、reduceRight、reduceRightOption"><a href="#reduce、reduceOption、reduceLeft、reduceLeftOption、reduceRight、reduceRightOption" class="headerlink" title="reduce、reduceOption、reduceLeft、reduceLeftOption、reduceRight、reduceRightOption"></a>reduce、reduceOption、reduceLeft、reduceLeftOption、reduceRight、reduceRightOption</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t4 = <span class="type">Traversable</span>(<span class="number">1</span> to <span class="number">10</span> : _*)</span><br><span class="line">println(t4.reduce((acc,x) =&gt; acc+x))</span><br><span class="line">println(t4.reduce(_ + _))</span><br><span class="line">println(t4.reduceRight(_*<span class="number">10</span> + _))</span><br></pre></td></tr></table></figure><p>这个例子中除了最后一个元素没有乘以10以外，其他的元素都是乘以10再相加</p><h4 id="sum、product、min、max、aggregate、maxBy、minBy"><a href="#sum、product、min、max、aggregate、maxBy、minBy" class="headerlink" title="sum、product、min、max、aggregate、maxBy、minBy"></a>sum、product、min、max、aggregate、maxBy、minBy</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t5 = <span class="type">Traversable</span>(<span class="number">1</span> to <span class="number">10</span> : _*)</span><br><span class="line">println(t5.sum)</span><br><span class="line">println(t5.product)</span><br><span class="line">println(t5.max)</span><br><span class="line">println(t5.min)</span><br><span class="line"><span class="keyword">val</span> t6 = <span class="type">Traversable</span>(<span class="string">"helloaworld,goodstudy"</span>.split(<span class="string">"\\W+"</span>):_*)</span><br><span class="line">println(t6.maxBy(_.length))</span><br><span class="line">println(t6.minBy(_.length))</span><br><span class="line">valchars=t6.aggregate(<span class="number">0</span>)(_+_.length,_+_)</span><br><span class="line">println(chars)</span><br></pre></td></tr></table></figure><ul><li>sum：求和</li><li>product：求积</li><li>min：最小值</li><li>max：最大值</li><li>aggregate：</li><li>maxBy/minBy：根据测量函数的值大小来决定返回值最大值或最小值</li></ul><h4 id="mkString、addString、stringPrefix"><a href="#mkString、addString、stringPrefix" class="headerlink" title="mkString、addString、stringPrefix"></a>mkString、addString、stringPrefix</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t = <span class="type">Traversable</span>(<span class="number">1</span> to <span class="number">10</span> : _*)</span><br><span class="line">println(t.mkString(<span class="string">","</span>))</span><br><span class="line">println(t.mkString(<span class="string">"["</span>,<span class="string">","</span>,<span class="string">"]"</span>))  <span class="comment">//提供分隔符以及前后缀</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> sb:<span class="type">StringBuilder</span>=<span class="keyword">new</span> <span class="type">StringBuilder</span></span><br><span class="line">sb.clear()</span><br><span class="line">t.addString(sb,<span class="string">","</span>)</span><br><span class="line">sb.clear()</span><br><span class="line">t.addString(sb,<span class="string">"["</span>,<span class="string">","</span>,<span class="string">"]"</span>)</span><br><span class="line">println(sb.toString())</span><br><span class="line">println(t.repr.getClass.getName)</span><br><span class="line">println(t.stringPrefix)</span><br></pre></td></tr></table></figure><ul><li>mkString/addString：用来生成字符串</li></ul><h4 id="toArray、toParArray、toBuffer、toIndexedSeq、toIterable、toIterator、toList、toSeq、toSet-toStream、toVector、toTraversable、toMap、to"><a href="#toArray、toParArray、toBuffer、toIndexedSeq、toIterable、toIterator、toList、toSeq、toSet-toStream、toVector、toTraversable、toMap、to" class="headerlink" title="toArray、toParArray、toBuffer、toIndexedSeq、toIterable、toIterator、toList、toSeq、toSet toStream、toVector、toTraversable、toMap、to"></a>toArray、toParArray、toBuffer、toIndexedSeq、toIterable、toIterator、toList、toSeq、toSet toStream、toVector、toTraversable、toMap、to</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t2=<span class="type">Traversable</span>(<span class="number">1</span> to <span class="number">5</span>:_*)</span><br><span class="line">println(t2.toArray.mkString(t.toArray.stringPrefix+<span class="string">"("</span>,<span class="string">","</span>,<span class="string">")"</span>))</span><br><span class="line">println(t2.toParArray)</span><br><span class="line">println(t2.toBuffer)</span><br><span class="line">println(t2.toIndexedSeq)</span><br><span class="line">println(t2.toIterable)</span><br><span class="line">println(t2.toIterator)</span><br><span class="line">println(t2.toList)</span><br><span class="line">println(t2.toSeq)</span><br><span class="line">println(t2.toSet)</span><br><span class="line">println(t2.toStream)</span><br><span class="line">println(t2.toVector)</span><br><span class="line">println(t2.toTraversable)</span><br><span class="line">println(<span class="type">Traversable</span>(<span class="string">"a"</span>-&gt;<span class="number">1</span>,<span class="string">"b"</span>-&gt;<span class="number">2</span>).toMap)</span><br><span class="line"><span class="comment">//------------- 返回 -----------------</span></span><br><span class="line">t2: <span class="type">Traversable</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">[<span class="type">I</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="type">ParArray</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="type">ArrayBuffer</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="type">Vector</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">non-empty iterator</span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="type">Set</span>(<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="type">Stream</span>(<span class="number">1</span>, ?)</span><br><span class="line"><span class="type">Vector</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="type">Map</span>(a -&gt; <span class="number">1</span>, b -&gt; <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h4 id="copyToArray、copyToBuffer-将Traversable对象中的元素复制到一个已有的数组中"><a href="#copyToArray、copyToBuffer-将Traversable对象中的元素复制到一个已有的数组中" class="headerlink" title="copyToArray、copyToBuffer  将Traversable对象中的元素复制到一个已有的数组中"></a>copyToArray、copyToBuffer  将Traversable对象中的元素复制到一个已有的数组中</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t3 = <span class="type">Traversable</span>(<span class="number">1</span> to <span class="number">5</span>:_*)</span><br><span class="line">println(t3.toArray)</span><br><span class="line"><span class="keyword">val</span> result=newArray[<span class="type">Int</span>](t3.size)</span><br><span class="line">t3.copyToArray(result)</span><br><span class="line">println(result.mkString(result.stringPrefix+<span class="string">"("</span>,<span class="string">","</span>,<span class="string">")"</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> result2=newArray[<span class="type">Int</span>](t.size*<span class="number">2</span>)</span><br><span class="line">t3.copyToArray(result2,<span class="number">5</span>,<span class="number">4</span>) <span class="comment">//复制到索引5 - 8的位置</span></span><br><span class="line">result2</span><br></pre></td></tr></table></figure><h4 id="view-给定一个Traversable对象，返回它从from到until之间的元素的视图"><a href="#view-给定一个Traversable对象，返回它从from到until之间的元素的视图" class="headerlink" title="view  给定一个Traversable对象，返回它从from到until之间的元素的视图"></a>view  给定一个Traversable对象，返回它从from到until之间的元素的视图</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t=<span class="type">Traversable</span>(<span class="number">1</span> to <span class="number">5</span> : _*)</span><br><span class="line"><span class="keyword">var</span> v=t.view(<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">v.foreach(println)</span><br><span class="line">v=t.view</span><br><span class="line">v.foreach(println)</span><br></pre></td></tr></table></figure><h4 id="fill、iterate-使用一个相同的元素填充元素"><a href="#fill、iterate-使用一个相同的元素填充元素" class="headerlink" title="fill、iterate  使用一个相同的元素填充元素"></a>fill、iterate  使用一个相同的元素填充元素</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t2=<span class="type">Traversable</span>.fill(<span class="number">5</span>)(<span class="string">"A"</span>)</span><br><span class="line">println(t2)</span><br><span class="line"><span class="keyword">val</span> t3=<span class="type">Traversable</span>.fill(<span class="number">5</span>,<span class="number">2</span>)(<span class="string">"A"</span>)</span><br><span class="line">println(t3)</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------- 返回 ---------</span></span><br><span class="line"><span class="type">List</span>(<span class="type">A</span>, <span class="type">A</span>, <span class="type">A</span>, <span class="type">A</span>, <span class="type">A</span>)</span><br><span class="line"><span class="type">List</span>(<span class="type">List</span>(<span class="type">A</span>, <span class="type">A</span>), <span class="type">List</span>(<span class="type">A</span>, <span class="type">A</span>), <span class="type">List</span>(<span class="type">A</span>, <span class="type">A</span>), <span class="type">List</span>(<span class="type">A</span>, <span class="type">A</span>), <span class="type">List</span>(<span class="type">A</span>, <span class="type">A</span>))</span><br></pre></td></tr></table></figure><h4 id="range-在某个值域上生成指定间隔的队列"><a href="#range-在某个值域上生成指定间隔的队列" class="headerlink" title="range  在某个值域上生成指定间隔的队列"></a>range  在某个值域上生成指定间隔的队列</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> t4 = <span class="type">Traversable</span>.range(<span class="number">1</span>,<span class="number">20</span>,<span class="number">5</span>) <span class="comment">//(start,end,step) -&gt; 如果没有指定步进的大小，则将其默认为1</span></span><br><span class="line">println(t4)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> t5 = <span class="type">Traversable</span>.range(<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line">println(t5)</span><br><span class="line"><span class="comment">//-------- 返回 -------</span></span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">6</span>, <span class="number">11</span>, <span class="number">16</span>)</span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h1 id="Iterable"><a href="#Iterable" class="headerlink" title="Iterable"></a>Iterable</h1><hr><h1 id="Seq"><a href="#Seq" class="headerlink" title="Seq"></a>Seq</h1><hr><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><hr><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><hr><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><hr><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><hr><h1 id="缓冲器"><a href="#缓冲器" class="headerlink" title="缓冲器"></a>缓冲器</h1><hr><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><hr><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><hr><h1 id="流"><a href="#流" class="headerlink" title="流"></a>流</h1><hr><h1 id="并行集合"><a href="#并行集合" class="headerlink" title="并行集合"></a>并行集合</h1><hr><h1 id="Scala集合总结"><a href="#Scala集合总结" class="headerlink" title="Scala集合总结"></a>Scala集合总结</h1><hr>]]></content>
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>随笔(四)</title>
      <link href="/2018/06/21/jottings-4/"/>
      <url>/2018/06/21/jottings-4/</url>
      <content type="html"><![CDATA[<p><img src="/2018/06/21/jottings-4/jottings-4.1.jpg" alt="jottings"><br><a id="more"></a></p><center><br><font face="STZhongsong " size="4" color="Brown">如果冬天有什么可以期待的话<br>糖炒栗子算一个<br>烤红薯算一个<br>还有毛线帽、围巾<br>对了，还有糖葫芦<br>当然这些都抵不上那个冬天星星很亮的夜晚<br><br><img src="/2018/06/21/jottings-4/jottings-4.2.jpg" alt="jottings"><br>我们一起坐在赭山公园的长凳上，聊天<br>你说你笑点低，而我在一直想办法逗你笑<br><br>我讨厌热闹也不喜欢孤独，我总是熬夜<br>会一个人听歌，想自己做个的事<br>我没有面包，也没有清酒<br>我只想做天上明亮的星星伴你前行……</font><br></center>]]></content>
      
      <categories>
          
          <category> thoughts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jottings </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spark生态圈之Spark(七) ----- 常用的Action</title>
      <link href="/2018/06/05/BigData-Spark7/"/>
      <url>/2018/06/05/BigData-Spark7/</url>
      <content type="html"><![CDATA[<h3 id="常用action介绍"><a href="#常用action介绍" class="headerlink" title="常用action介绍"></a>常用action介绍</h3><style>table th:nth-of-type(1){width: 20%;}table th:nth-of-type(2){width: 80%;}</style><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">介绍</th></tr></thead><tbody><tr><td style="text-align:center">reduce</td><td style="text-align:center">通过func函数聚集RDD中的所有元素</td></tr><tr><td style="text-align:center">collect</td><td style="text-align:center">在驱动程序中，以数组的形式返回数据集的所有元素</td></tr><tr><td style="text-align:center">count</td><td style="text-align:center">返回RDD中的元素个数</td></tr><tr><td style="text-align:center">take</td><td style="text-align:center">返回RDD中的前n个元素</td></tr><tr><td style="text-align:center">saveAsTextFile</td><td style="text-align:center">将RDD以文本文件的方式保存到本地或者HDFS中</td></tr><tr><td style="text-align:center">countByKey</td><td style="text-align:center">针对(K,V)类型的RDD，返回一个(K,Int)的map，表示每一个key对应的元素个数。</td></tr></tbody></table><a id="more"></a><style>table th:nth-of-type(1){width: 20%;}table th:nth-of-type(2){width: 80%;}</style><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">介绍</th></tr></thead><tbody><tr><td style="text-align:center">foreach</td><td style="text-align:center">在数据集的每一个元素上，运行函数func进行更新。</td></tr><tr><td style="text-align:center">takeSample</td><td style="text-align:center">抽样但是返回一个scala集合。</td></tr><tr><td style="text-align:center">first</td><td style="text-align:center">返回RDD中的第一个元素</td></tr><tr><td style="text-align:center">takeOrdered</td><td style="text-align:center">返回前几个的排序</td></tr><tr><td style="text-align:center">aggregate</td><td style="text-align:center">将每个分区里面的元素通过seqOp和初始值进行聚合，然后用combine函数将每个分区的结果和初始值(zeroValue)进行combine操作。</td></tr><tr><td style="text-align:center">fold</td><td style="text-align:center">折叠操作，aggregate的简化操作，seqop和combop一样。</td></tr><tr><td style="text-align:center">saveAsObjectFile</td><td style="text-align:center">将RDD中的元素以序列化后对象形式保存到本地或者HDFS中。</td></tr></tbody></table><!-- more --><h3 id="reduce案例实战"><a href="#reduce案例实战" class="headerlink" title="reduce案例实战"></a>reduce案例实战</h3><h3 id="collect案例实战"><a href="#collect案例实战" class="headerlink" title="collect案例实战"></a>collect案例实战</h3><h3 id="count案例实战"><a href="#count案例实战" class="headerlink" title="count案例实战"></a>count案例实战</h3><h3 id="take案例实战"><a href="#take案例实战" class="headerlink" title="take案例实战"></a>take案例实战</h3><h3 id="saveAsTextFile案例实战"><a href="#saveAsTextFile案例实战" class="headerlink" title="saveAsTextFile案例实战"></a>saveAsTextFile案例实战</h3><h3 id="countByKey案例实战"><a href="#countByKey案例实战" class="headerlink" title="countByKey案例实战"></a>countByKey案例实战</h3><h3 id="foreach案例实战"><a href="#foreach案例实战" class="headerlink" title="foreach案例实战"></a>foreach案例实战</h3><h3 id="takeSample案例实战"><a href="#takeSample案例实战" class="headerlink" title="takeSample案例实战"></a>takeSample案例实战</h3><h3 id="first案例实战"><a href="#first案例实战" class="headerlink" title="first案例实战"></a>first案例实战</h3><h3 id="takeOrdered案例实战"><a href="#takeOrdered案例实战" class="headerlink" title="takeOrdered案例实战"></a>takeOrdered案例实战</h3><h3 id="aggregate案例实战"><a href="#aggregate案例实战" class="headerlink" title="aggregate案例实战"></a>aggregate案例实战</h3><h3 id="fold案例实战"><a href="#fold案例实战" class="headerlink" title="fold案例实战"></a>fold案例实战</h3><h3 id="saveAsObjectFile案例实战"><a href="#saveAsObjectFile案例实战" class="headerlink" title="saveAsObjectFile案例实战"></a>saveAsObjectFile案例实战</h3>]]></content>
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spark生态圈之Spark(六) ----- 常用的Transformation</title>
      <link href="/2018/06/05/BigData-Spark6/"/>
      <url>/2018/06/05/BigData-Spark6/</url>
      <content type="html"><![CDATA[<h3 id="常用transformation介绍"><a href="#常用transformation介绍" class="headerlink" title="常用transformation介绍"></a>常用transformation介绍</h3><style>table th:nth-of-type(1){width: 20%;}table th:nth-of-type(2){width: 80%;}</style><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">介绍</th></tr></thead><tbody><tr><td style="text-align:center">map</td><td style="text-align:center">将RDD中的每个元素传入自定义函数，获取一个新的元素，然后用新的元素组成新的RDD</td></tr><tr><td style="text-align:center">filter</td><td style="text-align:center">对RDD中每个元素进行判断，如果返回true则保留，返回false则剔除</td></tr><tr><td style="text-align:center">flatMap</td><td style="text-align:center">与map类似，但是对每个元素都可以返回一个或多个新元素。</td></tr><tr><td style="text-align:center">groupByKey</td><td style="text-align:center">根据key进行分组，每个key对应一个Iterable<value></value></td></tr><tr><td style="text-align:center">reduceByKey</td><td style="text-align:center">对每个key对应的value进行reduce操作</td></tr><tr><td style="text-align:center">sortByKey</td><td style="text-align:center">对每个key对应的value进行排序操作</td></tr></tbody></table><a id="more"></a><style>table th:nth-of-type(1){width: 20%;}table th:nth-of-type(2){width: 80%;}</style><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">介绍</th></tr></thead><tbody><tr><td style="text-align:center">join</td><td style="text-align:center">对两个包含&lt;key,value&gt;对的RDD进行join操作，每个key join上的pair，都会传入自定义函数进行处理</td></tr><tr><td style="text-align:center">cogroup</td><td style="text-align:center">同join，但是是每个key对应的Iterable<value>都会传入自定义函数进行处理</value></td></tr><tr><td style="text-align:center">mapPartitions</td><td style="text-align:center">将函数应用于RDD的每一个分区，每一个分区运行一次，函数需要能够接受Iterator类型，然后返回Iterator。</td></tr><tr><td style="text-align:center">sample</td><td style="text-align:center">在RDD中移seed为种子返回大致上有fraction比例个数据样本RDD，withReplacement表示是否采用放回式抽样。</td></tr><tr><td style="text-align:center">union</td><td style="text-align:center">将两个RDD中的元素进行合并，返回一个新的RDD</td></tr><tr><td style="text-align:center">intersection</td><td style="text-align:center">将两个RDD做交集，返回一个新的RDD</td></tr><tr><td style="text-align:center">distinct</td><td style="text-align:center">将当前RDD进行去重后，返回一个新的RDD</td></tr><tr><td style="text-align:center">partitionBy</td><td style="text-align:center">根据设置的分区器重新将RDD进行分区，返回新的RDD。</td></tr><tr><td style="text-align:center">combineByKey</td><td style="text-align:center">根据key分别使用CreateCombiner和mergeValue进行相同key的数值聚集，通过mergeCombiners将各个分区最终的结果进行聚集。</td></tr><tr><td style="text-align:center">aggregateByKey</td><td style="text-align:center">通过seqOp函数将每一个分区里面的数据和初始值迭代带入函数返回最终值，comOp将每一个分区返回的最终值根据key进行合并操作。</td></tr><tr><td style="text-align:center">foldByKey</td><td style="text-align:center">aggregateByKey的简化操作，seqop和combop相同</td></tr><tr><td style="text-align:center">sortBy</td><td style="text-align:center">底层实现还是使用sortByKey，只不过使用fun生成的新key进行排序。</td></tr><tr><td style="text-align:center">cartesian</td><td style="text-align:center">做两个RDD的笛卡尔积，返回对偶的RDD</td></tr><tr><td style="text-align:center">pipe</td><td style="text-align:center">对于每个分区，都执行一个perl或者shell脚本，返回输出的RDD，注意，如果你是本地文件系统中，需要将脚本放置到每个节点上。</td></tr><tr><td style="text-align:center">coalesce</td><td style="text-align:center">缩减分区数，用于大数据集过滤后，提高小数据集的执行效率。</td></tr><tr><td style="text-align:center">repartition</td><td style="text-align:center">根据你传入的分区数重新通过网络分区所有数据，重型操作。</td></tr><tr><td style="text-align:center">glom</td><td style="text-align:center">将每一个分区形成一个数组，形成新的RDD类型时RDD[Array[T]]</td></tr><tr><td style="text-align:center">mapValues</td><td style="text-align:center">将函数应用于（k，v）结果中的v，返回新的RDD</td></tr><tr><td style="text-align:center">subtract</td><td style="text-align:center">计算差的一种函数去除两个RDD中相同的元素，不同的RDD将保留下来。</td></tr></tbody></table><!-- more --><h3 id="map案例实战"><a href="#map案例实战" class="headerlink" title="map案例实战"></a>map案例实战</h3><p>将集合中每个元素乘以2</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>(): <span class="type">Unit</span> =&#123;</span><br><span class="line">  <span class="keyword">val</span> conf  = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"map"</span>).setMaster(<span class="string">"local[*]"</span>)</span><br><span class="line">  <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> numbers = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">  <span class="keyword">val</span> numberRDD = sc.parallelize(numbers,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> multiRDD = numberRDD.map(_*<span class="number">2</span>)</span><br><span class="line">  multiRDD.foreach(println)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="filter案例实战"><a href="#filter案例实战" class="headerlink" title="filter案例实战"></a>filter案例实战</h3><p>过滤出集合中的偶数</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(): <span class="type">Unit</span> =&#123;</span><br><span class="line">  <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"filter"</span>).setMaster(<span class="string">"local[*]"</span>)</span><br><span class="line">  <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> numbers = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> numberRDD = sc.parallelize(numbers,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> filterRDD = numberRDD.filter(num=&gt;(num%<span class="number">2</span>==<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">  filterRDD.foreach(println)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flatMap案例实战"><a href="#flatMap案例实战" class="headerlink" title="flatMap案例实战"></a>flatMap案例实战</h3><p>将行拆分为单词<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>(): <span class="type">Unit</span> =</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"flatMap"</span>).setMaster(<span class="string">"local[*]"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> lineArray = <span class="type">Array</span>(<span class="string">"hello you"</span>,<span class="string">"hello me"</span>,<span class="string">"hello world"</span>)</span><br><span class="line">    <span class="keyword">val</span> lines = sc.parallelize(lineArray,<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">val</span> words = lines.flatMap(line =&gt; line.split(<span class="string">" "</span>))</span><br><span class="line"></span><br><span class="line">    words.foreach(word =&gt; println(word))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="groupByKey案例实战"><a href="#groupByKey案例实战" class="headerlink" title="groupByKey案例实战"></a>groupByKey案例实战</h3><p>根据key进行分组，每个key对应一个Iterable<value><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupByKey</span></span>(): <span class="type">Unit</span> =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"groupByKey"</span>).setMaster(<span class="string">"local[*]"</span>)</span><br><span class="line">  <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> scoreList = <span class="type">Array</span>((<span class="string">"class1"</span>,<span class="number">80</span>),(<span class="string">"class2"</span>,<span class="number">75</span>),(<span class="string">"class1"</span>,<span class="number">90</span>),(<span class="string">"class2"</span>,<span class="number">60</span>))</span><br><span class="line">  <span class="keyword">val</span> scores = sc.parallelize(scoreList)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> groupedScores = scores.groupByKey()</span><br><span class="line"></span><br><span class="line">  groupedScores.foreach(score =&gt; &#123;</span><br><span class="line">    println(score._1)</span><br><span class="line">    score._2.foreach(println)</span><br><span class="line">    println(<span class="string">"========================================="</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></value></p><h3 id="reduceByKey案例实战"><a href="#reduceByKey案例实战" class="headerlink" title="reduceByKey案例实战"></a>reduceByKey案例实战</h3><p>对每个key对应的value进行reduce操作<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduceByKey</span></span>(): <span class="type">Unit</span> =</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"reduceByKey"</span>).setMaster(<span class="string">"local[*]"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> scoreList = <span class="type">Array</span>((<span class="string">"class1"</span>,<span class="number">80</span>),(<span class="string">"class2"</span>,<span class="number">75</span>),(<span class="string">"class1"</span>,<span class="number">90</span>),(<span class="string">"class2"</span>,<span class="number">60</span>))</span><br><span class="line">    <span class="keyword">val</span> scores = sc.parallelize(scoreList)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> totalScores = scores.reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line">    totalScores.foreach(classScore=&gt;println(classScore._1+<span class="string">" : "</span>+classScore._2))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="sortByKey案例实战"><a href="#sortByKey案例实战" class="headerlink" title="sortByKey案例实战"></a>sortByKey案例实战</h3><p>对每个key对应的value进行排序操作<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortByKey</span></span>(): <span class="type">Unit</span> =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"sortByKey"</span>).setMaster(<span class="string">"local[*]"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> scoreArray = <span class="type">Array</span>((<span class="number">65</span>, <span class="string">"leo"</span>),(<span class="number">50</span>, <span class="string">"tom"</span>),(<span class="number">100</span>, <span class="string">"marry"</span>),(<span class="number">80</span>, <span class="string">"jack"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> scores = sc.parallelize(scoreArray,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> scoresSort = scores.sortByKey()</span><br><span class="line"></span><br><span class="line">    scoresSort.foreach(score=&gt;&#123;</span><br><span class="line">      println(score._1+<span class="string">":"</span>+score._2)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="join案例实战"><a href="#join案例实战" class="headerlink" title="join案例实战"></a>join案例实战</h3><p>对两个包含&lt;key,value&gt;对的RDD进行join操作，每个key join上的pair，都会传入自定义函数进行处理</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">join</span></span>(): <span class="type">Unit</span> =&#123;</span><br><span class="line">  <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"join"</span>).setMaster(<span class="string">"local[*]"</span>)</span><br><span class="line">  <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> studentList = <span class="type">Array</span>((<span class="number">1</span>,<span class="string">"leo"</span>),(<span class="number">2</span>,<span class="string">"jack"</span>),(<span class="number">3</span>,<span class="string">"tom"</span>))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> scoreList = <span class="type">Array</span>((<span class="number">1</span>,<span class="number">100</span>),(<span class="number">2</span>,<span class="number">90</span>),(<span class="number">3</span>,<span class="number">60</span>))</span><br><span class="line">  <span class="comment">//并行化两个RDD</span></span><br><span class="line">  <span class="keyword">val</span> students = sc.parallelize(studentList)</span><br><span class="line">  <span class="keyword">val</span> scores = sc.parallelize(scoreList)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> studentScores = students.join(scores).sortByKey()</span><br><span class="line"></span><br><span class="line">  studentScores.collect().foreach(studentScore =&gt; &#123;</span><br><span class="line">    println(<span class="string">"student id:"</span>+studentScore._1)</span><br><span class="line">    println(<span class="string">"student score:"</span> + studentScore._2)</span><br><span class="line">    println(<span class="string">"==========================="</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="cogroup案例实战"><a href="#cogroup案例实战" class="headerlink" title="cogroup案例实战"></a>cogroup案例实战</h3><p>同join，但是是每个key对应的Iterable<value>都会传入自定义函数进行处理<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cogroup</span></span>: <span class="type">Unit</span> =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"join"</span>).setMaster(<span class="string">"local[*]"</span>)</span><br><span class="line">  <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> studentList = <span class="type">Array</span>((<span class="number">1</span>,<span class="string">"leo"</span>),(<span class="number">2</span>,<span class="string">"jack"</span>),(<span class="number">3</span>,<span class="string">"tom"</span>))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> scoreList = <span class="type">Array</span>((<span class="number">1</span>,<span class="number">100</span>),(<span class="number">2</span>,<span class="number">90</span>),(<span class="number">3</span>,<span class="number">60</span>))</span><br><span class="line">  <span class="comment">//并行化两个RDD</span></span><br><span class="line">  <span class="keyword">val</span> students = sc.parallelize(studentList)</span><br><span class="line">  <span class="keyword">val</span> scores = sc.parallelize(scoreList)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> studentCogroups = students.cogroup(scores)</span><br><span class="line">  studentCogroups.collect().foreach(studentCogroup =&gt; &#123;</span><br><span class="line">    println(studentCogroup._1 + <span class="string">" : "</span> + studentCogroup._2)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></value></p><h3 id="mapPartitions案例实战"><a href="#mapPartitions案例实战" class="headerlink" title="mapPartitions案例实战"></a>mapPartitions案例实战</h3><h3 id="sample案例实战"><a href="#sample案例实战" class="headerlink" title="sample案例实战"></a>sample案例实战</h3><h3 id="union案例实战"><a href="#union案例实战" class="headerlink" title="union案例实战"></a>union案例实战</h3><h3 id="intersection案例实战"><a href="#intersection案例实战" class="headerlink" title="intersection案例实战"></a>intersection案例实战</h3><h3 id="distinct案例实战"><a href="#distinct案例实战" class="headerlink" title="distinct案例实战"></a>distinct案例实战</h3><h3 id="partitionBy案例实战"><a href="#partitionBy案例实战" class="headerlink" title="partitionBy案例实战"></a>partitionBy案例实战</h3><h3 id="combineByKey案例实战"><a href="#combineByKey案例实战" class="headerlink" title="combineByKey案例实战"></a>combineByKey案例实战</h3><h3 id="aggregateByKey案例实战"><a href="#aggregateByKey案例实战" class="headerlink" title="aggregateByKey案例实战"></a>aggregateByKey案例实战</h3><h3 id="foldByKey案例实战"><a href="#foldByKey案例实战" class="headerlink" title="foldByKey案例实战"></a>foldByKey案例实战</h3><h3 id="sortBy案例实战"><a href="#sortBy案例实战" class="headerlink" title="sortBy案例实战"></a>sortBy案例实战</h3><h3 id="cartesian案例实战"><a href="#cartesian案例实战" class="headerlink" title="cartesian案例实战"></a>cartesian案例实战</h3><h3 id="pipe案例实战"><a href="#pipe案例实战" class="headerlink" title="pipe案例实战"></a>pipe案例实战</h3><h3 id="coalesce案例实战"><a href="#coalesce案例实战" class="headerlink" title="coalesce案例实战"></a>coalesce案例实战</h3><h3 id="repartition案例实战"><a href="#repartition案例实战" class="headerlink" title="repartition案例实战"></a>repartition案例实战</h3><h3 id="glom案例实战"><a href="#glom案例实战" class="headerlink" title="glom案例实战"></a>glom案例实战</h3><h3 id="mapValues案例实战"><a href="#mapValues案例实战" class="headerlink" title="mapValues案例实战"></a>mapValues案例实战</h3><h3 id="subtract案例实战"><a href="#subtract案例实战" class="headerlink" title="subtract案例实战"></a>subtract案例实战</h3>]]></content>
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spark生态圈之Spark(五) ----- Transformation和Action介绍</title>
      <link href="/2018/06/05/BigData-Spark5/"/>
      <url>/2018/06/05/BigData-Spark5/</url>
      <content type="html"><![CDATA[<p><img src="/2018/06/05/BigData-Spark5/spark5.1.png" alt="Spark工作原理"><br><a id="more"></a></p><h3 id="transformation和action介绍"><a href="#transformation和action介绍" class="headerlink" title="transformation和action介绍"></a>transformation和action介绍</h3><p>Spark支持两种RDD操作：transformation和action。transformation操作会针对已有的RDD创建一个新的RDD；而action则主要是对RDD进行最后的操作，比如遍历、reduce、保存到文件等，并可以返回结果给Driver程序。</p><p>例如，map就是一种transformation操作，它用于将已有RDD的每个元素传入一个自定义的函数，并获取一个新的元素，然后将所有的新元素组成一个新的RDD。而reduce就是一种action操作，它用于对RDD中的所有元素进行聚合操作，并获取一个最终的结果，然后返回给Driver程序。</p><p>transformation的特点就是lazy特性。lazy特性指的是，如果一个spark应用中只定义了transformation操作，那么即使你执行该应用，这些操作也不会执行。也就是说，transformation是不会触发spark程序的执行的，它们只是记录了对RDD所做的操作，但是不会自发的执行。只有当transformation之后，接着执行了一个action操作，那么所有的transformation才会执行。Spark通过这种lazy特性，来进行底层的spark应用执行的优化，避免产生过多中间结果</p><p>action操作执行，会触发一个spark job的运行，从而触发这个action之前所有的transformation的执行。这是action的特性。</p><p>整个这一块儿，都是在driver节点上执行的，也就是执行我们自己编写的Spark应用程序。但是呢，在action执行之前，所有的transformation都是lazy的，不会立即执行。只有执行了action之后，才会触发job，提交task到Spark集群上，进行实际的执行。<br><img src="/2018/06/05/BigData-Spark5/spark5.1.png" alt="Spark工作原理"></p><h3 id="案例1：统计文件字数"><a href="#案例1：统计文件字数" class="headerlink" title="案例1：统计文件字数"></a>案例1：统计文件字数</h3><p>这里通过一个之前学习过的案例，统计文件字数，来讲解transformation和action。</p><p>这里通过textFile()方法，针对外部文件创建了一个RDD，lines，但是实际上，程序执行到这里为止，spark.txt文件的数据是不会加载到内存中的。lines，只是代表了一个指向spark.txt文件的引用。<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">val lines</span> = sc.textFile(<span class="string">"spark.txt"</span>)</span><br></pre></td></tr></table></figure></p><p>这里对lines RDD进行了map算子，获取了一个转换后的lineLengthsRDD。但是这里连数据都没有，当然也不会做任何操作。lineLengths RDD也只是一个概念上的东西而已。<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val lineLengths  = <span class="keyword">lines</span>.map( <span class="built_in">line</span>=&gt; <span class="built_in">line</span>.<span class="built_in">length</span>)</span><br></pre></td></tr></table></figure></p><p>之列，执行了一个action操作，reduce。此时就会触发之前所有transformation操作的执行，Spark会将操作拆分成多个task到多个机器上并行执行，每个task会在本地执行map操作，并且进行本地的reduce聚合。最后会进行一个全局的reduce聚合，然后将结果返回给Driver程序。<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val totalLength = lineLengths.reduce(<span class="keyword">_</span>+<span class="keyword">_</span>)</span><br></pre></td></tr></table></figure></p><h3 id="案例2：统计文件每行出现的次数"><a href="#案例2：统计文件每行出现的次数" class="headerlink" title="案例2：统计文件每行出现的次数"></a>案例2：统计文件每行出现的次数</h3><p>Spark有些特殊的算子，也就是特殊的transformation操作。比如，groupByKey、sortByKey、reduceByKey等，其实只是针对特殊的RDD的。即包含key-value对的RDD。而这种RDD中的元素，实际上是scala中的一种类型，即Tuple2，也就是包含两个值的Tuple、</p><p>在Scala中，需要手动导入Spark的相关隐式转换，import org.apache.spark.SparkContext._。然后，对应包含Tuple2的RDD，会自动隐式转换为PairRDDFunction，并提供reduceByKey等方法。</p> <figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val <span class="attr">lines</span> = sc.textFile(<span class="string">"hello.txt"</span>)</span><br><span class="line">val <span class="attr">linePairs</span> = lines.<span class="built_in">map</span>( <span class="attr">line</span> =&gt; (line,<span class="number">1</span>))</span><br><span class="line">val <span class="attr">lineCounts</span> = linePairs.reduceByKey(\_+\_)</span><br><span class="line">lineCounts.foreach(<span class="attr">lineCount</span> =&gt; println(lineCount._1+<span class="string">" appears "</span>+lineCount._2+<span class="string">" times."</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spark生态圈之Spark(四) ----- RDD的创建</title>
      <link href="/2018/06/05/BigData-Spark4/"/>
      <url>/2018/06/05/BigData-Spark4/</url>
      <content type="html"><![CDATA[<h3 id="创建RDD"><a href="#创建RDD" class="headerlink" title="创建RDD"></a>创建RDD</h3><p>进行Spark核心编程时，首先要做的第一件事，就是创建一个初始的RDD。该RDD中，通常就代表和包含了Spark应用程序的输入源数据。然后在创建了初始的RDD之后，才可以通过Spark Core提供的Transformation算子，对该RDD进行转换，来获取其他的RDD。</p><p>Spark Core提供了三种创建RDD的方式，包括：使用程序中的集合创建RDD；使用本地文件创建RDD；使用HDFS文件创建RDD。</p><p>1、使用程序中的集合创建RDD，主要用于进行测试，可以在实际部署到集群运行之前，自己使用集合构造测试数据，来测试后面的spark应用的流程</p><p>2、使用本地文件创建RDD，主要用于临时性地处理一些存储了大量数据的文件</p><p>3、使用HDFS文件创建RDD，应该是最常用的生产环境处理方式，主要可以针对HDFS上存储的大数据，进行离线批处理操作。<br><a id="more"></a></p><h4 id="并行化集合创建RDD"><a href="#并行化集合创建RDD" class="headerlink" title="并行化集合创建RDD"></a>并行化集合创建RDD</h4><p>如果要通过并行化集合来创建RDD，需要针对程序中的集合，调用SparkContext的parallelize()方法。Spark会将集合中的数据拷贝到集群上去，形成一个分布式的数据集合，也就是一个RDD。相当于是，集合中的部分数据会到一个节点上，而另一部分数据会到其他节点上。然后就可以用并行的方式来操作这个分布式数据集合，即RDD。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val arr = Array(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>)</span><br><span class="line">val rdd = sc.parallelize(arr)</span><br><span class="line">val sum = rdd.reduce(_+_)</span><br></pre></td></tr></table></figure><p>调用parallelize()时，有一个重要的参数可以指定，就是要将集合切分成多少个partition。Spark会为每一个partition运行一个task来进行处理。Spark官方的建议是，为集群中的每个CPU创建2~4个partition。Spark默认会根据集群的情况来设置partition的数量。但是也可以在调用parallelize()方法时，传入第二个参数，来设置RDD的partition数量。比如parallelize(arr,10)</p><h4 id="使用本地文件和HDFS创建RDD"><a href="#使用本地文件和HDFS创建RDD" class="headerlink" title="使用本地文件和HDFS创建RDD"></a>使用本地文件和HDFS创建RDD</h4><p>Spark是支持使用任何Hadoop支持的存储系统上的文件创建RDD的，比如说HDFS、Cassandra、HBase以及本地文件。通过调用SparkContext的textFile()方法，可以针对本地文件或HDFS文件创建RDD</p><p>有几个事项要需要注意的：</p><p>1、如果是针对本地文件的话，如果是在windows上本地测试，windows上有一份文件即可；如果是在Spark集群上针对linux本地文件，那么需要将文件拷贝到所有worker节点上。</p><p>2、Spark的textFile()方法支持针对目录、压缩文件以及通配符进行RDD创建</p><p>3、Spark默认会为hdfs文件的每一个block创建一个partition，但是也可以通过textFile()第二个参数手动设置分区数量，只能比block数量多，不能比block数量少。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val rdd = sc.textFile(<span class="string">"data.txt"</span>)</span><br><span class="line"></span><br><span class="line">val wordCount = rdd.<span class="built_in">map</span>(line =&gt; line.<span class="built_in">length</span>).reduce(<span class="symbol">_</span>+<span class="symbol">_</span>)</span><br></pre></td></tr></table></figure><p>Spark的textFile()除了可以针对上述几种普通的文件创建RDD之外，还有一些特列的方法来创建RDD:</p><p>1、SparkContext.wholeTextFiles()方法，可以针对一个目录中的大量小文件，返回&lt;filename,fileContent&gt;组成的pair，作为一个PairRDD，而不是普通的RDD。普通的textFile()返回的RDD中，每个元素就是文件中的一行文本。</p><p>2、SparkContext.sequenceFile[K,V]()方法，可以针对SequenceFile创建RDD，K和V泛型类型就是SequenceFile的key和value的类型。K和V要求必须是Hadoop的序列化类型，比如IntWritable、Text等。</p><p>3、SparkContext.hadoopRDD()方法，对于Hadoop的自定义输入类型，可以创建RDD。该方法接收JobConf、InputFormatClass、Key和Value的Class。</p><p>4、SparkContext.objectFile()方法，可以针对之前调用RDD.saveAsObjectFile()创建的对象序列化的文件，反序列化文件中的数据，并创建一个RDD。</p>]]></content>
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>随笔(三)</title>
      <link href="/2018/06/04/jottings-3/"/>
      <url>/2018/06/04/jottings-3/</url>
      <content type="html"><![CDATA[<p><img src="/2018/06/04/jottings-3/jottings-3.jpg" alt="jottings"><br><a id="more"></a></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=479598964&auto=1&height=66"></iframe><center>害怕岁月静好无人来扰<br>害怕诗人渐老穷困潦倒<br>害怕绿惹芭蕉晚风潇潇<br>害怕路途陡峭空水几瓢<br>害怕流年尽抛知音难找<br>害怕夜半轻悄同为寂寥<br>害怕共度一朝无人说道<br>害怕时光渐消不成玩笑<br>害怕孤独高傲酿成毒药<br>害怕青春走掉再无吵闹<br>害怕深夜嚎叫影过石桥<br>害怕自持年少过往焚烧<br>害怕无人依靠苦涩情调<br>害怕所有的以梦为马都没必要<br>终了</center>]]></content>
      
      <categories>
          
          <category> thoughts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jottings </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spark生态圈之Spark(三) ----- Spark架构原理</title>
      <link href="/2018/05/25/BigData-Spark3/"/>
      <url>/2018/05/25/BigData-Spark3/</url>
      <content type="html"><![CDATA[<p><img src="/2018/05/25/BigData-Spark3/spark1.png" alt="Spark工作原理"><br><a id="more"></a></p><h3 id="Spark框架原理"><a href="#Spark框架原理" class="headerlink" title="Spark框架原理"></a>Spark框架原理</h3><p>Driver：我们编写的Spark程序就在Driver上</p><p>Master: 其实主要负责资源的调度和分配，还有集群的监控，等等职责</p><p>Worker：主要是负责两个，一个是用自己的内存存储RDD的某个或某些partition；另一个是启动其他进程和线程，对RDD上的partition进行版型的处理和计算</p><p>Executor和Task： Executor和Task，其实就是负责执行对RDD的partition进行并行的计算了，也就是执行我们对RDD定义的，比如map、flatMap、reduce等算子操作</p><p>1、Driver进程启动之后，会做一些初始化的操作；在这个过程中，就会发送请求到Master上，进行Spark应用程序的注册，说白了，就是让Master知道，有一个新的Spark应用程序要运行。</p><p>2、Master，在接收到了Spark应用程序的注册申请之后，会发送请求给Worker，进行资源的调度和分配，ok，说白了，说穿了，资源分配，就是executor的分配。</p><p>3、Worker接收到Master的请求之后，会为Spark应用程序启动Executor</p><p>4、Executor启动之后，会向Driver进行反注册。这样，Driver就知道，哪些Executor是为它进行服务的了。</p><p>5、Driver注册了一些executor之后，就可以开始正式执行我们的spark应用程序了，首先第一步，就是，创建初始RDD，读取数据源</p><p>6、HDFS文件内容被读取到多个worker节点上，形成内存中的分布式数据集，也就是初始RDD</p><p>7、Driver会根据我们对RDD定义的操作，提交一大堆task去executor上，executor接收到task之后，会启动多个线程来执行task</p><p>8、task就会对RDD的partition数据执行指定的算子操作，形成新的RDD的partition</p>]]></content>
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spark生态圈之Spark(二) ----- WordCount程序原理</title>
      <link href="/2018/05/25/BigData-Spark2/"/>
      <url>/2018/05/25/BigData-Spark2/</url>
      <content type="html"><![CDATA[<p><img src="/2018/05/25/BigData-Spark2/spark1.png" alt="Spark工作原理"><br><a id="more"></a></p><h3 id="Java开发WordCount"><a href="#Java开发WordCount" class="headerlink" title="Java开发WordCount"></a>Java开发WordCount</h3><p>用Java开发wordcount程序：<br>1、配置Maven环境<br>2、如何进行本地测试<br>3、如何使用spark-submit提交到spark集群进行执行(spark-submit常用参数说明，spark-submit其实就类似于hadoop的hadoop jar命令)</p><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p>创建SparkConf对象，设置spark应用的配置信息使用setMaster()可以设置Spark应用程序要连接的spark集群的master节点的url，但是如果设置为local则代表在本地运行<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">SparkConf conf</span> = new SparkConf().setAppName(<span class="string">"SparkJava"</span>).setMaster(<span class="string">"local"</span>);</span><br></pre></td></tr></table></figure></p><h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p>创建JavaSparkContext对象</p><p>在Spark中，SparkContext是spark所有功能的一个入口，你无论是用java，scala，甚至是python编写<br>都必须要有一个SparkContext，他的主要作用，包括初始化Spark应用程序所需的一些核心组件，包括<br>调度器(DAGSchedule、TaskScheduler),还会去到Spark Master节点上进行注册，等等<br>一句话，SparkContext，是Spark应用中，可以说是最最重要的一个对象<br>但是呢，在spark中，编写不同类型的spark应用程序，使用的SparkContext是不同的，如果使用scala，<br>使用的就是原生的SparkContext对象<br>但是如果使用Java，那么就是JavaSparkContext对象<br>如果是开发Spark SQL程序，那么就是SQLContext、HiveContext<br>如果是开发 Spark Streaming程序，那么就是它独有的SparkContext以此类推<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">JavaSparkContext sc</span> = new JavaSparkContext(conf);</span><br></pre></td></tr></table></figure></p><h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><p>要针对输入源(HDFS、本地文件、等等)，创建一个初始的RDD</p><p>输入源中的数据会打散，分配到RDD的每个partition中，从而形成一个初始的分布式的数据集<br>我们这里呢，因为是本地测试，所以呢，就是针对本地文件<br>SparkContext中，用于根据文件类型的输入源创建RDD的方法，叫做textFile()方法<br>在Java中，创建的普通RDD，都叫做JavaRDD<br>在这里呢，RDD中，有元素这种概念，如果是HDFS或者本地文件呢，创建的RDD，每一个元素就相当于是文件里的一行<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JavaRDD&lt;String&gt; lines = sc.textFile(<span class="string">"C://MyWork-Study//Spark//课件//第29讲-Spark核心编程：使用Java、Scala和spark-shell开发wordcount程序//文档//spark.txt"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><h4 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h4><p>对初始RDD进行transformation操作，也就是一些计算操作</p><p>通常操作会通过创建function，并配合RDD的map、flatMap等算子来执行function<br>通常，如果比较简单，则创建指定Function的匿名内部类<br>但是如果function比较复杂，则会单独创建一个类，作为实现这个function接口的类<br>先将每一行拆分成单个的单词<br>FlatMapFunction，有两个泛型参数，分别代表了输入和输出<br>我们这里呢，输入肯定是String，因为是一行一行的文本，输出，其实也是String，因为是每一行的文本<br>这里先简要介绍flatMap算子的作用，其实就是，将RDD的一个元素，给拆分成一个或多个元素<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JavaRDD&lt;<span class="keyword">String</span>&gt; words = lines.flatMap(<span class="keyword">new</span> FlatMapFunction&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt;() &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> servialVersionUID = <span class="number">1</span>L;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">public</span> Iterator&lt;<span class="keyword">String</span>&gt; call(<span class="keyword">String</span> <span class="built_in">line</span>) <span class="keyword">throws</span> Exception</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">return</span> (Iterator&lt;<span class="keyword">String</span>&gt;) Arrays.asList(<span class="built_in">line</span>.<span class="built_in">split</span>(<span class="string">" "</span>));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure></p><h4 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h4><p>接着，需要将每一个单词，映射为(单词，1))的这种格式<br>因为只有这样，后面才能根据单词作为key，来进行每个单词的出现次数的累加<br>mapToPair，其实就是将每个元素，映射为一个(v1,v2)这样的Tuple2类型的元素<br>如果大家还记得Scala里面讲的tuple，那么没错，这里的tuple2就是scala类型，包含了两个值<br>mapToPair这个算子，要求的是与PairFunction配合使用，第一个泛型参数代表了输入类型<br>第二个和第三个泛型参数，代表的输出的Tuple2的第一个值和第二个值的类型<br>JavaPairRDD的两个泛型参数，分别代表了Tuple元素的第一个值和第二个值的类型<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JavaPairRDD&lt;<span class="keyword">String</span>, Integer&gt; pairs = words.mapToPair(</span><br><span class="line">        <span class="keyword">new</span> PairFunction&lt;<span class="keyword">String</span>, <span class="keyword">String</span>, Integer&gt;() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">long</span> serialVersionUDI = <span class="number">1</span>L;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Tuple2&lt;<span class="keyword">String</span>, Integer&gt; call(<span class="keyword">String</span> <span class="keyword">word</span>) throws Exception &#123;</span><br><span class="line">        <span class="built_in">return</span> <span class="keyword">new</span> Tuple2&lt;<span class="keyword">String</span>, Integer&gt;(<span class="keyword">word</span>,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="第六步"><a href="#第六步" class="headerlink" title="第六步"></a>第六步</h4><p>接着，需要以单词作为key，统计每个单词出现的次数<br>这里要使用reduceByKey这个算子，对每个key对应的value，都进行reduce操作<br>比如JavaPairRDD中有几个元素，分别为(hello，1) (hello,1) (world,1)<br>比如这里的hello，那么就相当于是，首先是1 + 1 = 2，然后再将2 + 1 = 3<br>最后返回的JavaPairRDD中的元素，也是tuple，但是第一个值就是每个key，第二个值就是key的value<br>reduce之后的结果，相当于就是每个单词出现的次数<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wordCounts.foreach(</span><br><span class="line">        <span class="keyword">new</span> VoidFunction&lt;Tuple2&lt;<span class="keyword">String</span>, Integer&gt;&gt;() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> call(Tuple2&lt;<span class="keyword">String</span>, Integer&gt; wordcount) throws Exception &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(wordcount._1+<span class="string">" appeared "</span>+wordcount._2+<span class="string">" times."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">sc.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure></p><h3 id="程序提交"><a href="#程序提交" class="headerlink" title="程序提交"></a>程序提交</h3><p>一旦打包好,就可以使用bin/spark-submit脚本启动应用了. 这个脚本负责设置spark使用的classpath和依赖,支持不同类型的集群管理器和发布模式:<br>./bin/spark-submit \<br>  --class <main-class><br>  --master <master-url> \<br>      --deploy-mode <deploy-mode> \<br>  --conf <key>=<value> \<br>  … # other options<br>  <application-jar> \<br>  [application-arguments]<br>一些常用选项:<br>1)    --class: 你的应用的启动类 (如 org.apache.spark.examples.SparkPi)<br>2)    --master: 集群的master URL (如 spark://23.195.26.187:7077)<br>3)    --deploy-mode: 是否发布你的驱动到worker节点(cluster) 或者作为一个本地客户端 (client) (default: client)*<br>4)    --conf: 任意的Spark配置属性， 格式key=value. 如果值包含空格，可以加引号“key=value”. 缺省的Spark配置<br>5)    application-jar: 打包好的应用jar,包含依赖. 这个URL在集群中全局可见。 比如hdfs:// 共享存储系统， 如果是 file:// path， 那么所有的节点的path都包含同样的jar.<br>6)    application-arguments: 传给main()方法的参数</application-jar></value></key></deploy-mode></master-url></main-class></p><p>local    本地以一个worker线程运行(例如非并行的情况).<br>local[K]    本地以K worker 线程 (理想情况下, K设置为你机器的CPU核数).<br>local[*]    本地以本机同样核数的线程运行.<br>spark://HOST:PORT    连接到指定的Spark standalone cluster master. 端口是你的master集群配置的端口，缺省值为7077.<br>mesos://HOST:PORT    连接到指定的Mesos 集群. Port是你配置的mesos端口， 缺省是5050. 或者如果Mesos使用ZOoKeeper,格式为 mesos://zk://….<br>yarn-client    以client模式连接到YARN cluster. 集群的位置基于HADOOP_CONF_DIR 变量找到.<br>yarn-cluster    以cluster模式连接到YARN cluster. 集群的位置基于HADOOP_CONF_DIR 变量找到.</p><p>例如：</p><blockquote><p><strong>$</strong> spark2-submit \<br>--class com.scala.wordcount.WordCount<br>--num-executors 3 \<br>--driver-memory 1G \<br>--executor-memory 1G \<br>--executor-cores 3 \<br>/home/richard/wordcount-jar-with-dependencies.jar \<br>100</p></blockquote><h3 id="WordCount程序原理"><a href="#WordCount程序原理" class="headerlink" title="WordCount程序原理"></a>WordCount程序原理</h3><p><img src="/2018/05/25/BigData-Spark2/spark1.png" alt="Spark工作原理"></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">val conf = <span class="built_in">new</span> SparkConf().setAppName(<span class="string">"WordCount"</span>)</span><br><span class="line"></span><br><span class="line">val sc = <span class="built_in">new</span> SparkContext(conf)</span><br><span class="line"></span><br><span class="line">val <span class="keyword">lines</span> = sc.textFile(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">val <span class="keyword">words</span> = <span class="keyword">lines</span>.flatMap(<span class="built_in">line</span> =&gt; <span class="built_in">line</span>.<span class="built_in">split</span>(<span class="string">" "</span>))</span><br><span class="line"></span><br><span class="line">val pairs = <span class="keyword">words</span>.map(<span class="built_in">word</span> =&gt; (<span class="built_in">word</span>,<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">val wordCounts = pairs.reduceByKey(\_+\_)</span><br><span class="line"></span><br><span class="line">wordCount.foreach(wordCount =&gt; println(wordCount.<span class="title">_1</span> + <span class="string">" appears "</span>+wordCount.<span class="title">_2</span> + <span class="string">" times."</span>))</span><br></pre></td></tr></table></figure><p><img src="/2018/05/25/BigData-Spark2/spark2.png" alt="Spark工作原理"></p><p>这个过程，所有的算子，都是在相同节点内进行的，这里就体现出了分布式、内存、迭代式计算，等几个spark最显著的计算模型和特点。也是Spark叫MapReduce这种计算模型速度更快的原因，MR的话，实现这个过程，必须要跨节点，走磁盘读写，没有内存式、迭代式计算的特点。<br>这就是所谓Spark的分布式、内存式、迭代式的计算模型，也是Spark之所以速度比MapReduce更快的原因。如果是MR，就必须走磁盘读写，速度必然降低。</p>]]></content>
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spark生态圈之Spark(一) ----- Spark工作原理与RDD</title>
      <link href="/2018/05/25/BigData-Spark1/"/>
      <url>/2018/05/25/BigData-Spark1/</url>
      <content type="html"><![CDATA[<p><img src="/2018/05/25/BigData-Spark1/spark1.png" alt="Spark工作原理"><br><a id="more"></a></p><h3 id="Spark工作原理"><a href="#Spark工作原理" class="headerlink" title="Spark工作原理"></a>Spark工作原理</h3><p>1、分布式<br>2、主要基于内存(少数情况基于磁盘)<br>3、迭代式运算</p><p>spark与MapReduce最大的不同在于，迭代式计算模型：Mapreduce，分为两个阶段，map和reduce，两个阶段完了，就结束了，所以我们在一个job里能做的处理很有限，spark计算模型，可以分为n个阶段，因为他是内存迭代式的，我们在处理完一个阶段以后，可以继续往下处理很多个阶段，而不只是两个阶段。所以，spark相较于Mapreduce来说，计算模型可以提供更强大的功能。</p><p><img src="/2018/05/25/BigData-Spark1/spark1.png" alt="Spark工作原理"></p><p>Spark的核心编程其实就是：</p><p>第一，定义初始的RDD，就是说，你要定义第一个RDD是从哪里读取数据，HDFS，linux本地文件，程序中的集合。<br>第二，定义对RDD的计算操作，这个在Spark里称之为算子，map，reduce，flatMap，groupByKey，比mapreduce提供的map和reduce强大的太多太多了。<br>第三，其实就是循环往复的过程，第一个计算完了以后，数据可能就会到了新的一批节点上，也就是变成一个新的RDD，然后再次反复，针对新的RDD定义计算操作。。。。<br>第四，最后获得最终的数据，将数据保存起来。</p><h3 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h3><p>1、RDD是spark提供的核心抽象，全称为Resillient Distributed Dataset，即弹性分布式数据集<br>2、RDD在抽象上来说是一种元素集合，包含了数据，它是被分区的，分为多个分区，每个分区分布在集群中的不同节点上，从而让RDD中的数据可以被并行操作(分布式数据集)<br>3、RDD通常通过Hadoop上的文件，即HDFS文件或者Hive表，来进行创建；有时也可以通过应用程序中的集合来创建。<br>4、RDD最重要的特性就是，提供了容错性，可以自动从节点失败中恢复过来。即如果某个节点上的RDD partition，因为节点故障，导致数据丢了，那么RDD会自动通过自己的数据来源重新计算该partition。这一切对使用者是透明的。<br>5、RDD的数据默认情况下存放在内存中的，但是在内存资源不足时，Spark会自动将RDD数据写入磁盘。(弹性)</p><p><img src="/2018/05/25/BigData-Spark1/spark2.png" alt="Spark工作原理"><br>一个RDD，在逻辑上，抽象地代表了一个HDFS文件，但是，它实际上是被分区得，分为多个分区。多个分区散落在Spark集群中，不同的节点上，比如说，RDD有90万数据；分为9个partition，9个分区。</p><p><img src="/2018/05/25/BigData-Spark1/spark3.png" alt="Spark工作原理"><br>现在，节点9出了些故障，导致partition9的数据丢失了，那么此时Spark会脆弱到直接报错，直接挂掉吗？不可能！！<br> RDD是有很强的容错性的，当它发现自己的数据丢失了以后，会自动从自己来源的数据进行重计算，重新获取自己这份数据，这一切对用户，都是完全透明的。</p><p><img src="/2018/05/25/BigData-Spark1/spark4.png" alt="Spark工作原理"><br>RDD的每个partition，在spark节点上存储时，默认都是放在内存中的，但是如果说内存放不下这么多数据时，比如每个节点最多放5万数据，结果你每个partition是10万数据，那么就会把partition中的部分数据写入磁盘上，进行保存。<br>而上述这一切对于用户来说，都是完全透明的。你不用去管RDD的数据存储在哪里，内存还是磁盘，只要关注，你针对RDD来进行计算和处理，等等操作即可。<br>所以说，RDD的这种自动进行内存和磁盘之间权衡和切换的机制，就是RDD的弹性的特点所在。</p><h3 id="Spark开发"><a href="#Spark开发" class="headerlink" title="Spark开发"></a>Spark开发</h3><p>1、核心开发：离线批处理 / 延迟性的交互式数据处理<br>2、SQL查询 ： 底层都是RDD和计算操作<br>3、实时计算 ： 底层都是RDD和计算操作</p>]]></content>
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spark </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>随笔(二)</title>
      <link href="/2018/05/18/jottings-2/"/>
      <url>/2018/05/18/jottings-2/</url>
      <content type="html"><![CDATA[<p><img src="/2018/05/18/jottings-2/jottings2.jpg" alt="jottings"><br><a id="more"></a></p><p>太好了，太好了。我也算卸下包袱，这下总算可以回去了。<br>你这人还真是的，<br>又冒失，<br>又愚蠢，<br>又厌学，<br>有懦弱，<br>又懒惰，<br>又迟钝，<br>运动又不行，<br>又胆小，<br>又糊涂，<br>又不可靠….<br>又讨厌麻烦….<br>又没出息….<br>记性又差….<br>是个老好人….<br>还总是得意忘形….<br>又爱撒娇….</p><p>咦？</p><p>该怎么办呢？还真是伤脑筋啊！！！</p>]]></content>
      
      <categories>
          
          <category> thoughts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jottings </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python科学计算库 ----- Numpy</title>
      <link href="/2018/05/17/Python-Numpy/"/>
      <url>/2018/05/17/Python-Numpy/</url>
      <content type="html"><![CDATA[<h3 id="Numpy基础结构"><a href="#Numpy基础结构" class="headerlink" title="Numpy基础结构"></a>Numpy基础结构</h3><p>按照”,”分隔，以str形式读取txt文件<br>type():数据类型<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line">world_alcohol = numpy.genfromtxt(<span class="string">"world_alcohol.txt"</span>, delimiter=<span class="string">","</span>,dtype=str)</span><br><span class="line">print(type(world_alcohol))</span><br><span class="line">print(world_alcohol)</span><br><span class="line">print(help(numpy.genfromtxt))</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>读取array数组<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector = numpy.array([<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>])</span><br><span class="line"></span><br><span class="line">matrix = numpy.array([[<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>],[<span class="number">20</span>,<span class="number">25</span>,<span class="number">30</span>],[<span class="number">35</span>,<span class="number">40</span>,<span class="number">45</span>]])</span><br><span class="line"><span class="keyword">print</span> vector</span><br><span class="line"><span class="keyword">print</span> matrix</span><br></pre></td></tr></table></figure></p><p>shape显示数组的维度<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector = numpy.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">print(vector.shape)</span><br><span class="line"></span><br><span class="line">matrix = numpy.array([[<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>],[<span class="number">20</span>,<span class="number">25</span>,<span class="number">30</span>]])</span><br><span class="line">print(matrix.shape)</span><br></pre></td></tr></table></figure></p><p>dtype:数组元素类型<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line">numbers = numpy.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">print(numbers)</span><br><span class="line">numbers.dtype</span><br></pre></td></tr></table></figure></p><p>skip_header:略过多少行从 n+1行开始读取数据<br>[m,n]\:第m+1行、第n+1列数据<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">world_alcohol = numpy.genfromtxt(<span class="string">"world_alcohol.txt"</span>,delimiter=<span class="string">","</span>,dtype=str,skip_header=<span class="number">1</span>)</span><br><span class="line">print(world_alcohol)</span><br><span class="line"><span class="comment"># print(world_alcohol.shape)</span></span><br><span class="line"></span><br><span class="line">uruguay_other_1986 = world_alcohol[<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">third_country = world_alcohol[<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line">print(uruguay_other_1986)</span><br><span class="line">print(third_country)</span><br></pre></td></tr></table></figure></p><p>读取数组1~3列的数据<br><figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vector</span> = numpy.<span class="keyword">array</span>([<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>])</span><br><span class="line"><span class="keyword">print</span>(<span class="keyword">vector</span>[<span class="number">0</span>:<span class="number">3</span>])</span><br></pre></td></tr></table></figure></p><p>[:,n] \: 读取所有行第n+1列的数据<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">matrix = numpy.array(<span class="comment">[</span></span><br><span class="line"><span class="comment">    <span class="comment">[5,10,15]</span>,</span></span><br><span class="line"><span class="comment">    <span class="comment">[20,25,30]</span>,</span></span><br><span class="line"><span class="comment">    <span class="comment">[35,40,45]</span></span></span><br><span class="line"><span class="comment">]</span>)</span><br><span class="line">print(matrix<span class="comment">[:,1]</span>)</span><br></pre></td></tr></table></figure></p><p>[:,0:2] \: 读取所有行第1~2列的数据<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">matrix = numpy.array(<span class="comment">[</span></span><br><span class="line"><span class="comment">    <span class="comment">[5,10,15]</span>,</span></span><br><span class="line"><span class="comment">    <span class="comment">[20,25,30]</span>,</span></span><br><span class="line"><span class="comment">    <span class="comment">[35,40,45]</span></span></span><br><span class="line"><span class="comment">]</span>)</span><br><span class="line">print(matrix<span class="comment">[:,0:2]</span>)</span><br></pre></td></tr></table></figure></p><p>[1:3,0:2] \: 读取数组的第2~3行，第1~2列数据<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">matrix = numpy.array(<span class="comment">[</span></span><br><span class="line"><span class="comment">    <span class="comment">[5,10,15]</span>,</span></span><br><span class="line"><span class="comment">    <span class="comment">[20,25,30]</span>,</span></span><br><span class="line"><span class="comment">    <span class="comment">[35,40,45]</span></span></span><br><span class="line"><span class="comment">]</span>)</span><br><span class="line">print(matrix<span class="comment">[1:3,0:2]</span>)</span><br></pre></td></tr></table></figure></p><h3 id="Numpy矩阵基础"><a href="#Numpy矩阵基础" class="headerlink" title="Numpy矩阵基础"></a>Numpy矩阵基础</h3><p>== : 返回boolean型 [False,True,False,False]<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vector</span> = numpy.array([<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>])</span><br><span class="line">print(<span class="type">vector</span>==<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">matrix = numpy.array([</span><br><span class="line">    [<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>],</span><br><span class="line">    [<span class="number">20</span>,<span class="number">25</span>,<span class="number">30</span>],</span><br><span class="line">    [<span class="number">35</span>,<span class="number">40</span>,<span class="number">45</span>]</span><br><span class="line">])</span><br><span class="line">print(matrix == <span class="number">25</span>)</span><br></pre></td></tr></table></figure></p><p>根据==返回的boolean数组，可以通过boolean数组，从原数据中获取数据<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vector</span> = numpy.array([<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>])</span><br><span class="line">equal_to_ten = (<span class="type">vector</span> == <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">print(equal_to_ten)</span><br><span class="line">print(<span class="type">vector</span>[equal_to_ten])</span><br></pre></td></tr></table></figure></p><p>根据matrix[:,1]==25的条件获取所在列的boolean数组，可以根据boolean数组找到原数据<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">matrix = numpy.array(<span class="comment">[</span></span><br><span class="line"><span class="comment">    <span class="comment">[5,10,15]</span>,</span></span><br><span class="line"><span class="comment">    <span class="comment">[20,25,30]</span>,</span></span><br><span class="line"><span class="comment">    <span class="comment">[35,40,45]</span></span></span><br><span class="line"><span class="comment">]</span>)</span><br><span class="line">second_column_25 = (matrix<span class="comment">[:,1]</span>==25)</span><br><span class="line">print(second_column_25)</span><br><span class="line">print(matrix<span class="comment">[second_column_25,:]</span>)</span><br></pre></td></tr></table></figure></p><p>条件与 : &amp;<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import numpy</span><br><span class="line"><span class="type">vector</span> = numpy.array([<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>])</span><br><span class="line">equal_to_ten_and_five = (<span class="type">vector</span>==<span class="number">10</span>) &amp; (<span class="type">vector</span>==<span class="number">5</span>)</span><br><span class="line">print(equal_to_ten_and_five)</span><br></pre></td></tr></table></figure></p><p>条件或 ： |</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vector</span> = numpy.array([<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>])</span><br><span class="line">equal_to_ten_or_five = (<span class="type">vector</span> == <span class="number">10</span>) | (<span class="type">vector</span> == <span class="number">5</span>)</span><br><span class="line">print(equal_to_ten_or_five)</span><br></pre></td></tr></table></figure><p>根据[:,1]==25的boolean数据条件更改原数组数据<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">matrix</span> = numpy.<span class="built_in">array</span>([</span><br><span class="line">    [<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>],</span><br><span class="line">    [<span class="number">20</span>,<span class="number">25</span>,<span class="number">30</span>],</span><br><span class="line">    [<span class="number">35</span>,<span class="number">40</span>,<span class="number">45</span>]</span><br><span class="line">])</span><br><span class="line">second_column_25 = <span class="built_in">matrix</span>[:,<span class="number">1</span>] == <span class="number">25</span></span><br><span class="line"><span class="built_in">print</span>(second_column_25)</span><br><span class="line"><span class="built_in">matrix</span>[second_column_25,<span class="number">1</span>] = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">matrix</span>)</span><br></pre></td></tr></table></figure></p><p>astype:类型转换<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector = numpy.array([<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>])</span><br><span class="line">print(vector.dtype)</span><br><span class="line">print(vector)</span><br><span class="line">vector = vector.astype(float)</span><br><span class="line">print(vector.dtype)</span><br><span class="line">print(vector)</span><br></pre></td></tr></table></figure></p><h3 id="Numpy常用函数"><a href="#Numpy常用函数" class="headerlink" title="Numpy常用函数"></a>Numpy常用函数</h3><p>min:数组最小值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector = numpy.array([<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>])</span><br><span class="line">print(vector.min())</span><br></pre></td></tr></table></figure></p><p>axis=1 按行求和<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">matrix = numpy.array([</span><br><span class="line">    [<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>],</span><br><span class="line">    [<span class="number">20</span>,<span class="number">25</span>,<span class="number">30</span>],</span><br><span class="line">    [<span class="number">35</span>,<span class="number">40</span>,<span class="number">45</span>]</span><br><span class="line">])</span><br><span class="line">print(matrix.sum(axis=<span class="number">1</span>))</span><br></pre></td></tr></table></figure></p><p>axis=0 按列求和<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">matrix = numpy.array([</span><br><span class="line">    [<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>],</span><br><span class="line">    [<span class="number">20</span>,<span class="number">25</span>,<span class="number">30</span>],</span><br><span class="line">    [<span class="number">35</span>,<span class="number">40</span>,<span class="number">45</span>]</span><br><span class="line">])</span><br><span class="line">print(matrix.sum(axis=<span class="number">0</span>))</span><br></pre></td></tr></table></figure></p><p>arange(n): 0~n-1的值<br>reshape : 更改数组维度<br>ndim : 数组维度(比如二维数组、三维数组等)<br>dtype : 数据类型<br>size : 大小<br>zeros((m,n)) : 二维值都为0的数组<br>ones((a,b,c)):三维值都为1的数组</p><p>arange(a,b,c) :按照c跳值<br>np.random.random : 随机值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">print(np.arange(<span class="number">15</span>))</span><br><span class="line">a = np.arange(<span class="number">15</span>).reshape(<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(a.shape)</span><br><span class="line"></span><br><span class="line">print(a.ndim) <span class="comment">#维度</span></span><br><span class="line"></span><br><span class="line">print(a.dtype.name)</span><br><span class="line"></span><br><span class="line">print(a.size)</span><br><span class="line"></span><br><span class="line">print(np.zeros((<span class="number">3</span>,<span class="number">4</span>)))</span><br><span class="line"></span><br><span class="line">print(np.ones((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>),dtype=np.int32))</span><br><span class="line"></span><br><span class="line">print(np.arange(<span class="number">10</span>,<span class="number">30</span>,<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">print(np.arange(<span class="number">0</span>,<span class="number">2</span>,<span class="number">0.3</span>))</span><br><span class="line"></span><br><span class="line">print(np.arange(<span class="number">12</span>).reshape(<span class="number">4</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">print(np.random.random((<span class="number">2</span>,<span class="number">3</span>)))</span><br></pre></td></tr></table></figure></p><h3 id="矩阵常用操作"><a href="#矩阵常用操作" class="headerlink" title="矩阵常用操作"></a>矩阵常用操作</h3><p>**2 : 平方<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>])</span><br><span class="line">b = np.arange(<span class="number">4</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line">c= a-b</span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line">b**<span class="number">2</span></span><br><span class="line">print(b**<span class="number">2</span>)</span><br><span class="line">print(a&lt;<span class="number">35</span>)</span><br></pre></td></tr></table></figure></p><p>.dot : 矩阵相乘<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">A = np.array([[<span class="number">1</span>,<span class="number">1</span>],</span><br><span class="line">              [<span class="number">0</span>,<span class="number">1</span>]])</span><br><span class="line"></span><br><span class="line">B = np.array([[<span class="number">2</span>,<span class="number">0</span>],</span><br><span class="line">              [<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">print(A)</span><br><span class="line">print(<span class="string">"--------"</span>)</span><br><span class="line">print(B)</span><br><span class="line">print(<span class="string">"--------"</span>)</span><br><span class="line">print(A* B)</span><br><span class="line">print(<span class="string">"--------"</span>)</span><br><span class="line">print(A.dot(B))</span><br><span class="line">print(<span class="string">"--------"</span>)</span><br><span class="line">print(np.dot(A,B))</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">B = np.arange(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">print(B)</span><br><span class="line">print(np.exp(B))  <span class="comment"># e的多少次幂</span></span><br><span class="line">print(np.sqrt(B))  <span class="comment"># 开根号</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"-----------------------"</span>)</span><br><span class="line">a = np.floor(<span class="number">10</span>*np.random.random((<span class="number">3</span>,<span class="number">4</span>)))</span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">"-----------------------"</span>)</span><br><span class="line"></span><br><span class="line">print(a.ravel())   <span class="comment">#把矩阵拉成向量</span></span><br><span class="line">print(<span class="string">"-----------------------"</span>)</span><br><span class="line"></span><br><span class="line">a.shape = (<span class="number">6</span>,<span class="number">2</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">"-----------------"</span>)</span><br><span class="line">print(a.T)</span><br><span class="line"></span><br><span class="line">print(a.reshape(<span class="number">4</span>,<span class="number">-1</span>))</span><br></pre></td></tr></table></figure><p>hstack : 矩阵拼接<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"---"</span>)</span><br><span class="line">a = np.floor(<span class="number">10</span>*np.random.random((<span class="number">2</span>,<span class="number">3</span>)))</span><br><span class="line">b = np.floor(<span class="number">10</span>*np.random.random((<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">"---"</span>)</span><br><span class="line">print(b)</span><br><span class="line">print(<span class="string">"---"</span>)</span><br><span class="line">print(np.hstack((a,b)))   <span class="comment">#横着对矩阵进行拼接</span></span><br><span class="line"></span><br><span class="line">a = np.floor(<span class="number">10</span>*np.random.random((<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line">b = np.floor(<span class="number">10</span>*np.random.random((<span class="number">2</span>,<span class="number">2</span>)))</span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">"----"</span>)</span><br><span class="line">print(b)</span><br><span class="line">print(<span class="string">"----"</span>)</span><br><span class="line">print(np.vstack((a,b)))     <span class="comment">#竖着对矩阵进行拼接</span></span><br></pre></td></tr></table></figure></p><p>hsplit:矩阵切割<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"========="</span>)</span><br><span class="line">a = np.floor(<span class="number">10</span>*np.random.random((<span class="number">2</span>,<span class="number">12</span>)))</span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">"-----"</span>)</span><br><span class="line">print(np.hsplit(a,<span class="number">3</span>))</span><br><span class="line">print(<span class="string">"-----"</span>)</span><br><span class="line">print(np.hsplit(a,(<span class="number">3</span>,<span class="number">4</span>)))</span><br><span class="line">a = np.floor(<span class="number">10</span>*np.random.random((<span class="number">12</span>,<span class="number">2</span>)))</span><br><span class="line">print(<span class="string">"-----"</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(np.vsplit(a,<span class="number">3</span>))</span><br></pre></td></tr></table></figure></p><p>矩阵的arg找index、排序：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">data = np.sin(np.arange(<span class="number">20</span>)).reshape(<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">print(data)</span><br><span class="line">ind = data.argmax(axis=<span class="number">0</span>)                  <span class="comment">#axis = 0 按照列，找每一列的最大值所在的index</span></span><br><span class="line">print(ind)</span><br><span class="line">data_max = data[ind,range(data.shape[<span class="number">1</span>])]</span><br><span class="line">print(data_max)</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">40</span>,<span class="number">10</span>)</span><br><span class="line">print(a)</span><br><span class="line">b = np.tile(a,(<span class="number">3</span>,<span class="number">5</span>))     <span class="comment">#对矩阵进行扩展</span></span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = np.array(\[[<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>\],\[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>\]])</span><br><span class="line">print(a)</span><br><span class="line">print(<span class="string">"---------"</span>)</span><br><span class="line">b = np.sort(a,axis=<span class="number">1</span>)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">a.sort(axis=<span class="number">1</span>)</span><br><span class="line">print(<span class="string">"---------"</span>)</span><br><span class="line">print(a)</span><br><span class="line">a = np.array(\[<span class="number">4</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>\])</span><br><span class="line">j = np.argsort(a)          <span class="comment">#找的index</span></span><br><span class="line">print(<span class="string">"---------"</span>)</span><br><span class="line">print(j)</span><br><span class="line">print(<span class="string">"---------"</span>)</span><br><span class="line">print(a[j])</span><br></pre></td></tr></table></figure></p><h3 id="不同复制操作对比"><a href="#不同复制操作对比" class="headerlink" title="不同复制操作对比"></a>不同复制操作对比</h3><p>矩阵中的值的复制：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"><span class="selector-tag">a</span> = np.arange(<span class="number">12</span>)</span><br><span class="line"><span class="selector-tag">b</span> = a</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(b is a)</span></span></span><br><span class="line"><span class="selector-tag">b</span><span class="selector-class">.shape</span> = (<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(a.shape)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(id(a)</span></span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(id(b)</span></span>)</span><br><span class="line"></span><br><span class="line">c = <span class="selector-tag">a</span>.view()</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(c is a )</span></span></span><br><span class="line">c<span class="selector-class">.shape</span> = <span class="number">2</span>,<span class="number">6</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(a.shape)</span></span></span><br><span class="line">c[<span class="number">0</span>,<span class="number">4</span>]=<span class="number">1234</span>    #指向的位置不相同，但是共用的是一套值</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(a)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(id(a)</span></span>)</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(id(c)</span></span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d = <span class="selector-tag">a</span>.copy()</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(d is a)</span></span></span><br><span class="line">d[<span class="number">0</span>,<span class="number">0</span>] = <span class="number">9999</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(d)</span></span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(a)</span></span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spark生态圈之Scala(十四) ----- Scala中的函数式编程之隐式转换</title>
      <link href="/2018/05/17/BigData-Scala8/"/>
      <url>/2018/05/17/BigData-Scala8/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spark生态圈之Scala(十三) ----- Scala中的函数式编程之类型参数</title>
      <link href="/2018/05/17/BigData-Scala7/"/>
      <url>/2018/05/17/BigData-Scala7/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spark生态圈之Scala(十二) ----- Scala中的函数式编程之模式匹配</title>
      <link href="/2018/05/17/BigData-Scala6/"/>
      <url>/2018/05/17/BigData-Scala6/</url>
      <content type="html"><![CDATA[<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p>scala是没有Java中的switch case语法的，相对应的，Scala提供了更加强大的match case语法，即模式匹配，类代替switch case，match case也被称为模式匹配<br>Scala的match case与Java的switch case最大的不同点在于，Java的switch case仅能匹配变量的值，比如1、2、3等；而Scala的match case可以匹配各种情况，比如变量的类型、集合的元素、有值或无值<br>match case的语法如下 : 变量match{case 值=&gt; 语法}。如果值为下划线，则代表了不满足以上所有情况下的默认情况如何处理。此外，match case中，主要一个case分支满足并处理了，就不会继续判断下一个case分支了。（与Java不同，java的switch case需要用break阻止）<br>match case语法最基本的应用，就是对变量的值进行模式匹配</p><p>案例：成绩评价<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def judgeGrade(grade:String)&#123;</span><br><span class="line"> grade <span class="keyword">match</span>&#123;</span><br><span class="line">      <span class="built_in">case</span> <span class="string">"A"</span> =&gt; println(<span class="string">"Excellent"</span>)</span><br><span class="line">      <span class="built_in">case</span> <span class="string">"B"</span>=&gt; println(<span class="string">"Good"</span>)</span><br><span class="line">      <span class="built_in">case</span> <span class="string">"C"</span>=&gt; println(<span class="string">"Just so so"</span>)</span><br><span class="line">      <span class="built_in">case</span> <span class="keyword">_</span> =&gt; println(<span class="string">"you need work harder"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="在模式匹配中使用if守卫"><a href="#在模式匹配中使用if守卫" class="headerlink" title="在模式匹配中使用if守卫"></a>在模式匹配中使用if守卫</h3><p>Scala的模式匹配语法，有一个特点在于，可以在case后的条件判断中，不仅仅只是提供一个值，而是可以在值后面再加一个if守卫，进行双重过滤</p><p>案例：成绩评价（升级版）<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def judgeGrade(name:<span class="keyword">String</span>,grade:<span class="keyword">String</span>)&#123;</span><br><span class="line">  grade <span class="built_in">match</span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"A"</span>=&gt;<span class="built_in">println</span>(name+<span class="string">",you are excellent"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"B"</span>=&gt;<span class="built_in">println</span>(name+<span class="string">",you are good"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"C"</span>=&gt;<span class="built_in">println</span>(name+<span class="string">",you are just so so"</span>)</span><br><span class="line">    <span class="keyword">case</span> \_if name==<span class="string">"leo"</span> =&gt;<span class="built_in">println</span>(name+<span class="string">",you are a good boy,come on"</span>)</span><br><span class="line">    <span class="keyword">case</span> \_ =&gt;<span class="built_in">println</span>(<span class="string">"you need to work harder"</span>)  </span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="在模式匹配中进行变量赋值"><a href="#在模式匹配中进行变量赋值" class="headerlink" title="在模式匹配中进行变量赋值"></a>在模式匹配中进行变量赋值</h3><p>Scala的模式匹配语法，有一个特点在于，可以将模式匹配的默认情况，下划线，替换为一个变量名，此时模式匹配语法就会将要匹配的值赋值给这个变量，从而可以在后面的处理语句中使用要匹配的值</p><p>为什么有这种语法？？思考一下。因为只要使用用case匹配到的值，是不是我们就知道这个值啦！在这个case的处理语句中，是不是就直接可以使用写程序时就已知的值！<br>但是对于下划线<em>这种情况，所有不满足前面的case的值，都会进行</em>这种默认情况进行处理，此时如果我们在处理语句中需要拿到具体的值进行处理呢？那就需要使用这种在模式匹配中进行变量赋值的语法！！</p><p>案例：成绩评价（升级版）<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def juegeGrade(<span class="built_in">name</span>:String,grade:String)&#123;</span><br><span class="line">  grade match&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"A"</span> =&gt; println(<span class="built_in">name</span>+<span class="string">",you are excellent"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"B"</span>=&gt; println(<span class="built_in">name</span>+<span class="string">", you are good"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"C"</span> =&gt; println(<span class="built_in">name</span>+<span class="string">",you are just so so"</span>)</span><br><span class="line">    <span class="keyword">case</span> \<span class="variable">_grade</span> <span class="keyword">if</span> <span class="built_in">name</span> == <span class="string">"leo"</span> =&gt; println(<span class="built_in">name</span>+<span class="string">",you are a good boy,come on,your grade is"</span>+\<span class="variable">_grade</span>)</span><br><span class="line">    <span class="keyword">case</span> \<span class="variable">_grade</span> =&gt; println(<span class="string">"you need to work harder,your grade is "</span>+\<span class="variable">_grade</span>)</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="对类型进行模式匹配"><a href="#对类型进行模式匹配" class="headerlink" title="对类型进行模式匹配"></a>对类型进行模式匹配</h3><p>Scala的模式匹配一个强大之处就在于，可以直接匹配类型，而不是值！！！这点是java的switch case绝对做不到的。</p><p> 理论知识：对类型如何进行匹配？其他语法与匹配值其实是一样的，但是匹配类型的话，就是要用“case变量：类型=&gt;代码”这种语法，而不是匹配值的“case值=&gt; 代码”这种语法</p><p>案例：异常处理<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io._</span><br><span class="line"></span><br><span class="line">def processException(e:Exception)</span><br><span class="line">&#123;</span><br><span class="line">  e match&#123;</span><br><span class="line">    <span class="keyword">case</span> e1 : <span class="function"><span class="params">lllegalArgumentException</span> =&gt;</span> println(<span class="string">"you have illegal arguments! exception is :"</span>+e1)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> e2 : <span class="function"><span class="params">FileNotFoundException</span> =&gt;</span> println(<span class="string">"cannot find the file you need read or write!, exception is :"</span>+e2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> e3 : <span class="function"><span class="params">IOException</span> =&gt;</span> println(<span class="string">"you got an error while you were doing IO operation! exception is:"</span>+e3)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> _ : <span class="function"><span class="params">Exception</span> =&gt;</span> println(<span class="string">"cannot know which exception you have!"</span>)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">processException(<span class="keyword">new</span> IllegalArgumentException(<span class="string">"except two arguments,but found one argument."</span>))</span><br><span class="line"></span><br><span class="line">processException(<span class="keyword">new</span> FileNotFoundException(<span class="string">"text.txt not found"</span>))</span><br><span class="line"></span><br><span class="line">processException(<span class="keyword">new</span> IOException(<span class="string">"get data from socket fail."</span>))</span><br><span class="line"></span><br><span class="line">processException(<span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"array is null"</span>))</span><br></pre></td></tr></table></figure></p><h3 id="对Array和List进行模式匹配"><a href="#对Array和List进行模式匹配" class="headerlink" title="对Array和List进行模式匹配"></a>对Array和List进行模式匹配</h3><p>对Array进行模式匹配，分别可以匹配带有指定元素的数组、带有指定个数元素的数组、以某元素打头的数组<br>对List进行模式匹配，与Array类似，但是需要使用List特有的::操作符</p><p>案例：对朋友打招呼<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def greeting(arr:<span class="keyword">Array</span>[String])&#123;</span><br><span class="line">  arr match&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">Array</span>(<span class="string">"Leo"</span>) =&gt; println(<span class="string">"Hi,Leo!"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">Array</span>(girl1,girl2,girl3) =&gt; println(<span class="string">"Hi,girls,nice to meet you."</span>+girl1+<span class="string">"and"</span>+girl2+<span class="string">"and"</span>+girl3)</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">Array</span>(<span class="string">"Leo"</span>,\_*) =&gt; println(<span class="string">"Hi,Leo,please introduce you friends to me"</span>)</span><br><span class="line">    <span class="keyword">case</span> \_ =&gt; println(<span class="string">"hey,who are you?"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def greeting(<span class="keyword">list</span>:<span class="keyword">List</span>[String])&#123;</span><br><span class="line">  <span class="keyword">list</span> match&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Leo"</span>::Nil =&gt; println(<span class="string">"Hi,Leo!"</span>)</span><br><span class="line">    <span class="keyword">case</span> girl1::girl2::girl3::Nil =&gt; println(<span class="string">"Hi,girls,nice to meet you."</span>+girl1+<span class="string">"and"</span>+girl2+<span class="string">"and"</span>+girl3)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Leo"</span>::tail =&gt; println(<span class="string">"Hi,Leo,please introduce your friends to me"</span>)</span><br><span class="line">    <span class="keyword">case</span> \_=&gt; println(<span class="string">"hey,who are you?"</span>)</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="case-class与模式匹配"><a href="#case-class与模式匹配" class="headerlink" title="case class与模式匹配"></a>case class与模式匹配</h3><p>Scala中提供了一种特殊的类，用case class进行声明，中文也可以称作样例类。case class其实有点类似于Java中的JavaBean的概念。即只定义field，并且由Scala编译时自动提供getter和setter方法，但是没有method</p><p>case class的主构造函数接收的参数通常不需要使用var或val修饰，Scala自动就会使用val修饰（但是如果你自己使用var修饰，那么还是会按照var来）</p><p>Scala自动为case class定义了伴生对象，也就是object，并且定义了apply()方法，该方法接收主构造函数中相同的参数，并返回case class对象</p><p>//案例:学校门禁<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Teacher</span>(<span class="params">name:<span class="type">String</span>,subject:<span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Studnet</span>(<span class="params">name:<span class="type">String</span>,classroom:<span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">def</span> <span class="title">judgeIdentify</span>(<span class="params">p:<span class="type">Person</span></span>)</span>&#123;</span><br><span class="line">  p <span class="keyword">match</span>&#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="type">Teacher</span>(name,subject)=&gt; println(<span class="string">"Teacher,name is "</span>+name+<span class="string">",subject is "</span>+subject)</span><br><span class="line">     <span class="keyword">case</span> <span class="type">Student</span>(name,classroom)=&gt; println(<span class="string">"Student,name is "</span>+name+<span class="string">",classroom is"</span>+classroom)</span><br><span class="line">     <span class="keyword">case</span> \_=&gt; println(<span class="string">"illegal access,please go out of the school!"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> leo:<span class="type">Person</span> = <span class="type">Student</span>(<span class="string">"leo"</span>,<span class="string">"class1"</span>)</span><br><span class="line"><span class="keyword">val</span> tom:<span class="type">Person</span> =<span class="type">Teacher</span>(<span class="string">"tom"</span>,<span class="string">"Math"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span>(<span class="params">name:<span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">jack</span></span>:<span class="type">Person</span> = <span class="type">Worker</span>(<span class="string">"jack"</span>)</span><br><span class="line"></span><br><span class="line">judgeIdentify(leo)</span><br><span class="line">judgeIdentify(tom)</span><br><span class="line">judgeIdentify(jack)</span><br></pre></td></tr></table></figure></p><h3 id="Option与模式匹配"><a href="#Option与模式匹配" class="headerlink" title="Option与模式匹配"></a>Option与模式匹配</h3><p>Scala有一种特殊的类型，叫做Option。Option有两种值，一种是Some，表示有值，一种是None，表示没有值</p><p>Option通常会用于模式匹配中，用于判断某个变量是有值还是没有值，这比null来的更加简洁明了<br>Option的用法必须掌握，因为Spark源码中大量地使用了Option，比如Some(a),None这种语法，因此必须看得懂Option模式匹配，才能够读懂Spark源码</p><p>//案例：成绩查询<br><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> grades = <span class="type">Map</span>(<span class="string">"Leo"</span>-&gt;<span class="string">"A"</span>,<span class="string">"Jack"</span>-&gt;<span class="string">"B"</span>,<span class="string">"Jen"</span>-&gt;<span class="string">"C"</span>)</span><br><span class="line"></span><br><span class="line">def getGrade(name:<span class="type">String</span>)&#123;</span><br><span class="line">    <span class="keyword">val</span> grade = grades.get(name)</span><br><span class="line">    grade match&#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Some</span>(grade) =&gt; println(<span class="string">"your grade is "</span>+grade)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">None</span> =&gt; println(<span class="string">"Sorry , your grade information is not in the system"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spark生态圈之Scala(十一) ----- Scala中的函数式编程之集合操作</title>
      <link href="/2018/05/17/BigData-Scala5-2/"/>
      <url>/2018/05/17/BigData-Scala5-2/</url>
      <content type="html"><![CDATA[<h3 id="Scala的集合体系"><a href="#Scala的集合体系" class="headerlink" title="Scala的集合体系"></a>Scala的集合体系</h3><p>Scala中的集合体系主要包括:Iterable、Seq、Set、Map。其中Iterable是所有集合Trait的根trai。这个结构与Java的集合体系非常相似。<br>Scala中的集合是分成可变和不可变两类集合的，其中可变集合就是说，集合的元素可以动态修改，而不可变集合的元素在初始化之后，就无法修改了。分别对应scala.collection.mutable和scala.collection.immutable两个包<br>Seq下包含了Range、ArrayBuffer、List等子trait。其中Range就代表了一个序列，通常可以使用“1  to 10”这种语法来产生一个Range。ArrayBuffer就类似于Java中的ArrayList<br> <figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">range</span>: <span class="number">1</span> <span class="keyword">to</span> <span class="number">10</span>  <span class="number">1</span>.<span class="keyword">to</span>(<span class="number">10</span>)   <span class="number">1</span>.<span class="keyword">until</span>(<span class="number">10</span>)</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List 代表一个不可变的列表<br>List的创建，val list = List(1,2,3,4)<br>List有head和tail，head代表Lit的第一个元素，tail代表第一个元素之后的所有元素</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>.head , <span class="built_in">list</span>.tail</span><br></pre></td></tr></table></figure><p>List有特殊的::操作符，可以用于将head和tail合并成一个List,0::list</p><p>::这种操作符要清楚，在spark源码中都是有体现的，一定要能够看懂！</p><p>如果一个List只有一个元素，那么它的head就是这个元素，它的tail就是Nil</p><p>案例：用递归函数来给List中每个元素都加上指定前缀，并打印<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">def</span> <span class="selector-tag">decorator</span>(<span class="attribute">l</span>:List[Int],<span class="attribute">prefix</span>:String)&#123;</span><br><span class="line">  <span class="selector-tag">if</span>(l ! = Nil)</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="selector-tag">println</span>(prefix+l.head)</span><br><span class="line">     <span class="selector-tag">decorator</span>(l.tail,prefix)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList代表一个可变的列表，使用elem可以引用其头部，使用next可以引用其尾部<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val l = scala.collection.LinkedList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);  l.elem;l.next</span><br><span class="line"></span><br><span class="line"><span class="comment">//案例：使用while循环将LinkedList中的每个元素都乘以2</span></span><br><span class="line">val <span class="type">list</span> = scala.collection.mutable.LinkedList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">var currentList = <span class="type">list</span></span><br><span class="line">while(currentList !=Nil)</span><br><span class="line">&#123;</span><br><span class="line">  currentList.elem = currentList.elem * <span class="number">2</span></span><br><span class="line">  currentList.elem = currentList.elem * <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>案例：使用while循环将LinkedList中，从第一个元素开始，每隔一个元素，乘以2<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">val <span class="type">list</span> = scala.collection.mutable.LinkedList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>)</span><br><span class="line">var currentList = <span class="type">list</span></span><br><span class="line">var first = true</span><br><span class="line">while(currentList !=Nil &amp;&amp; currentList.next!=Nil)</span><br><span class="line">&#123;</span><br><span class="line">  if(first) &#123;currentList.elem = currentList.elem * <span class="number">2</span>;first = false &#125;</span><br><span class="line">  currentList = currentList.next.next</span><br><span class="line"></span><br><span class="line">  if(currentList != Nil)</span><br><span class="line">  currentList.elem = currentList.elem * <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set代表一个没有重复元素的集合<br>将重复元素加入Set是没有用的，比如</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val s = Set(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);s+<span class="number">1</span>;s+<span class="number">4</span></span><br></pre></td></tr></table></figure><p>而且Set是不保证插入顺序的，也就是说，Set中的元素是乱序的</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s = <span class="keyword">new</span> scala.collection.<span class="keyword">mutable</span>.HashSet[Int] ; s+=<span class="number">1</span>;s+=<span class="number">2</span>;s+=<span class="number">5</span></span><br></pre></td></tr></table></figure><p>LinkedHashSet会用一个链表维护插入顺序，</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val s = new scala.collection.mutable.LinkedHashSet[<span class="string">Int</span>](<span class="link"></span>)；i+=1;s+=2;s+=5</span><br></pre></td></tr></table></figure><p>SortedSet会自动根据key来进行排序，</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val s = scala<span class="selector-class">.collection</span><span class="selector-class">.mutable</span><span class="selector-class">.SortedSet</span>(<span class="string">"orange"</span>,<span class="string">"apple"</span>,<span class="string">"banana"</span>)</span><br></pre></td></tr></table></figure><h3 id="集合的函数式编程"><a href="#集合的函数式编程" class="headerlink" title="集合的函数式编程"></a>集合的函数式编程</h3><p>集合的函数式编程非常非常之重要<br>必须完全掌握和理解Scala的高阶函数是什么意思，Scala的集合类的map、flatMap、reduce、reduceLeft、foreach等这些函数，就是高阶函数，因为可以接收其他函数作为参数</p><p>高阶函数的使用，也是Scala与Java最大的一点不同！！！因为Java里面是没有函数式编程的，也肯定没有高阶函数，也肯定无法直接将函数传入一个方法，或者让一个方法返回一个函数<br>对Scala高阶函数的理解、掌握和使用，可以大大增强你的技术，而且也是Scala最有诱惑力、最有优势的一个功能！！！</p><p>此外，在Spark源码中，有大量的函数式编程，以及基于集合的高阶函数的使用！！！所以必须掌握，才能看懂spark源码</p><p>map案例实战：为List中每个元素都添加一个前缀<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">List</span><span class="params">(<span class="string">"Leo"</span>,<span class="string">"Jen"</span>,<span class="string">"Peter"</span>,<span class="string">"Jack"</span>)</span></span>.map(<span class="string">"name  is "</span>+ \_)</span><br></pre></td></tr></table></figure></p><p>flatMap案例实战：将List中的多行句子拆分成单词<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">List</span><span class="params">(<span class="string">"Hello World"</span>,<span class="string">"You Me"</span>)</span></span>.flatMap(\_.split(<span class="string">" "</span>))</span><br></pre></td></tr></table></figure></p><p>foreach案例实战：打印List中的每个单词<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">List</span><span class="params">(<span class="string">"I"</span>,<span class="string">"have"</span>,<span class="string">"a"</span>,<span class="string">"beautiful"</span>,<span class="string">"house"</span>)</span></span>.foreach(println(\_))</span><br></pre></td></tr></table></figure></p><p>zip案例实战：对学生姓名和学生成绩进行关联<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List(<span class="string">"Leo"</span>,<span class="string">"Jen"</span>,<span class="string">"Peter"</span>,<span class="string">"Jack"</span>).zip(List(<span class="number">100</span>,<span class="number">90</span>,<span class="number">75</span>,<span class="number">83</span>))</span><br></pre></td></tr></table></figure></p><h3 id="综合案例：单词计数"><a href="#综合案例：单词计数" class="headerlink" title="综合案例：单词计数"></a>综合案例：单词计数</h3><p>使用scala的io包将文本文件内的数据读取出来<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val lines1 = scala<span class="selector-class">.io</span><span class="selector-class">.Source</span><span class="selector-class">.fromFile</span>(<span class="string">""</span>).mkString</span><br><span class="line">val lines2 = scala<span class="selector-class">.io</span><span class="selector-class">.Source</span><span class="selector-class">.fromFile</span>(<span class="string">""</span>).mkString</span><br></pre></td></tr></table></figure></p><p>使用List的伴生对象，将多个文件内的内容创建为一个List<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val lines = List(<span class="name">lines1</span>,lines2)</span><br></pre></td></tr></table></figure></p><p>下面这一行才是我们的案例的核心和重点，因为有多个高阶函数的链式调用，以及大量下划线的使用，如果没有透彻掌握之前的课程讲解的Scala函数式编程，那么下面这一行代码，完全可能会看不懂！！！<br>但是下面这行代码其实就是Scala编程的精髓所在，就是函数式编程，也是Scala相较于Java等编程员最大的功能优势所在<br>而且，spark的源码中大量使用了这种复杂的链式调用的函数式编程<br>而且，spark本身提供的开发人员使用的编程api的风格，完全沿用了Scala的函数式编程，比如Spark本身的api中就提供了map、flatMap、reduce、foreach，以及更高级的reduceByKey、groupbyKey等高阶函数<br>如果要使用Scala进行spark工程的开发，那么就必须掌握这种复杂的高阶函数的链式调用！！！<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lines.flatMap(<span class="symbol">_</span>.<span class="built_in">split</span>(<span class="string">" "</span>)).<span class="built_in">map</span>((\<span class="symbol">_</span>,<span class="number">1</span>)).<span class="built_in">map</span>(\<span class="symbol">_</span>.\_2).reduceLeft(\<span class="symbol">_</span> + \<span class="symbol">_</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spark生态圈之Scala(十) ----- Scala中的函数式编程</title>
      <link href="/2018/05/17/BigData-Scala5-1/"/>
      <url>/2018/05/17/BigData-Scala5-1/</url>
      <content type="html"><![CDATA[<h3 id="将函数赋值给变量"><a href="#将函数赋值给变量" class="headerlink" title="将函数赋值给变量"></a>将函数赋值给变量</h3><p>Scala中的函数是一等公民，可以独立定义，独立存在，而且直接将函数作为值赋值给变量<br>Scala的语法规定，将函数复制给变量时，必须在函数后面加上空格和下划线<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayHello</span><span class="params">(<span class="symbol">name:</span>String)</span></span> &#123;println(<span class="string">"Hello,"</span>+name)&#125;</span><br><span class="line"></span><br><span class="line">val sayHelloFunc = sayHello <span class="number">_</span></span><br><span class="line"></span><br><span class="line">sayHelloFunc(<span class="string">"leo"</span>)</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>Scala中，函数也可以不需要命名，此时函数被称为匿名函数。<br>可以直接定义函数之后，将函数赋值给某个变量；也可以将直接定义的匿名函数传入其他函数之中<br>Scala定义匿名函数的语法规则就是:(参数名:参数类型) =&gt; 函数体<br>这种匿名函数的语法必须深刻理解和掌握，在spark的中有大量这样的语法，如果没有掌握，是看不懂spark源码的<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val sayHelloFunc = (<span class="name">name</span><span class="symbol">:String</span>) =&gt; println(<span class="string">"Hello,"</span>+name)</span><br></pre></td></tr></table></figure></p><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>Scala中，由于函数是一等公民，因此可以直接将某个函数传入其他函数，作为参数。这个功能是极其强大的，也是Java这种面向对象的编程语言所不具备的。<br>接收其他函数作为参数的函数，也被称作高阶函数(higher-order function)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val sayHelloFunc = <span class="function">(<span class="params">name:<span class="built_in">String</span></span>) =&gt;</span> println(<span class="string">"Hello,"</span>+name)</span><br><span class="line">def greeting(func:<span class="function">(<span class="params"><span class="built_in">String</span></span>) =&gt;</span>Unit , <span class="attr">name</span>:<span class="built_in">String</span>) &#123;func(name)&#125;</span><br><span class="line">greeting(sayeHelloFunc,<span class="string">"leo"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).map(<span class="function">(<span class="params">num:Int</span>) =&gt;</span> num*num)</span><br></pre></td></tr></table></figure></p><p>高阶函数的另外一个功能是将函数作为返回值<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def getGreetingFunc(<span class="name">msg</span><span class="symbol">:String</span>) = (<span class="name">name</span><span class="symbol">:String</span>) =&gt; println(<span class="name">msg+</span><span class="string">","</span>+name)</span><br><span class="line">val greetingFunc = getGreetingFunc(<span class="string">"hello"</span>)</span><br><span class="line">greetingFunc(<span class="string">"leo"</span>)</span><br></pre></td></tr></table></figure></p><h3 id="高阶函数的类型推断"><a href="#高阶函数的类型推断" class="headerlink" title="高阶函数的类型推断"></a>高阶函数的类型推断</h3><p>高阶函数可以自动推断出参数类型，而不需要写明类型；而且对于只有一个参数的函数，还可以省去其小括号；如果仅有的一个参数在右侧的函数体内只使用一次，则还可以将接收参数省略，并且将参数用<em>来代替<br> 诸如3*\</em>的这种语法，必须掌握！！Spark源码中大量使用了这种语法！！<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def greeting(<span class="function"><span class="keyword">func</span>:<span class="params">(String)</span></span> =&gt; <span class="type">Unit</span>,name:<span class="type">String</span>) &#123;<span class="function"><span class="keyword">func</span><span class="params">(name)</span></span>&#125;</span><br><span class="line"></span><br><span class="line">greeting((name:<span class="type">String</span>) =&gt; <span class="built_in">println</span>(<span class="string">"Hello,"</span>+name),<span class="string">"leo"</span>)</span><br><span class="line"></span><br><span class="line">greeting((name)=&gt;<span class="built_in">println</span>(<span class="string">"Hello"</span>+name),<span class="string">"leo"</span>)</span><br><span class="line"></span><br><span class="line">greeting(name=&gt;<span class="built_in">println</span>(<span class="string">"Hello,"</span>+name),<span class="string">"leo"</span>)</span><br><span class="line"></span><br><span class="line">def triple(<span class="function"><span class="keyword">func</span>:<span class="params">(Int)</span></span>=&gt;<span class="type">Int</span>)=&#123;<span class="function"><span class="keyword">func</span><span class="params">(<span class="number">3</span>)</span></span>&#125;</span><br><span class="line"></span><br><span class="line">triple(<span class="number">3</span>*<span class="number">_</span>)</span><br></pre></td></tr></table></figure></p><h3 id="Scala的常用高阶函数"><a href="#Scala的常用高阶函数" class="headerlink" title="Scala的常用高阶函数"></a>Scala的常用高阶函数</h3><p>map:对传入的每个元素都进行映射，返回一个处理后的元素<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).map(<span class="number">2</span>*\_)</span><br></pre></td></tr></table></figure></p><p>foreach:对传入的每个元素都进行处理，但是没有返回值<br><figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span> to <span class="number">9</span>).<span class="keyword">map</span>(<span class="string">"*"</span> \* \_).<span class="keyword">foreach</span>(<span class="keyword">println</span>)</span><br></pre></td></tr></table></figure></p><p>filter:对传入的每个元素都进行条件判断，如果对元素返回true，则保留该元素，否则过滤掉该元素<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span> to <span class="number">20</span>).filter(_ % <span class="number">2</span> == <span class="number">0</span> )</span><br></pre></td></tr></table></figure></p><p>reduceLeft:从左侧元素开始，进行reduce操作，即先对元素1和元素2进行处理，然后将结果与元素3处理，再将结果与元素4处理，依次类推，即为reduce<br>下面这个操作就相当于1<em>2</em>3<em>4</em>5<em>6</em>7<em>8</em>9<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span> to <span class="number">9</span>).reduceLeft(\<span class="keyword">_</span>*\<span class="keyword">_</span>)</span><br></pre></td></tr></table></figure></p><p>sortWith:对元素进行两两比较，进行排序<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array(<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">1</span>).sortWith(\_&lt;\_)</span><br></pre></td></tr></table></figure></p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包最简洁的解释，函数在变量不处于其有效作用域时，还能够对变量进行访问，即为闭包<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def getGreetingFunc(<span class="name">msg</span><span class="symbol">:String</span>) = (<span class="name">name</span><span class="symbol">:String</span>) =&gt; println(<span class="name">msg+</span><span class="string">","</span>+name)</span><br><span class="line"></span><br><span class="line">val greetingFuncHello = getGreetingFunc(<span class="string">"hello"</span>)</span><br><span class="line"></span><br><span class="line">val greetingFuncHi = getGreetingFunc(<span class="string">"hi"</span>)</span><br></pre></td></tr></table></figure></p><p>两次调用getGreetingFunc函数，传入不同的msg，并创建不同的函数返回<br>然而，msg只有一个局部变量，却在getGreetingFunc执行完之后，还可以继续存在创建的函数之中；greetingFuncHello(“leo”)，调用时，值为”hello”的msg被保留在了函数体内部，可以反复的使用</p><p>这种变量超出了其作用域，还可以使用的情况，即为闭包<br>Scala通过为每个函数创建对象来实现闭包，实际上对于getGreetingFunc函数创建的函数，msg是作为函数对象的变量存在的，因此每个函数才可以拥有不同的msg<br>Scala编译器会确保上述闭包机制</p><h3 id="SAM转换"><a href="#SAM转换" class="headerlink" title="SAM转换"></a>SAM转换</h3><p>在Java中，不支持直接将函数传入一个方法作为参数，通常来说，唯一的方法就是定义一个实现了某个接口的类的实例对象，该对象只有一个方法；而这些接口都只有单个的抽象方法，也就是single abstract method，简称为SAM</p><p>由于Scala是可以调用Java的代码的，因此当我们调用Java的某个方法时，可能就不得不创建SAM传递给方法，非常麻烦；但是Scala又是支持直接传递函数的。此时就可以使用Scala提供的，在调用Java方法时，使用的功能，SAM转换，即将SAM转换为Scala函数</p><p>要使用SAM转换，需要使用Scala提供的特性，隐式转换</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing._</span><br><span class="line"><span class="keyword">import</span> java.awt.event._</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> button = <span class="keyword">new</span> <span class="type">JButton</span>(<span class="string">"Click"</span>)</span><br><span class="line">button.addActionListener(<span class="keyword">new</span> <span class="type">ActionListener</span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">actionPerformed</span></span>(event:<span class="type">ActionEvent</span>)&#123;</span><br><span class="line">    println(<span class="string">"Click Me!!!"</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">getActionListener</span></span>(actionProcessFunc:(<span class="type">ActionEvent</span>)=&gt;<span class="type">Unit</span>) = <span class="keyword">new</span> <span class="type">ActionListener</span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">actionPerformed</span></span>(event:<span class="type">ActionEvent</span>)&#123;</span><br><span class="line">    actionProcessFunc(event)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Currying函数"><a href="#Currying函数" class="headerlink" title="Currying函数"></a>Currying函数</h3><p>Curring函数，指的是，将原来接收两个参数的一个函数，转换为两个函数，第一个函数接收原先的第一个参数，然后返回接收原先第二个参数的第二个函数。<br>在函数调用的过程中，就变为两个函数连续调用的形式<br>在Spark的源码中也有体现，所以对()()这种形式的Curring函数，必须掌握！</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def sum(<span class="name">a</span><span class="symbol">:Int</span>,b<span class="symbol">:Int</span>)=a+b</span><br><span class="line">sum(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">def sum2(<span class="name">a</span><span class="symbol">:Int</span>) = (<span class="name">b</span><span class="symbol">:Int</span>)=&gt;a+b</span><br><span class="line">sum2(<span class="number">1</span>)(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">def sum3(<span class="name">a</span><span class="symbol">:Int</span>)(<span class="name">b</span><span class="symbol">:Int</span>)=a+b</span><br></pre></td></tr></table></figure><h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>Scala中，不需要使用return来返回函数的值，函数最后一行语句的值，就是函数的返回值。在Scala中，return用于在匿名函数中返回值给包含匿名函数的带名函数，并作为带名函数的返回值。<br>使用return的匿名函数，是必须给出返回类型的，否则无法通过编译</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greeting</span><span class="params">(<span class="symbol">name:</span>String)</span></span>=&#123;</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span><span class="params">(<span class="symbol">name:</span>String)</span></span><span class="symbol">:String=</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">"Hello,"</span>+name</span><br><span class="line">  &#125;</span><br><span class="line"> sayHello(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spark生态圈之Scala(九) ----- Scala中的面向对象编程之Trait</title>
      <link href="/2018/05/17/BigData-Scala4-4/"/>
      <url>/2018/05/17/BigData-Scala4-4/</url>
      <content type="html"><![CDATA[]]></content>
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spark生态圈之Scala(八) ----- Scala中的面向对象编程之继承</title>
      <link href="/2018/05/17/BigData-Scala4-3/"/>
      <url>/2018/05/17/BigData-Scala4-3/</url>
      <content type="html"><![CDATA[<h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><p>scala中，让子类继承父类，与Java一样，也是使用extends关键字<br>继承就代表，子类可以从父类继承父类的field和method，然后子类可以在自己内部放入父类所没有，子类特有的field和method；使用继承可以有效复用代码<br>子类可以覆盖父类的field和method；但是如果父类用final修饰，field和method用final修饰，则该类是无法被继承的，field和method是无法被覆盖的<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> name = <span class="string">"leo"</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getName</span> </span>= name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> score = <span class="string">"A"</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getScore</span> </span>= score</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="override和super"><a href="#override和super" class="headerlink" title="override和super"></a>override和super</h3><p>Scala中，如果子类要覆盖一个父类中的非抽象方法，则必须使用override关键字<br>override关键字可以帮助我们尽早地发现代码里的错误，比如:override修饰的父类方法的方法名我们拼写错了；比如要覆盖的父类方法的参数我们写错了；等等<br>此外，在子类覆盖父类方法之后，如果我们在子类中就是要调用父类的被覆盖的方法呢？那就可以使用super关键字。显式地指定要调用父类的方法<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> name = <span class="string">"leo"</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getName</span> </span>= name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> score = <span class="string">"A"</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getScore</span> </span>= score</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getName</span> </span>= <span class="string">"Hi,I'm "</span>+<span class="keyword">super</span>.getName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="override-field"><a href="#override-field" class="headerlink" title="override field"></a>override field</h3><p>Scala中，子类可以覆盖父类的val field，而且子类的val field还可以覆盖父类的val field的getter方法；只要在子类中使用override关键字即可<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> name:<span class="type">String</span> = <span class="string">"Person"</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">age</span></span>:<span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"> <span class="keyword">override</span> <span class="keyword">val</span> name:<span class="type">String</span> = <span class="string">"leo"</span></span><br><span class="line"> <span class="keyword">override</span> <span class="keyword">val</span> age:<span class="type">Int</span> = <span class="number">30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="isInstanceOf和asInstanceOf"><a href="#isInstanceOf和asInstanceOf" class="headerlink" title="isInstanceOf和asInstanceOf"></a>isInstanceOf和asInstanceOf</h3><p>如果我们创建了子类的对象，但是又将其赋予了父类类型的变量。则在后续的程序中，我们又需要将父类类型的变量转换为子类类型的变量，应该如何做?<br>首先，需要使用isInstanceOf判断对象是否是指定类的对象，如果是的话，则可以使用asInstanceOf将对象转换为指定类型<br>注意，如果对象时null,则isInstanceOf一定返回false，asInstanceOf一定返回null<br>注意，如果没有用isInstanceOf先判断对象是否为指定类的实例，就直接用asInstanceOf转换，则可能抛出异常<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">p</span></span>:<span class="type">Person</span>  = <span class="keyword">new</span> <span class="type">Student</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> s:<span class="type">Student</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">if</span>(p.isInstanceOf[<span class="type">Student</span>]) s = p.asInstanceOf[<span class="type">Student</span>]</span><br></pre></td></tr></table></figure></p><h3 id="getClass和classOf"><a href="#getClass和classOf" class="headerlink" title="getClass和classOf"></a>getClass和classOf</h3><p>isInstanceOf只能判断出对象是否是指定类以及其子类的对象，而不能精确判断出，对象就是指定类的对象<br>如果要求精确地判断对象就是指定类的对象，那么就只能使用getClass和classOf了<br>对象.getClass可以精确获取对象的类，classOf[类]可以精确获取类，然后使用==操作符即可判断<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">p</span></span>:<span class="type">Person</span> = <span class="keyword">new</span> <span class="type">Student</span></span><br><span class="line"></span><br><span class="line">p.isInstanceOf[<span class="type">Person</span>]</span><br><span class="line"></span><br><span class="line">p.getClass == classOf[<span class="type">Person</span>]</span><br><span class="line"></span><br><span class="line">p.getClass == classOf[<span class="type">Student</span>]</span><br></pre></td></tr></table></figure></p><h3 id="使用模式匹配进行类型判断"><a href="#使用模式匹配进行类型判断" class="headerlink" title="使用模式匹配进行类型判断"></a>使用模式匹配进行类型判断</h3><p>但是在实际开发中，比如spark的源码中，大量的地方都是使用了模式匹配的方式来进行类型的判断，这种方式更加地简介明了，而且代码得可维护性和可扩展性也非常的高<br>使用模式匹配，功能性上来说，与isInstanceOf一样，也是判断主要是该类以及该类的子类的对象即可，不是精确判断的<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">p</span></span>:<span class="type">Person</span> = <span class="keyword">new</span> <span class="type">Student</span></span><br><span class="line"></span><br><span class="line">p <span class="keyword">match</span>&#123;</span><br><span class="line"> <span class="keyword">case</span> per:<span class="type">Person</span> =&gt; println(<span class="string">"it's Person's object"</span>)</span><br><span class="line"> case_ =&gt; println(<span class="string">"unknown type"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h3><p>跟java一样，scala中同样可以使用protected关键字来修饰field和method，这样在子类中就不需要super关键字，直接就可以访问field和method<br>还可以使用protected[this]，则只能在当前子类对象中访问父类的field和method，无法通过其他子类对象访问父类的field和method<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">var</span> name:<span class="type">String</span> = <span class="string">"leo"</span></span><br><span class="line">  <span class="keyword">protected</span>[<span class="keyword">this</span>] <span class="keyword">var</span> hobby:<span class="type">String</span> = <span class="string">"game"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sayHello=println</span></span>(<span class="string">"Hello,"</span>+name)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">makeFriends</span></span>(s:<span class="type">Student</span>)&#123;</span><br><span class="line">   println(<span class="string">"my hobby is "</span>+hobby+<span class="string">",your hobby is"</span>+s.hobby)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其它实例可以访问:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">var</span> name:<span class="type">String</span> = <span class="string">"leo"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">makeFriends</span></span>(s:<span class="type">Student</span>): <span class="type">Unit</span> =&#123;</span><br><span class="line">    println(<span class="string">"Hi,my name is "</span>+name+<span class="string">",your name is "</span>+s.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> s1 = <span class="keyword">new</span> <span class="type">Student</span></span><br><span class="line"><span class="keyword">val</span> s2 = <span class="keyword">new</span> <span class="type">Student</span></span><br><span class="line">s1.makeFriends(s2)</span><br></pre></td></tr></table></figure></p><p>其他实例不能访问 : (使用protected[this])</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">protected</span>[<span class="keyword">this</span>] <span class="keyword">var</span> name:<span class="type">String</span> = <span class="string">"leo"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">makeFriends</span></span>(s:<span class="type">Student</span>): <span class="type">Unit</span> =&#123;</span><br><span class="line">    println(<span class="string">"Hi,my name is "</span>+name+<span class="string">",your name is "</span>+s.name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> s1 = <span class="keyword">new</span> <span class="type">Student</span></span><br><span class="line"><span class="keyword">val</span> s2 = <span class="keyword">new</span> <span class="type">Student</span></span><br><span class="line">s1.makeFriends(s2)</span><br></pre></td></tr></table></figure><h3 id="调用父类的constructor"><a href="#调用父类的constructor" class="headerlink" title="调用父类的constructor"></a>调用父类的constructor</h3><p>Scala中，每个类可以有一个主constructor和任意多个辅助constructor，而每个辅助constructor的第一行都必须是调用其他辅助constructor或者是主constructor；因此子类的辅助constructor是一定不可能直接调用父类的constructor的<br>只能在子类的主constructor中调用父类的constructor，以下这种语法，就是通过子类的主构造函数来调用父类的构造函数<br>注意！如果是父类中接收的参数，比如name和age，子类中接收时，就不要用任何val或var来修饰了，否则会认为是子类要覆盖父类的field<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val name:<span class="type">String</span>,val age:<span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Student</span>(<span class="params">name:<span class="type">String</span>,age:<span class="type">Int</span>,var score:<span class="type">Double</span></span>) <span class="keyword">extends</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(name:<span class="type">String</span>)&#123;</span><br><span class="line">     <span class="keyword">this</span>(name,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(age:<span class="type">Int</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="string">"leo"</span>,age,<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spark生态圈之Scala(七) ----- Scala中的面向对象编程之对象</title>
      <link href="/2018/05/17/BigData-Scala4-2/"/>
      <url>/2018/05/17/BigData-Scala4-2/</url>
      <content type="html"><![CDATA[<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>object,相当于class的单个实例，通常在里面放一些静态的field或者method<br>第一次调用Object的方法时，就会执行object的constructor，也就是object内部不在method中的代码；但是object不能定义接受参数的constructor<br>注意，object的constructor只会在其第一次被调用时执行一次，以后再次调用就不会再次执行constructor了<br>object通常用于作为单例模式的实现，或者放class的静态成员，比如工具方法<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> eyeNum = <span class="number">2</span></span><br><span class="line">  println(<span class="string">"this Person object!"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getEysNum</span> </span>= eyeNum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="Object继承抽象类"><a href="#Object继承抽象类" class="headerlink" title="Object继承抽象类"></a>Object继承抽象类</h3><p>object 的功能其实和class类似，除了不能定义接受参数的constructor之外<br>object也可以继承抽象类，并覆盖抽象类中的方法<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span>(<span class="params">var message:<span class="type">String</span></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span></span>(name:<span class="type">String</span>):<span class="type">Unit</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">HelloImpl</span> <span class="keyword">extends</span> <span class="title">Hello</span>(<span class="params">"<span class="type">Hello</span>"</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span></span>(name:<span class="type">String</span>)=&#123;</span><br><span class="line">    println(message+<span class="string">","</span>+name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h3><p>如果有一个class,还有一个与class同名的object，那么就称这个object是class的伴生对象，class是object的伴生类<br> 伴生类和伴生对象必须存放在一个.scala文件之中<br>伴生类和伴生对象，最大的特点就在于，互相可以访问private field<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val name:<span class="type">String</span>,val age:<span class="type">Int</span></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span> </span>= println(<span class="string">"Hi,"</span>+name+<span class="string">",I guess you are"</span>+age+<span class="string">"years old!"</span>+<span class="string">",and usually you must have "</span>+<span class="type">Person</span>.eyeNum+<span class="string">" eyes."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> eyeNum = <span class="number">2</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getEyeNum</span> </span>= eyeNum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="apply方法"><a href="#apply方法" class="headerlink" title="apply方法"></a>apply方法</h3><p>object 中非常重要的一个特殊方法，就是apply方法<br>通常在伴生对象中实现apply方法，并在其中实现构造半生类的对象的功能<br>而创建伴生类的对象时，通常不会使用new Class的方式，而是使用Class()的方式，隐式地调用伴生对象得apply方法，这样会让对象创建更加简洁<br>比如，Array类的伴生对象得apply方法就实现了接收可变数量的参数，并创建一个Array对象的功能<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val a = Array(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure></p><p>比如，定义自己的伴生类和伴生对象<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val name:<span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(name:<span class="type">String</span>) = <span class="keyword">new</span> <span class="type">Person</span>(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h3><p>就如同java中，如果要运行一个程序，必须编写一个包含main方法类一样；在scala中，如果要运行一个应用程序，那么必须有一个main方法，作为入口<br>scala中的main方法定义为def main(args:Array[String]),并且必须定义在object中<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>])&#123;</span><br><span class="line">    println(<span class="string">"Hello World!!!"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除了自己实现main方法之外，还可以继承App Trait，然后将需要在main方法中运行的代码，直接作为object的constructor代码；而且用args可以接受传入的参数<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">App</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(args.length&gt;<span class="number">0</span>) println(<span class="string">"hello,"</span>+args(<span class="number">0</span>))</span><br><span class="line">  <span class="keyword">else</span> println(<span class="string">"Hello World!!!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果要运行上述代码，需要将其方法.scala文件，然后先使用scalac编译，再用scala执行<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scalac HelloWorld.scala</span><br><span class="line">scala -Dscala<span class="selector-class">.time</span> HelloWorld</span><br></pre></td></tr></table></figure></p><p>App Trait的工作原理为：App Trait继承自DeployedInit Trait,scalac命令进行编译时，会把继承App Trait的object的constructor代码放到DeplayedInit Trait的deplayedInit方法中执行</p><h3 id="Object实现枚举功能"><a href="#Object实现枚举功能" class="headerlink" title="Object实现枚举功能"></a>Object实现枚举功能</h3><p>Scala没有直接提供类似于java中的Enum这样的枚举特性，如果要实现枚举，则需要用object继承Enumerationlei，并且调用value方法来初始化枚举值<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Season</span> <span class="keyword">extends</span> <span class="title">Enumeration</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> <span class="type">SPRING</span>,<span class="type">SUMMER</span>,<span class="type">AUTUMN</span>,<span class="type">WINTER</span> = <span class="type">Value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还可以通过Value传入枚举值的id和name，通过id和toString可以获取，还可以通过id和name来查找枚举值<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Season</span> <span class="keyword">extends</span> <span class="title">Enumeration</span></span>&#123;</span><br><span class="line">  <span class="keyword">val</span> <span class="type">SPRING</span> = <span class="type">Value</span>(<span class="number">0</span>,<span class="string">"spring"</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">SUMMER</span> = <span class="type">Value</span>(<span class="number">1</span>,<span class="string">"summer"</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">AUTUMN</span> = <span class="type">Value</span>(<span class="number">2</span>,<span class="string">"autumn"</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">WINTER</span> = <span class="type">Value</span>(<span class="number">3</span>,<span class="string">"winter"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Season</span>(<span class="number">0</span>)</span><br><span class="line"><span class="type">Season</span>.withName(<span class="string">"spring"</span>)</span><br></pre></td></tr></table></figure></p><p>使用枚举object.values可以遍历枚举值<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(<span class="name">ele</span> &lt;- Season.values) println(<span class="name">ele</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spark生态圈之Scala(六) ----- Scala中的面向对象编程之类</title>
      <link href="/2018/05/17/BigData-Scala4-1/"/>
      <url>/2018/05/17/BigData-Scala4-1/</url>
      <content type="html"><![CDATA[<h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><p>定义类，包含field以及方法<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">var</span> name = <span class="string">"leo"</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span></span>() &#123; print(<span class="string">"Hello , "</span>+name)&#125;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">getName</span> </span>= name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建类的对象，并调用其方法</span></span><br><span class="line"><span class="keyword">val</span> helloWorld = <span class="keyword">new</span> <span class="type">HelloWorld</span></span><br><span class="line">helloWorld.sayHello()</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以不加括号，如果定义方法时不带括号，则调用方法时也不能带括号</span></span><br><span class="line">print(helloWorld.getName)</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="field的getter与setter"><a href="#field的getter与setter" class="headerlink" title="field的getter与setter"></a>field的getter与setter</h3><p>定义不带private的var field，此时scala生成的面向JVM的类时，会定义为private的name字段，并提供public的getter和setter方法,而如果使用private修饰field，则生成的getter和setter也是private的,如果定义val field，则只会生成getter方法,如果不希望生成setter和getter方法，则将field声明为private[this]</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Student&#123;</span><br><span class="line">    <span class="selector-tag">var</span> name = <span class="string">"leo"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用getter和setter方法，分别叫做name和name_ =</span></span><br><span class="line"></span><br><span class="line">val leo = new Student</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(leo.name)</span></span></span><br><span class="line">leo<span class="selector-class">.name</span> = <span class="string">"leo1"</span></span><br></pre></td></tr></table></figure><h3 id="自定义getter和setter方法"><a href="#自定义getter和setter方法" class="headerlink" title="自定义getter和setter方法"></a>自定义getter和setter方法</h3><p>如果只是希望拥有简单的getter和setter方法，那么就按照scala提供的语法规则，根据需求为field选择合适的修饰符就好:var、val、private、private[this]<br>但是如果希望能够自己对getter与setter进行控制，则可以自定义getter和setter方法<br>自定义setter方法的时候一定需要注意scala的语法限制，签名、=、参数间不能有空格<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> myName = <span class="string">"leo"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span> </span>= <span class="string">"your name is "</span> + myName</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name_=</span></span>(newValue:<span class="type">String</span>)&#123;</span><br><span class="line">     print(<span class="string">"you cannot edit your name !!!"</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> leo = <span class="keyword">new</span> <span class="type">Student</span></span><br><span class="line">print(leo.name)</span><br><span class="line">leo.name = <span class="string">"leo1"</span></span><br></pre></td></tr></table></figure></p><h3 id="private-this-的使用"><a href="#private-this-的使用" class="headerlink" title="private[this]的使用"></a>private[this]的使用</h3><p>如果将field使用private来修饰，那么代表这个field是类私有的，在类的方法中，可以直接访问类的其他对象的private field<br>这种情况下，如果不希望field被其他对象访问到，那么可以使用private[this]，意味着对象私有的field，只有本对象内可以访问到</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">var</span> myAge = <span class="number">0</span></span><br><span class="line">   def age_ = (<span class="keyword">new</span><span class="type">Value</span>:<span class="keyword">Int</span>)&#123;</span><br><span class="line">   <span class="keyword">if</span>(<span class="keyword">new</span><span class="type">Value</span>&gt;<span class="number">0</span>) myAge = <span class="keyword">new</span><span class="type">Value</span></span><br><span class="line"><span class="type"></span>     <span class="keyword">else</span> print(<span class="string">"illegal age!"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  def age = myAge</span><br><span class="line">  def older(s:<span class="type">Student</span>) = &#123;</span><br><span class="line">     myAge &gt; s.myAge</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java风格的getter和setter方法"><a href="#Java风格的getter和setter方法" class="headerlink" title="Java风格的getter和setter方法"></a>Java风格的getter和setter方法</h3><p>Scala的getter和setter方法的命名与java是不同的，是field和field_=的方式<br>如果要让scala自动生成java风格的getter和setter方法，只要给field添加@BeanProperty注解即可<br>此时会生成4个方法，name:String、name_=(newValue:String):Unit、getName():String、setName(newValue:String):Unit<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.reflect.BeanProperty</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">   <span class="meta">@BeanProperty</span> <span class="keyword">var</span> name:String =_</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(<span class="meta">@BeanProperty</span> <span class="keyword">var</span> name:String)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> s = new Student</span><br><span class="line">s.getName(<span class="string">"leo"</span>)</span><br><span class="line">s.getName()</span><br></pre></td></tr></table></figure></p><h3 id="辅助constructor"><a href="#辅助constructor" class="headerlink" title="辅助constructor"></a>辅助constructor</h3><p>Scala中，可以给类定义多个辅助constructor，类似于java中的构造函数重载<br>辅助constructor之间可以互相调用，而且必须第一行调用主constructor<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> name =<span class="string">""</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line">   def <span class="keyword">this</span>(name:String)</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="keyword">this</span>()</span><br><span class="line">     <span class="keyword">this</span>.name = name</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    def <span class="keyword">this</span>(name:String,age:<span class="built_in">Int</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">this</span>(name)</span><br><span class="line">     <span class="keyword">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spark生态圈之Scala(五) ----- Scala中的Map和Tuple</title>
      <link href="/2018/05/08/BigData-Scala3/"/>
      <url>/2018/05/08/BigData-Scala3/</url>
      <content type="html"><![CDATA[<h3 id="创建Map"><a href="#创建Map" class="headerlink" title="创建Map"></a>创建Map</h3><p>创建一个不可变的Map<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val ages = Map(<span class="string">"Leo"</span>-&gt;<span class="number">30</span>,<span class="string">"Jen"</span>-&gt;<span class="number">25</span>,<span class="string">"Jack"</span>-&gt;<span class="number">23</span>)</span><br><span class="line">ages(<span class="string">"Leo"</span>)=<span class="number">31</span></span><br></pre></td></tr></table></figure></p><p>创建一个可变的Map<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val ages = scala<span class="selector-class">.collection</span><span class="selector-class">.mutable</span><span class="selector-class">.Map</span>(<span class="string">"Leo"</span>-&gt;<span class="number">30</span>,<span class="string">"Jen"</span>-&gt;<span class="number">25</span>,<span class="string">"Jack"</span>-&gt;<span class="number">23</span>)</span><br><span class="line"><span class="function"><span class="title">ages</span><span class="params">(<span class="string">"Leo"</span>)</span></span>=<span class="number">31</span></span><br></pre></td></tr></table></figure></p><p>使用另外一种方式定义Map元素<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val ages = Map((<span class="string">"Leo"</span>,<span class="number">30</span>),(<span class="string">"Jen"</span>,<span class="number">25</span>),(<span class="string">"Jack"</span>,<span class="number">23</span>))</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>创建一个空的HashMap<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val ages = <span class="keyword">new</span> <span class="type">scala</span>.collection.mutable.HashMap[<span class="keyword">String</span>,<span class="keyword">Int</span>]</span><br></pre></td></tr></table></figure></p><h3 id="访问Map的元素"><a href="#访问Map的元素" class="headerlink" title="访问Map的元素"></a>访问Map的元素</h3><p>获取指定key对应的value，如果key不存在，会报错<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> leoAge = ages(<span class="string">"leo"</span>)</span><br><span class="line"><span class="keyword">val</span> leoAge = ages(<span class="string">"leo"</span>)</span><br></pre></td></tr></table></figure></p><p>使用contains函数检查key是否存在<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val leoAge = if(<span class="name">ages</span>.contains(<span class="string">"leo"</span>)) ages(<span class="string">"leo"</span>) else <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>getOrElse函数<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">val leoAge</span> = ages.getOrElse(<span class="string">"leo"</span>,0)</span><br></pre></td></tr></table></figure></p><h3 id="修改Map元素"><a href="#修改Map元素" class="headerlink" title="修改Map元素"></a>修改Map元素</h3><p>更新Map的元素<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">ages</span><span class="params">(<span class="string">"Leo"</span>)</span></span> = <span class="number">31</span></span><br></pre></td></tr></table></figure></p><p>增加多个元素<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ages+=(<span class="string">"Mike"</span>-&gt;<span class="number">35</span>,<span class="string">"Tom"</span>-&gt;<span class="number">40</span>)</span><br></pre></td></tr></table></figure></p><p>移除元素<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ages</span> -= <span class="string">"Mike"</span></span><br></pre></td></tr></table></figure></p><p>更新不可变的map<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ages2 = ages+(<span class="string">"Leo"</span>-&gt;<span class="number">30</span>,<span class="string">"Jen"</span>-&gt;<span class="number">25</span>,<span class="string">"Jack"</span>-&gt;<span class="number">23</span>)</span><br></pre></td></tr></table></figure></p><p>移除不可变map的元素<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ages3 = ages-<span class="string">"Tom"</span></span><br></pre></td></tr></table></figure></p><h3 id="遍历Map"><a href="#遍历Map" class="headerlink" title="遍历Map"></a>遍历Map</h3><p>遍历map的entrySet<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for((<span class="name">key</span>,value)&lt;- ages) println(<span class="name">key+</span><span class="string">" "</span>+value)</span><br></pre></td></tr></table></figure></p><p>遍历map的key<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(<span class="name">key</span> &lt;- ages.keySet) println(<span class="name">key</span>)</span><br></pre></td></tr></table></figure></p><p>遍历map的value<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(<span class="name">value</span> &lt;- ages.values) println(<span class="name">value</span>)</span><br></pre></td></tr></table></figure></p><p>生成新map，反转key和value<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for((<span class="name">key</span>,value) &lt;- ages) yield (<span class="name">value</span>,key)</span><br></pre></td></tr></table></figure></p><h3 id="SortedMap和LinkedHashMap"><a href="#SortedMap和LinkedHashMap" class="headerlink" title="SortedMap和LinkedHashMap"></a>SortedMap和LinkedHashMap</h3><p>SortedMap可以自动对Map的key的排序<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> ages = scala.collection.immutable.<span class="type">SortedMap</span>(<span class="string">"leo"</span>-&gt;<span class="number">30</span> , <span class="string">"alice"</span>-&gt;<span class="number">15</span> , <span class="string">"jen"</span>-&gt;<span class="number">25</span>)</span><br></pre></td></tr></table></figure></p><p>LinkedHashMap可以记住插入entry的顺序<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val ages = new scala<span class="selector-class">.collection</span><span class="selector-class">.mutable</span><span class="selector-class">.LinkedHashMap</span>[String,Int]</span><br><span class="line"><span class="function"><span class="title">ages</span><span class="params">(<span class="string">"leo"</span>)</span></span> = <span class="number">30</span></span><br><span class="line"><span class="function"><span class="title">ages</span><span class="params">(<span class="string">"alice"</span>)</span></span> = <span class="number">15</span></span><br><span class="line"><span class="function"><span class="title">ages</span><span class="params">(<span class="string">"jen"</span>)</span></span> = <span class="number">25</span></span><br></pre></td></tr></table></figure></p><h3 id="Map的元素类型-Tuple"><a href="#Map的元素类型-Tuple" class="headerlink" title="Map的元素类型-Tuple"></a>Map的元素类型-Tuple</h3><p>简单Tuple<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val <span class="literal">t</span> = (<span class="string">"leo"</span>,<span class="number">30</span>)</span><br></pre></td></tr></table></figure></p><p>访问Tuple</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">t</span><span class="selector-class">._1</span></span><br></pre></td></tr></table></figure><p>zip操作</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> names = Array(<span class="string">"leo"</span>,<span class="string">"jack"</span>,<span class="string">"mike"</span>)</span><br><span class="line"><span class="keyword">val</span> ages = Array(<span class="number">30</span>,<span class="number">24</span>,<span class="number">26</span>)</span><br><span class="line"><span class="keyword">val</span> nameAges = names.zip(ages)</span><br><span class="line"><span class="keyword">for</span>((name,age) &lt;- nameAges) println(name+<span class="string">":"</span>+age)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spark生态圈之Scala(四) ----- Scala中的数组操作(三)</title>
      <link href="/2018/05/08/BigData-Scala1-4/"/>
      <url>/2018/05/08/BigData-Scala1-4/</url>
      <content type="html"><![CDATA[<h3 id="数组转换"><a href="#数组转换" class="headerlink" title="数组转换"></a>数组转换</h3><p>使用yield和函数式编程转换数组</p><p>对Array进行转换，获取的还是Array<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val a = Array(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">val a2 = for(ele &lt;- a) yield ele*ele</span><br></pre></td></tr></table></figure></p><p>对ArrayBuffer进行转换，获取的还是ArrayBuffer<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val b = ArrayBuffer[<span class="string">Int</span>](<span class="link"></span>)</span><br><span class="line">b += (1,2,3,4,5)</span><br><span class="line">val b2 = for(ele <span class="xml"><span class="tag">&lt;<span class="name">-b</span> ) <span class="attr">yield</span> <span class="attr">ele</span>*<span class="attr">ele</span></span></span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>结合if守卫，仅转换需要的元素<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a3 = <span class="keyword">for</span>(ele &lt;- <span class="keyword">if</span> ele %<span class="number">2</span> ==<span class="number">0</span>) <span class="keyword">yield</span> ele*ele</span><br></pre></td></tr></table></figure></p><p>使用函数式编程转换数组(通常使用第一种方式)<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.filter( _%<span class="number">2</span> ==<span class="number">0</span>).map(<span class="number">2</span>*_)</span><br><span class="line">a.filter&#123;_%<span class="number">2</span>==<span class="number">0</span>&#125;map(<span class="number">2</span>*_)</span><br></pre></td></tr></table></figure></p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>算法案例：移出第一个负数之后的所有依赖</p><p>构建数组<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val = ArrayBuffer[<span class="string">Int</span>](<span class="link"></span>)</span><br><span class="line">a+=(1,2,3,4,5,-1,-3,-5,-9)</span><br></pre></td></tr></table></figure></p><p>每发现一个第一个负数之后的负数，就进行移除，性能较差，多次移动数组<br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var foundFirstNegative = <span class="literal">false</span></span><br><span class="line">var arrayLength = a.<span class="built_in">length</span></span><br><span class="line">var  <span class="keyword">index</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">index</span>&lt;arrayLength)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(a(<span class="keyword">index</span>)&gt;=<span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">index</span>+=<span class="number">1</span></span><br><span class="line">    &#125;<span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(!foundFirstNegative)</span><br><span class="line">        &#123;</span><br><span class="line">          foundFirstNegative=<span class="literal">true</span>;<span class="keyword">index</span>+=<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;a.remove(<span class="keyword">index</span>);arrayLength-=<span class="number">1</span>&#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="案例改良版"><a href="#案例改良版" class="headerlink" title="案例改良版"></a>案例改良版</h3><p>算法案例：移出第一个负数之后的所有负数(改良版)</p><p>重新构建数组<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val a = ArrayBuffer[<span class="string">Int</span>](<span class="link"></span>)</span><br><span class="line">a +=(1,2,3,4,5,-1,-3,-5,-9)</span><br></pre></td></tr></table></figure></p><p>每记录所有不需要移除的元素的索引，稍后一次性移除所有需要移除的元素<br>性能较高，数组内的元素迁移只要执行一次即可</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val foundFirstNegative = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">val keepIndexes = <span class="keyword">for</span>(i&lt;- <span class="number">0</span> <span class="keyword">until</span> a.<span class="built_in">length</span> <span class="keyword">if</span>!foundFirstNegative || a(i)&gt;=<span class="number">0</span>) yield&#123;</span><br><span class="line"> <span class="keyword">if</span>(a(i)&lt;<span class="number">0</span>) foundFirstNegative = <span class="literal">true</span></span><br><span class="line"> i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(i&lt;- <span class="number">0</span> <span class="keyword">until</span> keepIndexes.<span class="built_in">length</span>) &#123;a(i) = a(keepIndexes(i))&#125;</span><br><span class="line">a.trimEnd(a.<span class="built_in">length</span> - keepIndexes.<span class="built_in">length</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spark生态圈之Scala(三) ----- Scala中的数组操作(二)</title>
      <link href="/2018/05/08/BigData-Scala1-3/"/>
      <url>/2018/05/08/BigData-Scala1-3/</url>
      <content type="html"><![CDATA[<h3 id="数组常见操作"><a href="#数组常见操作" class="headerlink" title="数组常见操作"></a>数组常见操作</h3><p>数组元素求和<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val a = Array(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">val sum = a.sum</span><br></pre></td></tr></table></figure></p><p>获取数组最大值<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val <span class="built_in">max</span> = <span class="keyword">a</span>.<span class="built_in">max</span></span><br></pre></td></tr></table></figure></p><p>对数组进行排序<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scala<span class="selector-class">.util</span><span class="selector-class">.Sorting</span><span class="selector-class">.quickSort</span>(a)</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>获取数组中所有元素内容<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span>.mkString</span><br><span class="line"><span class="selector-tag">a</span>.mkString(<span class="string">","</span>)</span><br><span class="line"><span class="selector-tag">a</span>.mkString(<span class="string">"&lt;"</span>,<span class="string">","</span>,<span class="string">"&gt;"</span>)</span><br></pre></td></tr></table></figure></p><p>toString函数<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span>.toString</span><br><span class="line"><span class="selector-tag">b</span>.toString</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spark生态圈之Scala(二) ----- Scala中的数组操作(一)</title>
      <link href="/2018/05/07/BigData-Scala1-2/"/>
      <url>/2018/05/07/BigData-Scala1-2/</url>
      <content type="html"><![CDATA[<h3 id="Array数组"><a href="#Array数组" class="headerlink" title="Array数组"></a>Array数组</h3><p>在Scala中，Array代表的含义与Java类似，也是长度不可变的数组。此外，由于Scala与Java都是运行在JVM中，双方可以互相调用。因此，Scala数组的底层实际上是Java数组。例如，字符串数组在底层就是Java的String[],整数数组在底层就是Java的Int[]</p><p>数组初始化后，长度就固定下来了，而且元素全部根据其类型初始化<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val a = new Array[<span class="string">Int</span>](<span class="link">10</span>)</span><br><span class="line">val a = new Array[<span class="string">String</span>](<span class="link">10</span>)</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>可以直接使用Array()创建数组，元素类型自动推断<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val <span class="selector-tag">a</span> = Array(<span class="string">"hello"</span>,<span class="string">"world"</span>)</span><br><span class="line"><span class="function"><span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>=<span class="string">"hi"</span></span><br></pre></td></tr></table></figure></p><h3 id="ArrayBuffer数组"><a href="#ArrayBuffer数组" class="headerlink" title="ArrayBuffer数组"></a>ArrayBuffer数组</h3><p>在Scala中，如果需要类似于Java中的ArrayList这种长度可变的集合类，则可以使用ArrayBuffer</p><p>如果不想每次都使用全限定名，则可以预先导入ArrayBuffer类<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import scala<span class="selector-class">.collection</span><span class="selector-class">.mutable</span><span class="selector-class">.ArrayBuffer</span></span><br></pre></td></tr></table></figure></p><p>使用ArrayBuffer()的方式可以创建一个空的ArrayBuffer<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val b = ArrayBuffer[<span class="string">Int</span>](<span class="link"></span>)</span><br></pre></td></tr></table></figure></p><p>使用+=操作符，可以添加一个元素，或者多个元素<br>这个语法必须要谨记在心！因为Spark源码里大量使用了这种集合操作语法！<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b+=<span class="number">1</span></span><br><span class="line">b+=(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure></p><p>使用++=操作符，可以添加其他集合中的所有元素<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b++=Array(<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure></p><p>使用trimEnd()函数，可以从尾部截断指定个数的元素<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">b</span>.trimEnd(<span class="number">5</span>)</span><br></pre></td></tr></table></figure></p><p>使用insert()函数可以在指定位置插入元素<br>但是这种操作效率较低，因为需要移动指定位置后的所有元素<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b.insert(<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">b.insert(<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>)</span><br></pre></td></tr></table></figure></p><p>使用remove()函数可以移除指定位置的元素<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b.<span class="builtin-name">remove</span>(1)</span><br><span class="line">b.<span class="builtin-name">remove</span>(1,3)</span><br></pre></td></tr></table></figure></p><p>Array与ArrayBuffer可以互相进行转换<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">b</span>.toArray</span><br><span class="line"><span class="selector-tag">a</span>.toBuffer</span><br></pre></td></tr></table></figure></p><h3 id="遍历Array和ArrayBuffer数组"><a href="#遍历Array和ArrayBuffer数组" class="headerlink" title="遍历Array和ArrayBuffer数组"></a>遍历Array和ArrayBuffer数组</h3><p>使用for循环和until遍历Array/ArrayBuffer<br>使until是RichInt提供的函数<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(<span class="name">i</span> &lt;- <span class="number">0</span> until b.length)</span><br><span class="line">println(<span class="name">b</span>(<span class="name">i</span>))</span><br></pre></td></tr></table></figure></p><p>跳跃遍历Array / ArrayBuffer<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(<span class="name">i</span> &lt;- <span class="number">0</span> until (<span class="name">b</span>.length,<span class="number">2</span>))</span><br><span class="line"> println(<span class="name">b</span>(<span class="name">i</span>))</span><br></pre></td></tr></table></figure></p><p>从尾部遍历Array / ArrayBuffer<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(<span class="name">i</span> &lt;- (<span class="number">0</span> to b.length).reverse)</span><br><span class="line"> println(<span class="name">b</span>(<span class="name">i</span>))</span><br></pre></td></tr></table></figure></p><p>使用“增强for循环” 遍历Array/ArrayBuffer<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(<span class="name">e</span> &lt;- b)</span><br><span class="line"> println(<span class="name">e</span>)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spark生态圈之Scala(一) ----- Scala中的函数</title>
      <link href="/2018/05/07/BigData-Scala1-1/"/>
      <url>/2018/05/07/BigData-Scala1-1/</url>
      <content type="html"><![CDATA[<h3 id="Scala中的函数"><a href="#Scala中的函数" class="headerlink" title="Scala中的函数"></a>Scala中的函数</h3><h4 id="Scala定义函数"><a href="#Scala定义函数" class="headerlink" title="Scala定义函数"></a>Scala定义函数</h4><p>在Scala中定义函数时，需要定义函数的函数名、参数、函数体<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def sayHello(<span class="keyword">name</span>:<span class="keyword">String</span>,age:Int):Int =</span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  if(age&gt;18)</span></span><br><span class="line"><span class="comment">  &#123;</span></span><br><span class="line"><span class="comment">    printf("Hi,%s,you are a big boy!!!",name)</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line">  <span class="keyword">else</span><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    prinf("Hi,%s,you are a children",name)</span></span><br><span class="line"><span class="comment">    age</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>Scala要求必须给出所有参数的类型，但是不一定给出函数返回值的类型，只要右侧的函数体中不包含递归的语句，Scala就可以自己根据右侧的表达式推断出返回类型。</p><p>单行函数：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayHello</span><span class="params">(<span class="symbol">name:</span>String)</span></span><span class="symbol">:Unit</span> = println(<span class="string">"Hello"</span>+name)</span><br></pre></td></tr></table></figure></p><p>sum函数:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def sum(n:Int):Int=</span><br><span class="line">&#123;</span><br><span class="line">  var <span class="literal">result</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span>(i&lt;- <span class="number">1</span> <span class="keyword">to</span> n)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="literal">result</span> +=i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="literal">result</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>递归函数(斐波那契数列)：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fab</span><span class="params">(<span class="symbol">n:</span>Int)</span></span><span class="symbol">:Int</span> =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span> fab(n-<span class="number">1</span>)+fab(n-<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Scala函数中的默认参数"><a href="#Scala函数中的默认参数" class="headerlink" title="Scala函数中的默认参数"></a>Scala函数中的默认参数</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def sayHello(FirstName:<span class="keyword">String</span>,MiddleName:<span class="keyword">String</span>=<span class="string">""</span>,LastName:<span class="keyword">String</span>=<span class="string">""</span>):Unit =</span><br><span class="line"><span class="built_in">print</span>(FirstName+<span class="string">" "</span>+MiddleName+<span class="string">" "</span>+LastName)</span><br></pre></td></tr></table></figure><p>Java与Scala实现默认参数的区别:</p><p>Java:<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> sayHello(String name,<span class="keyword">int</span> age)        </span><br><span class="line">&#123;                                                </span><br><span class="line">    <span class="keyword">if</span>(name = <span class="keyword">null</span>)                                </span><br><span class="line">   &#123;                                           </span><br><span class="line">      name = <span class="string">"defaultName"</span>                        </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(age ==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      age = <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Scala:<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">def</span> <span class="selector-tag">sayHello</span>(<span class="attribute">name</span>:String,<span class="attribute">age</span>:Int=<span class="number">20</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="selector-tag">print</span>(<span class="string">"Hello,"</span>+name+<span class="string">", your age is "</span>+age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Scala函数中的带名参数"><a href="#Scala函数中的带名参数" class="headerlink" title="Scala函数中的带名参数"></a>Scala函数中的带名参数</h4><p>在调用函数时，也可以不按照函数定义的参数顺序来传递参数，而是使用带名参数的方式来传递<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">sayHello</span><span class="params">(FirstName=<span class="string">"Mick"</span>,LastName=<span class="string">"Nina"</span>,MiddleName=<span class="string">"jack"</span>)</span></span></span><br></pre></td></tr></table></figure></p><p>还可以混合使用未命名参数和带名参数，但是未命名参数必须排在带名参数前面<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">sayHello</span><span class="params">(<span class="string">"Mick"</span>,LastName=<span class="string">"Nina"</span>,MiddleName=<span class="string">"Jack"</span>)</span></span></span><br></pre></td></tr></table></figure></p><h4 id="Scala函数中的变长参数"><a href="#Scala函数中的变长参数" class="headerlink" title="Scala函数中的变长参数"></a>Scala函数中的变长参数</h4><p>在Scala中，有时我们需要将函数定义为参数个数可变的形式，则此时可以使用变长参数定义函数<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def <span class="built_in">sum</span>(nums : Int*)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">var</span> res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">num</span> &lt;- nums)</span><br><span class="line">       res += <span class="built_in">num</span></span><br><span class="line">    res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用序列调用变长参数：</p><p>在如果想要将一个已有的序列直接调用变长参数函数，是不对的。比如：<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s = sum(<span class="number">1</span> <span class="keyword">to</span> <span class="number">5</span>)</span><br></pre></td></tr></table></figure></p><p>此时需要使用Scala特殊的语法将参数定义为序列，让Scala解释器能够识别。这种语法非常有用！一定要好好注意，在Spark的源码中大量地使用到了。<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val s = <span class="built_in">sum</span>(<span class="number">1</span> to <span class="number">5</span>:<span class="keyword">_</span>*)</span><br></pre></td></tr></table></figure></p><p>案例：使用递归函数实现累加<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum2</span><span class="params">(<span class="symbol">nums:</span>Int*)</span></span><span class="symbol">:Int=</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="number">0</span></span><br><span class="line">     <span class="keyword">else</span> nums.head+sum2(nums.tail : <span class="number">_</span>*)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Scala函数的过程、lazy值和异常"><a href="#Scala函数的过程、lazy值和异常" class="headerlink" title="Scala函数的过程、lazy值和异常"></a>Scala函数的过程、lazy值和异常</h4><p>1、过程:<br>  在Scala中，定义函数时，如果函数体直接包裹在了花括号里面，而没有使用=连接，则函数的返回值类型就是Unit。这样的函数就被称之为过程。过程通常用于不需要返回值的函数</p><p>  过程还有一种写法，就是将函数的返回值类型定义为Unit<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayHello</span><span class="params">(<span class="symbol">name:</span>String)</span></span> = <span class="string">"Hello,"</span>+name</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayHello</span><span class="params">(<span class="symbol">name:</span>String)</span></span> &#123;print(<span class="string">"Hello,"</span>+name);<span class="string">"Hello,"</span>+name&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayHello</span><span class="params">(<span class="symbol">name:</span>String)</span></span><span class="symbol">:Unit</span> = <span class="string">"Hello,"</span>+name</span><br></pre></td></tr></table></figure></p><p>2、lazy值：<br>  在Scala中，提供了lazy值的特性，也就是说，如果将一个变量声明为lazy，则只有在第一次使用该变量时，变量对应的表达式才会发生计算。这种特性对于特别耗时的计算操作特别有用，比如打开文件进行IO，进行网络IO等。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.io.<span class="type">Source</span>._</span><br><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> lines = fromFile(<span class="string">"C://Users//Administrator//Desktop//test.txt"</span>).mkString</span><br></pre></td></tr></table></figure><p>即使文件不存在，也不会报错，只有第一个使用变量时会报错，证明了表达式计算的lazy特性<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> lines = fromFile(<span class="string">"C://Users//Administrator//Desktop//test.txt"</span>).mkString</span><br><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> lines = fromFile(<span class="string">"C://Users//Administractor//Desktop//test.txt"</span>).mkString</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lines</span> </span>= fromFile(<span class="string">"C://Users//Administrator//Desktop//test.txt"</span>).mkString</span><br></pre></td></tr></table></figure></p><p>3、异常:<br>  在Scala中，异常处理和捕获机制与Java是非常相似的</p>]]></content>
      
      <categories>
          
          <category> Scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Scala </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>随笔(一)</title>
      <link href="/2018/05/02/jottings-%E4%B8%80/"/>
      <url>/2018/05/02/jottings-%E4%B8%80/</url>
      <content type="html"><![CDATA[<p><img src="/2018/05/02/jottings-一/jottings-1.jpg" alt="jottings"><br><a id="more"></a><br><strong>或许世界不是你预期的模样<br>柴米油盐包裹着大胆的梦想<br>学会了成熟，一直保持善良<br>勇敢哭、用力笑、别逞强<br>不勉强追寻飞到多高的地方<br>只要你快乐才是唯一的真相<br>当你扮大人，扮到疲惫了<br>有个家让你做回孩子。</strong></p>]]></content>
      
      <categories>
          
          <category> thoughts </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jottings </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hadoop生态圈(二) ----- Kafka的使用(四)</title>
      <link href="/2018/04/28/BigData-Kafka-%E5%9B%9B/"/>
      <url>/2018/04/28/BigData-Kafka-%E5%9B%9B/</url>
      <content type="html"><![CDATA[<p>  <img src="/2018/04/28/BigData-Kafka-四/kafka6.png" alt="Kafka拦截器"><br><a id="more"></a></p><h3 id="Kafka-producer拦截器-interceptor"><a href="#Kafka-producer拦截器-interceptor" class="headerlink" title="Kafka producer拦截器(interceptor)"></a>Kafka producer拦截器(interceptor)</h3><h4 id="拦截器原理"><a href="#拦截器原理" class="headerlink" title="拦截器原理"></a>拦截器原理</h4><p>Producer拦截器(interceptor)是在Kafka 0.10版本被引入的，主要用于实现clients端的定制化控制逻辑。</p><p>　　对于producer而言，interceptor使得用户在消息发送前以及producer回调逻辑前有机会对消息做一些定制化需求，比如修改消息等。同时，producer允许用户指定多个interceptor按序作用于同一条消息从而形成一个拦截链(interceptor chain)。Intercetpor的实现接口是org.apache.kafka.clients.producer.ProducerInterceptor，其定义的方法包括：</p><p>  （1）onSend(ProducerRecord)：<br>  该方法封装进KafkaProducer.send方法中，即它运行在用户主线程中。Producer确保在消息被序列化以计算分区前调用该方法。用户可以在该方法中对消息做任何操作，但最好保证不要修改消息所属的topic和分区，否则会影响目标分区的计算</p><p>  （2）onAcknowledgement(RecordMetadata, Exception)：<br>  该方法会在消息被应答之前或消息发送失败时调用，并且通常都是在producer回调逻辑触发之前。onAcknowledgement运行在producer的IO线程中，因此不要在该方法中放入很重的逻辑，否则会拖慢producer的消息发送效率</p><p>  （3）close：<br>  关闭interceptor，主要用于执行一些资源清理工作</p><p>如前所述，interceptor可能被运行在多个线程中，因此在具体实现时用户需要自行确保线程安全。另外倘若指定了多个interceptor，则producer将按照指定顺序调用它们，并仅仅是捕获每个interceptor可能抛出的异常记录到错误日志中而非在向上传递。这在使用过程中要特别留意。</p><h4 id="拦截器案例"><a href="#拦截器案例" class="headerlink" title="拦截器案例"></a>拦截器案例</h4><p>  1）需求：<br>  实现一个简单的双interceptor组成的拦截链。第一个interceptor会在消息发送前将时间戳信息加到消息value的最前部；第二个interceptor会在消息发送后更新成功发送消息数或失败发送消息数。<br>  <img src="/2018/04/28/BigData-Kafka-四/kafka6.png" alt="Kafka拦截器"></p><p>  2）案例实操<br>    (1)增加时间戳拦截器<br>    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">package</span> com.atguigu.kafka.interceptor;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.RecordMetadata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeInterceptor</span> <span class="keyword">implements</span> <span class="title">ProducerInterceptor</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, ?&gt; configs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProducerRecord&lt;String, String&gt; <span class="title">onSend</span><span class="params">(ProducerRecord&lt;String, String&gt; record)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建一个新的record，把时间戳写入消息体的最前部</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ProducerRecord(record.topic(), record.partition(), record.timestamp(), record.key(),</span><br><span class="line">System.currentTimeMillis() + <span class="string">","</span> + record.value().toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAcknowledgement</span><span class="params">(RecordMetadata metadata, Exception exception)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（2）统计发送消息成功和发送失败消息数，并在producer关闭时打印这两个计数器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.kafka.interceptor;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.RecordMetadata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CounterInterceptor</span> <span class="keyword">implements</span> <span class="title">ProducerInterceptor</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> errorCounter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> successCounter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, ?&gt; configs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ProducerRecord&lt;String, String&gt; <span class="title">onSend</span><span class="params">(ProducerRecord&lt;String, String&gt; record)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> record;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAcknowledgement</span><span class="params">(RecordMetadata metadata, Exception exception)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 统计成功和失败的次数</span></span><br><span class="line">        <span class="keyword">if</span> (exception == <span class="keyword">null</span>) &#123;</span><br><span class="line">            successCounter++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            errorCounter++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保存结果</span></span><br><span class="line">        System.out.println(<span class="string">"Successful sent: "</span> + successCounter);</span><br><span class="line">        System.out.println(<span class="string">"Failed sent: "</span> + errorCounter);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（3）producer主程序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.kafka.interceptor;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.KafkaProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.Producer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 1 设置配置信息</span></span><br><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"hadoop102:9092"</span>);</span><br><span class="line">props.put(<span class="string">"acks"</span>, <span class="string">"all"</span>);</span><br><span class="line">props.put(<span class="string">"retries"</span>, <span class="number">0</span>);</span><br><span class="line">props.put(<span class="string">"batch.size"</span>, <span class="number">16384</span>);</span><br><span class="line">props.put(<span class="string">"linger.ms"</span>, <span class="number">1</span>);</span><br><span class="line">props.put(<span class="string">"buffer.memory"</span>, <span class="number">33554432</span>);</span><br><span class="line">props.put(<span class="string">"key.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line">props.put(<span class="string">"value.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 构建拦截链</span></span><br><span class="line">List&lt;String&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">interceptors.add(<span class="string">"com.atguigu.kafka.interceptor.TimeInterceptor"</span>); interceptors.add(<span class="string">"com.atguigu.kafka.interceptor.CounterInterceptor"</span>);</span><br><span class="line">props.put(ProducerConfig.INTERCEPTOR_CLASSES_CONFIG, interceptors);</span><br><span class="line"></span><br><span class="line">String topic = <span class="string">"first"</span>;</span><br><span class="line">Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3 发送消息</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">    ProducerRecord&lt;String, String&gt; record = <span class="keyword">new</span> ProducerRecord&lt;&gt;(topic, <span class="string">"message"</span> + i);</span><br><span class="line">    producer.send(record).get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4 一定要关闭producer，这样才会调用interceptor的close方法</span></span><br><span class="line">producer.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4）测试<br>（1）在kafka上启动消费者，然后运行客户端java程序。</p><blockquote><p>[atguigu@hadoop102 kafka]$ in/kafka-console-consumer.sh –zookeeper hadoop102:2181 –from-beginning –topic first<br>1501904047034,message0<br>1501904047225,message1<br>1501904047230,message2<br>1501904047234,message3<br>1501904047236,message4<br>1501904047240,message5<br>1501904047243,message6<br>1501904047246,message7<br>1501904047249,message8<br>1501904047252,message9</p></blockquote><p>（2）观察java平台控制台输出数据如下：</p><blockquote><p>Successful sent: 10<br>Failed sent: 0</p></blockquote><h3 id="Kafka-stream"><a href="#Kafka-stream" class="headerlink" title="Kafka stream"></a>Kafka stream</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>1) Kafka Stream<br>  Kafka Streams。Apache Kafka开源项目的一个组成部分。是一个功能强大，易于使用的库。用于在Kafka上构建高可分布式、拓展性，容错的应用程序。它建立在流处理的一系列重要功能基础之上，比如正确区分事件和处理时间，处理迟到数据以及高效的应用程序状态管理。</p><p>2)  Kafka Stream 特点<br>  ① 功能强大<br>  高拓展性，弹性，容错<br>  有状态和无状态处理<br>  基于事件时间的Window，Join，Aggergations<br>  ② 轻量级<br>  无需专门的集群<br>  一个库，而不是框架<br>  ③ 完全集成<br>  100%的Kafka 0.10.0版本兼容<br>  易于集成到现有的应用程序<br>  程序部署无需手工处理(这个指的应该是Kafka多分区机制对Kafka Streams多实例的自动匹配)<br>  ④ 实时性<br>  毫秒级延迟<br>  并非微批处理<br>  窗口允许乱序数据<br>  允许迟到数据</p><p>3) 为什么要有Kafka Stream<br>当前已经有非常多的流式处理系统，最知名且应用最多的开源流式处理系统有Spark Streaming和Apache Storm。Apache Storm发展多年，应用广泛，提供记录级别的处理能力，当前也支持SQL on Stream。而Spark Streaming基于Apache Spark，可以非常方便与图计算，SQL处理等集成，功能强大，对于熟悉其它Spark应用开发的用户而言使用门槛低。另外，目前主流的Hadoop发行版，如MapR，Cloudera和Hortonworks，都集成了Apache Storm和Apache Spark，使得部署更容易。<br>既然Apache Spark与Apache Storm拥用如此多的优势，那为何还需要Kafka Stream呢？笔者认为主要有如下原因。<br>  第一，Spark和Storm都是流式处理框架，而Kafka Stream提供的是一个基于Kafka的流式处理类库。框架要求开发者按照特定的方式去开发逻辑部分，供框架调用。开发者很难了解框架的具体运行方式，从而使得调试成本高，并且使用受限。而Kafka Stream作为流式处理类库，直接提供具体的类给开发者调用，整个应用的运行方式主要由开发者控制，方便使用和调试。<br>  第二，虽然Cloudera与Hortonworks方便了Storm和Spark的部署，但是这些框架的部署仍然相对复杂。而Kafka Stream作为类库，可以非常方便的嵌入应用程序中，它对应用的打包和部署基本没有任何要求。更为重要的是，Kafka Stream充分利用了Kafka的分区机制和Consumer的Rebalance机制，使得Kafka Stream可以非常方便的水平扩展，并且各个实例可以使用不同的部署方式。具体来说，每个运行Kafka Stream的应用程序实例都包含了Kafka Consumer实例，多个同一应用的实例之间并行处理数据集。而不同实例之间的部署方式并不要求一致，比如部分实例可以运行在Web容器中，部分实例可运行在Docker或Kubernetes中。<br>  第三，就流式处理系统而言，基本都支持Kafka作为数据源。例如Storm具有专门的kafka-spout，而Spark也提供专门的spark-streaming-kafka模块。事实上，Kafka基本上是主流的流式处理系统的标准数据源。换言之，大部分流式系统中都已部署了Kafka，此时使用Kafka Stream的成本非常低。<br>  第四，使用Storm或Spark Streaming时，需要为框架本身的进程预留资源，如Storm的supervisor和Spark on YARN的node manager。即使对于应用实例而言，框架本身也会占用部分资源，如Spark Streaming需要为shuffle和storage预留内存。<br>  第五，由于Kafka本身提供数据持久化，因此Kafka Stream提供滚动部署和滚动升级以及重新计算的能力。<br>  第六，由于Kafka Consumer Rebalance机制，Kafka Stream可以在线动态调整并行度。</p><h4 id="Kafka-Stream案例"><a href="#Kafka-Stream案例" class="headerlink" title="Kafka Stream案例"></a>Kafka Stream案例</h4><p>  去除单词前缀“&gt;&gt;&gt;”案例<br>  0）需求：<br>    实时处理单词带有”&gt;&gt;&gt;”前缀的内容。例如输入”atguigu&gt;&gt;&gt;jingjing”，最终处理成“jingjing”</p><p>  1）创建主类<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">package</span> com.atguigu.kafka.stream;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.streams.KafkaStreams;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.streams.StreamsConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.streams.processor.Processor;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.streams.processor.ProcessorSupplier;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.streams.processor.TopologyBuilder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义输入的topic</span></span><br><span class="line">        String from = <span class="string">"first"</span>;</span><br><span class="line">        <span class="comment">// 定义输出的topic</span></span><br><span class="line">        String to = <span class="string">"second"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置参数</span></span><br><span class="line">        Properties settings = <span class="keyword">new</span> Properties();</span><br><span class="line">        settings.put(StreamsConfig.APPLICATION_ID_CONFIG, <span class="string">"logFilter"</span>);</span><br><span class="line">        settings.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">"hadoop102:9092"</span>);</span><br><span class="line"></span><br><span class="line">        StreamsConfig config = <span class="keyword">new</span> StreamsConfig(settings);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建拓扑</span></span><br><span class="line">        TopologyBuilder builder = <span class="keyword">new</span> TopologyBuilder();</span><br><span class="line"></span><br><span class="line">        builder.addSource(<span class="string">"SOURCE"</span>, from)</span><br><span class="line">               .addProcessor(<span class="string">"PROCESS"</span>, <span class="keyword">new</span> ProcessorSupplier&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt;() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Processor&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; get() &#123;</span><br><span class="line"><span class="comment">// 具体分析处理</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> LogProcessor();</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">"SOURCE"</span>)</span><br><span class="line">                .addSink(<span class="string">"SINK"</span>, to, <span class="string">"PROCESS"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建kafka stream</span></span><br><span class="line">        KafkaStreams streams = <span class="keyword">new</span> KafkaStreams(builder, config);</span><br><span class="line">        streams.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  2)具体业务处理<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">package</span> com.atguigu.kafka.stream;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.streams.processor.Processor;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.streams.processor.ProcessorContext;</span><br><span class="line"></span><br><span class="line">public class LogProcessor implements Processor&lt;byte[], byte[]&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ProcessorContext context;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessorContext context)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.context = context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] value)</span> </span>&#123;</span><br><span class="line">String input = <span class="keyword">new</span> String(value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果包含“&gt;&gt;&gt;”则只保留该标记后面的内容</span></span><br><span class="line"><span class="keyword">if</span> (input.contains(<span class="string">"&gt;&gt;&gt;"</span>)) &#123;</span><br><span class="line">input = input.split(<span class="string">"&gt;&gt;&gt;"</span>)[<span class="number">1</span>].trim();</span><br><span class="line"><span class="comment">// 输出到下一个topic</span></span><br><span class="line">context.forward(<span class="string">"logProcessor"</span>.getBytes(), input.getBytes());</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">context.forward(<span class="string">"logProcessor"</span>.getBytes(), input.getBytes());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">punctuate</span><span class="params">(<span class="keyword">long</span> timestamp)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3）将程序用eclipse插件打成jar包</p><p>4）将jar包拷贝hadoop102上运行</p><blockquote><p>[atguigu@hadoop102 kafka]$ java -jar kafka0508_fat.jar com.atguigu.kafka.stream.Application</p></blockquote><p>5）在hadoop104上启动生产者</p><blockquote><p>[atguigu@hadoop104 kafka]$ bin/kafka-console-producer.sh –broker-list hadoop102:9092 –topic first<br>$&gt;hello&gt;&gt;&gt;world<br>$&gt;h&gt;&gt;&gt;atguigu<br>$&gt;hahaha</p></blockquote><p>6）在hadoop103山启动消费者</p><blockquote><p>[atguigu@hadoop103 kafka]$ bin/kafka-console-consumer.sh –zookeeper hadoop102:2181 –from-beginning –topic second<br>world<br>atguigu<br>hahaha</p></blockquote>]]></content>
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hadoop生态圈(二) ----- Kafka的使用(三)</title>
      <link href="/2018/04/28/BigData-Kafka-%E4%B8%89/"/>
      <url>/2018/04/28/BigData-Kafka-%E4%B8%89/</url>
      <content type="html"><![CDATA[<h3 id="Kafka-API操作"><a href="#Kafka-API操作" class="headerlink" title="Kafka API操作"></a>Kafka API操作</h3><h4 id="创建生产者"><a href="#创建生产者" class="headerlink" title="创建生产者"></a>创建生产者</h4><p>过时的API:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.kafka;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> kafka.javaapi.producer.Producer;</span><br><span class="line"><span class="keyword">import</span> kafka.producer.KeyedMessage;</span><br><span class="line"><span class="keyword">import</span> kafka.producer.ProducerConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OldProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">properties.put(<span class="string">"metadata.broker.list"</span>, <span class="string">"hadoop102:9092"</span>);</span><br><span class="line">properties.put(<span class="string">"request.required.acks"</span>, <span class="string">"1"</span>);</span><br><span class="line">properties.put(<span class="string">"serializer.class"</span>, <span class="string">"kafka.serializer.StringEncoder"</span>);</span><br><span class="line"></span><br><span class="line">Producer&lt;Integer, String&gt; producer = <span class="keyword">new</span> Producer&lt;Integer,String&gt;(<span class="keyword">new</span> ProducerConfig(properties));</span><br><span class="line"></span><br><span class="line">KeyedMessage&lt;Integer, String&gt; message = <span class="keyword">new</span> KeyedMessage&lt;Integer, String&gt;(<span class="string">"first"</span>, <span class="string">"hello world"</span>);</span><br><span class="line">producer.send(message );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>新的API:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.kafka;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.KafkaProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.Producer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">// Kafka服务端的主机名和端口号</span></span><br><span class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"hadoop103:9092"</span>);</span><br><span class="line"><span class="comment">// 等待所有副本节点的应答</span></span><br><span class="line">props.put(<span class="string">"acks"</span>, <span class="string">"all"</span>);</span><br><span class="line"><span class="comment">// 消息发送最大尝试次数</span></span><br><span class="line">props.put(<span class="string">"retries"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 一批消息处理大小</span></span><br><span class="line">props.put(<span class="string">"batch.size"</span>, <span class="number">16384</span>);</span><br><span class="line"><span class="comment">// 请求延时</span></span><br><span class="line">props.put(<span class="string">"linger.ms"</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 发送缓存区内存大小</span></span><br><span class="line">props.put(<span class="string">"buffer.memory"</span>, <span class="number">33554432</span>);</span><br><span class="line"><span class="comment">// key序列化</span></span><br><span class="line">props.put(<span class="string">"key.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line"><span class="comment">// value序列化</span></span><br><span class="line">props.put(<span class="string">"value.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line"></span><br><span class="line">Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">producer.send(<span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(<span class="string">"first"</span>, Integer.toString(i), <span class="string">"hello world-"</span> + i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">producer.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="创建生产者带回调函数"><a href="#创建生产者带回调函数" class="headerlink" title="创建生产者带回调函数"></a>创建生产者带回调函数</h4><p>新API:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.kafka;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.Callback;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.KafkaProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.RecordMetadata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallBackProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">// Kafka服务端的主机名和端口号</span></span><br><span class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"hadoop103:9092"</span>);</span><br><span class="line"><span class="comment">// 等待所有副本节点的应答</span></span><br><span class="line">props.put(<span class="string">"acks"</span>, <span class="string">"all"</span>);</span><br><span class="line"><span class="comment">// 消息发送最大尝试次数</span></span><br><span class="line">props.put(<span class="string">"retries"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 一批消息处理大小</span></span><br><span class="line">props.put(<span class="string">"batch.size"</span>, <span class="number">16384</span>);</span><br><span class="line"><span class="comment">// 增加服务端请求延时</span></span><br><span class="line">props.put(<span class="string">"linger.ms"</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 发送缓存区内存大小</span></span><br><span class="line">props.put(<span class="string">"buffer.memory"</span>, <span class="number">33554432</span>);</span><br><span class="line"><span class="comment">// key序列化</span></span><br><span class="line">props.put(<span class="string">"key.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line"><span class="comment">// value序列化</span></span><br><span class="line">props.put(<span class="string">"value.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line"></span><br><span class="line">KafkaProducer&lt;String, String&gt; kafkaProducer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">kafkaProducer.send(<span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(<span class="string">"first"</span>, <span class="string">"hello"</span> + i), <span class="keyword">new</span> Callback() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompletion</span><span class="params">(RecordMetadata metadata, Exception exception)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (metadata != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">System.err.println(metadata.partition() + <span class="string">"---"</span> + metadata.offset());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kafkaProducer.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="自定义分区生产者"><a href="#自定义分区生产者" class="headerlink" title="自定义分区生产者"></a>自定义分区生产者</h4><p>  0) 需求:将所有数据存储到topic的第0将所有数据存储到topic的第0号分区上</p><p>  1) 定义一个类实现Partitioner接口，重写里面的方法(过时API)<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">package</span> com.atguigu.kafka;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> kafka.producer.Partitioner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomPartitioner</span> <span class="keyword">implements</span> <span class="title">Partitioner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CustomPartitioner</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Object key, <span class="keyword">int</span> numPartitions)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 控制分区</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  2) 自定义分区(新API)<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">package</span> com.atguigu.kafka;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.Partitioner;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.common.Cluster;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomPartitioner</span> <span class="keyword">implements</span> <span class="title">Partitioner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Map&lt;String, ?&gt; configs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 控制分区</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  3) 在代码中调用<br>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">package</span> com.atguigu.kafka;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.KafkaProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.Producer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartitionerProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">// Kafka服务端的主机名和端口号</span></span><br><span class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"hadoop103:9092"</span>);</span><br><span class="line"><span class="comment">// 等待所有副本节点的应答</span></span><br><span class="line">props.put(<span class="string">"acks"</span>, <span class="string">"all"</span>);</span><br><span class="line"><span class="comment">// 消息发送最大尝试次数</span></span><br><span class="line">props.put(<span class="string">"retries"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 一批消息处理大小</span></span><br><span class="line">props.put(<span class="string">"batch.size"</span>, <span class="number">16384</span>);</span><br><span class="line"><span class="comment">// 增加服务端请求延时</span></span><br><span class="line">props.put(<span class="string">"linger.ms"</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 发送缓存区内存大小</span></span><br><span class="line">props.put(<span class="string">"buffer.memory"</span>, <span class="number">33554432</span>);</span><br><span class="line"><span class="comment">// key序列化</span></span><br><span class="line">props.put(<span class="string">"key.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line"><span class="comment">// value序列化</span></span><br><span class="line">props.put(<span class="string">"value.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringSerializer"</span>);</span><br><span class="line"><span class="comment">// 自定义分区</span></span><br><span class="line">props.put(<span class="string">"partitioner.class"</span>, <span class="string">"com.atguigu.kafka.CustomPartitioner"</span>);</span><br><span class="line"></span><br><span class="line">Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line">producer.send(<span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(<span class="string">"first"</span>, <span class="string">"1"</span>, <span class="string">"atguigu"</span>));</span><br><span class="line"></span><br><span class="line">producer.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  4) 测试<br>  （1）在hadoop102上监控/opt/module/kafka/logs/目录下first主题3个分区的log日志动态变化情况</p><blockquote><p>[atguigu@hadoop102 first-0]$ tail -f 00000000000000000000.log<br>  [atguigu@hadoop102 first-1]$ tail -f 00000000000000000000.log<br>  [atguigu@hadoop102 first-2]$ tail -f 00000000000000000000.log</p></blockquote><p>  （2）发现数据都存储到指定的分区了。</p><h4 id="Kafka-消费者API"><a href="#Kafka-消费者API" class="headerlink" title="Kafka 消费者API"></a>Kafka 消费者API</h4><p>0）在控制台创建发送者</p><blockquote><p>[atguigu@hadoop104 kafka]$ bin/kafka-console-producer.sh –broker-list hadoop102:9092 –topic first<br>$&gt;hello world</p></blockquote><p>1）创建消费者（过时API）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.kafka.consume;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> kafka.consumer.Consumer;</span><br><span class="line"><span class="keyword">import</span> kafka.consumer.ConsumerConfig;</span><br><span class="line"><span class="keyword">import</span> kafka.consumer.ConsumerIterator;</span><br><span class="line"><span class="keyword">import</span> kafka.consumer.KafkaStream;</span><br><span class="line"><span class="keyword">import</span> kafka.javaapi.consumer.ConsumerConnector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">properties.put(<span class="string">"zookeeper.connect"</span>, <span class="string">"hadoop102:2181"</span>);</span><br><span class="line">properties.put(<span class="string">"group.id"</span>, <span class="string">"g1"</span>);</span><br><span class="line">properties.put(<span class="string">"zookeeper.session.timeout.ms"</span>, <span class="string">"500"</span>);</span><br><span class="line">properties.put(<span class="string">"zookeeper.sync.time.ms"</span>, <span class="string">"250"</span>);</span><br><span class="line">properties.put(<span class="string">"auto.commit.interval.ms"</span>, <span class="string">"1000"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建消费者连接器</span></span><br><span class="line">ConsumerConnector consumer = Consumer.createJavaConsumerConnector(<span class="keyword">new</span> ConsumerConfig(properties));</span><br><span class="line"></span><br><span class="line">HashMap&lt;String, Integer&gt; topicCount = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">topicCount.put(<span class="string">"first"</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Map&lt;String, List&lt;KafkaStream&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt;&gt;&gt; consumerMap = consumer.createMessageStreams(topicCount);</span><br><span class="line"></span><br><span class="line">KafkaStream&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; stream = consumerMap.get(<span class="string">"first"</span>).get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">ConsumerIterator&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; it = stream.iterator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(it.next().message()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2）官方提供案例（自动维护消费情况）（新API）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.kafka.consume;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecords;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.KafkaConsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomNewConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">// 定义kakfa 服务的地址，不需要将所有broker指定上</span></span><br><span class="line">props.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"hadoop102:9092"</span>);</span><br><span class="line"><span class="comment">// 制定consumer group</span></span><br><span class="line">props.put(<span class="string">"group.id"</span>, <span class="string">"test"</span>);</span><br><span class="line"><span class="comment">// 是否自动确认offset</span></span><br><span class="line">props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"true"</span>);</span><br><span class="line"><span class="comment">// 自动确认offset的时间间隔</span></span><br><span class="line">props.put(<span class="string">"auto.commit.interval.ms"</span>, <span class="string">"1000"</span>);</span><br><span class="line"><span class="comment">// key的序列化类</span></span><br><span class="line">props.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line"><span class="comment">// value的序列化类</span></span><br><span class="line">props.put(<span class="string">"value.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line"><span class="comment">// 定义consumer</span></span><br><span class="line">KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者订阅的topic, 可同时订阅多个</span></span><br><span class="line">consumer.subscribe(Arrays.asList(<span class="string">"first"</span>, <span class="string">"second"</span>,<span class="string">"third"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">// 读取数据，读取超时时间为100ms</span></span><br><span class="line">ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)</span><br><span class="line">System.out.printf(<span class="string">"offset = %d, key = %s, value = %s%n"</span>, record.offset(), record.key(), record.value());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hadoop生态圈(二) ----- Kafka的使用(二)</title>
      <link href="/2018/04/28/BigData-Kafka-%E4%BA%8C/"/>
      <url>/2018/04/28/BigData-Kafka-%E4%BA%8C/</url>
      <content type="html"><![CDATA[<p><img src="/2018/04/28/BigData-Kafka-二/kafka1.png" alt="Kafka内部实现原理"><br><a id="more"></a></p><h3 id="Kafka工作流程分析"><a href="#Kafka工作流程分析" class="headerlink" title="Kafka工作流程分析"></a>Kafka工作流程分析</h3><hr><h4 id="Kafka生产过程分析"><a href="#Kafka生产过程分析" class="headerlink" title="Kafka生产过程分析"></a>Kafka生产过程分析</h4><p>  1) 写入方式<br>  producer采用推（push）模式将消息发布到broker，每条消息都被追加（append）到分区（patition）中，属于顺序写磁盘（顺序写磁盘效率比随机写内存要高，保障kafka吞吐率）。</p><p>  2) 分区<br>  消息发送时都被发送到一个topic，其本质就是一个目录，而topic是由一些Partition Logs(分区日志)组成，其组织结构如下图所示：<br>  <img src="/2018/04/28/BigData-Kafka-二/kafka2.png" alt="分区"></p><p>  <img src="/2018/04/28/BigData-Kafka-二/kafka3.png" alt="分区"><br>  我们可以看到，每个Partition中的消息都是有序的，生产的消息被不断追加到Partition log上，其中的每一个消息都被赋予了一个唯一的offset值。</p><p>  ① 分区的原因<br>  （1）方便在集群中扩展，每个Partition可以通过调整以适应它所在的机器，而一个topic又可以有多个Partition组成，因此整个集群就可以适应任意大小的数据了；<br>  （2）可以提高并发，因为可以以Partition为单位读写了。</p><p>  ② 分区的原则<br>  （1）指定了patition，则直接使用；<br>  （2）未指定patition但指定key，通过对key的value进行hash出一个patition</p><p>  ③ patition和key都未指定，使用轮询选出一个patition。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DefaultPartitioner类</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(String topic, Object key, <span class="keyword">byte</span>[] keyBytes, Object value, <span class="keyword">byte</span>[] valueBytes, Cluster cluster)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line">      <span class="keyword">int</span> numPartitions = partitions.size();</span><br><span class="line">      <span class="keyword">if</span> (keyBytes == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">int</span> nextValue = nextValue(topic);</span><br><span class="line">          List&lt;PartitionInfo&gt; availablePartitions = cluster.availablePartitionsForTopic(topic);</span><br><span class="line">          <span class="keyword">if</span> (availablePartitions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">int</span> part = Utils.toPositive(nextValue) % availablePartitions.size();</span><br><span class="line">              <span class="keyword">return</span> availablePartitions.get(part).partition();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// no partitions are available, give a non-available partition</span></span><br><span class="line">              <span class="keyword">return</span> Utils.toPositive(nextValue) % numPartitions;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// hash the keyBytes to choose a partition</span></span><br><span class="line">          <span class="keyword">return</span> Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>  3) 副本<br>  同一个partition可能会有多个replication（对应 server.properties 配置中的 default.replication.factor=N）。没有replication的情况下，一旦broker 宕机，其上所有 patition 的数据都不可被消费，同时producer也不能再将数据存于其上的patition。引入replication之后，同一个partition可能会有多个replication，而这时需要在这些replication之间选出一个leader，producer和consumer只与这个leader交互，其它replication作为follower从leader 中复制数据。</p><p>  4) 写入流程<br>   producer写入消息流程如下：</p><p>  <img src="/2018/04/28/BigData-Kafka-二/kafka4.png" alt="写入流程"></p><p>  ① producer先从zookeeper的 “/brokers/…/state”节点找到该partition的leader<br>  ② producer将消息发送给该leader<br>  ③ leader将消息写入本地log<br>  ④ followers从leader pull消息，写入本地log后向leader发送ACK<br>  ⑤ leader收到所有ISR中的replication的ACK后，增加HW（high watermark，最后commit 的offset）并向producer发送ACK</p><h4 id="broker保存消息"><a href="#broker保存消息" class="headerlink" title="broker保存消息"></a>broker保存消息</h4><p>  1)存储方式<br>  物理上把topic分成一个或多个partition（对应 server.properties 中的num.partitions=3配置），每个patition物理上对应一个文件夹（该文件夹存储该patition的所有消息和索引文件)</p><p>  2)存储策略<br>  无论消息是否被消费，kafka都会保留所有消息。有两种策略可以删除旧数据：<br>  1）基于时间：log.retention.hours=168<br>  2）基于大小：log.retention.bytes=1073741824<br>  需要注意的是，因为Kafka读取特定消息的时间复杂度为O(1)，即与文件大小无关，所以这里删除过期文件与提高 Kafka 性能无关。</p><p>  3)Zookeeper存储结构<br><img src="/2018/04/28/BigData-Kafka-二/zookeeper.png" alt="写入流程"><br>注意：producer不在zk中注册，消费者在zk中注册。</p><h4 id="Kafka消费过程分析"><a href="#Kafka消费过程分析" class="headerlink" title="Kafka消费过程分析"></a>Kafka消费过程分析</h4><p>kafka提供了两套consumer API：高级Consumer API和低级API。<br>1) 高级API<br>  (1)高级API优点<br>  高级API 写起来简单不需要去自行去管理offset，系统通过zookeeper自行管理不需要管理分区，副本等情况，系统自动管理消费者断线会自动根据上一次记录在zookeeper中的offset去接着获取数据（默认设置1分钟更新一下zookeeper中存的的offset）可以使用group来区分对同一个topic 的不同程序访问分离开来（不同的group记录不同的offset，这样不同程序读取同一个topic才不会因为offset互相影响）<br>  (2)高级API缺点<br>  不能自行控制offset（对于某些特殊需求来说）<br>  不能细化控制如分区、副本、zk等</p><p>2) 低级API<br>  (1)低级API优点<br>  能够开发者自己控制offset，想从哪里读取就从哪里读取。自行控制连接分区，对分区自定义进行负载均衡对zookeeper的依赖性降低（如：offset不一定非要靠zk存储，自行存储offset即可，比如存在文件或者内存中）<br>  (2)低级API缺点<br>  太过复杂，需要自行控制offset，连接哪个分区，找到分区leader 等。</p><p>3) 消费者组<br><img src="/2018/04/28/BigData-Kafka-二/kafka5.png" alt="消费者组"><br>  消费者是以consumer group消费者组的方式工作，由一个或者多个消费者组成一个组，共同消费一个topic。每个分区在同一时间只能由group中的一个消费者读取，但是多个group可以同时消费这个partition。在图中，有一个由三个消费者组成的grouop，有一个消费者读取主题中的两个分区，另外两个分别读取一个分区。某个消费者读取某个分区，也可以叫做某个消费者是某个分区的拥有者。在这种情况下，消费者可以通过水平扩展的方式同时读取大量的消息。另外，如果一个消费者失败了，那么其他的group成员会自动负载均衡读取之前失败的消费者读取的分区。</p><p>4) 消费方式<br><strong>consumer采用pull（拉）模式从broker中读取数据。</strong><br>push（推）模式很难适应消费速率不同的消费者，因为消息发送速率是由broker决定的。它的目标是尽可能以最快速度传递消息，但是这样很容易造成consumer来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而pull模式则可以根据consumer的消费能力以适当的速率消费消息。<br>对于Kafka而言，pull模式更合适，它可简化broker的设计，consumer可自主控制消费消息的速率，同时consumer可以自己控制消费方式——即可批量消费也可逐条消费，同时还能选择不同的提交方式从而实现不同的传输语义。</p><p>5) 消费者组案例<br>(1)需求：测试同一个消费者组中的消费者，同一时刻只能有一个消费者消费。<br>(2)案例实操<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">① 在hadoop102、hadoop103上修改/opt/module/kafka/config/consumer.properties配置文件中的group.id属性为任意组名。</span><br><span class="line">[atguigu@hadoop103 config]$ vi consumer<span class="selector-class">.properties</span> group.id=atguigu</span><br><span class="line">② 在hadoop102、hadoop103上分别启动消费者</span><br><span class="line">[atguigu@hadoop102 kafka]$ bin/kafka-console-consumer<span class="selector-class">.sh</span> --zookeeper hadoop102:<span class="number">2181</span> --topic first --consumer<span class="selector-class">.config</span> config/consumer.properties</span><br><span class="line">[atguigu@hadoop103 kafka]$ bin/kafka-console-consumer<span class="selector-class">.sh</span> --zookeeper hadoop102:<span class="number">2181</span> --topic first --consumer<span class="selector-class">.config</span> config/consumer.properties</span><br><span class="line">③ 在hadoop104上启动生产者</span><br><span class="line">[atguigu@hadoop104 kafka]$ bin/kafka-console-producer<span class="selector-class">.sh</span> --broker-list hadoop102:<span class="number">9092</span> --topic first</span><br><span class="line">hello world</span><br><span class="line">④ 查看hadoop102和hadoop103的接收者。同一时刻只有一个消费者接收到消息。</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hadoop生态圈(一) ----- Flume的使用</title>
      <link href="/2018/04/23/BigData-Flume/"/>
      <url>/2018/04/23/BigData-Flume/</url>
      <content type="html"><![CDATA[<p><img src="/2018/04/23/BigData-Flume/agent1.jpg" alt="单个Agent采集数据"><br><a id="more"></a></p><h3 id="Flume在集群中扮演的角色"><a href="#Flume在集群中扮演的角色" class="headerlink" title="Flume在集群中扮演的角色"></a>Flume在集群中扮演的角色</h3><h4 id="Flume框架简介"><a href="#Flume框架简介" class="headerlink" title="Flume框架简介"></a>Flume框架简介</h4><p>  ① Flume提供一个分布式的，可靠的，对大数据量的日志进行高效收集、聚集、移动的服务，Flume只能在Unix环境下运行。<br>  ②Flume可以采集文件，socket数据包等各种形式源数据，又可以将采集到的数据输出到HDFS、HBase、hive、kafka等众多外部存储系统中<br>  ③一般的采集需求，通过对flume的简单配置即可实现<br>  ④Flume针对特殊场景也具备良好的自定义扩展能力，因此，flume可以适用于大部分的日常数据采集场景</p><h4 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h4><p>  1、Flume分布式系统中最核心的角色是agent，Flume采集系统就是由一个个agent所连接起来形成<br>  2、每一个agent相当于一个数据传递员，内部有三个组件:<br>    a) Source:采集源，用于跟数据源对接，以获取数据<br>    b) Sink:下沉地，采集数据的传送目的，用于往下一级agent传递数据或者往最终存储系统传递数据<br>    c) Channel:angent内部的数据传输通道，用于从source将数据传递到sink<br>    <strong>Source 到 Channel 到 Sink之间传递数据的形式是Event事件；Event事件是一个数据流单元。</strong></p><ul><li><p>简单结构<br><strong>单个Agent采集数据</strong><br><img src="/2018/04/23/BigData-Flume/agent1.jpg" alt="单个Agent采集数据"></p></li><li><p>复杂结构<br><strong>多个Agent采集数据</strong><br><img src="/2018/04/23/BigData-Flume/agent2.png" alt="多个Agent采集数据"></p></li></ul><h4 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h4><ul><li>Source<br>  用于采集数据，Source是生产数据流的地方，同时Source会将产生的数据流传输到Channel，这个有点类似于Java IO部分的Channel</li><li>Channel<br>  用于桥接Sources和Sinks，类似于一个队列</li><li>Sink<br>  从Channel收集数据，将数据写到目标源(可以是下一个Source，也可以是HDFS或者HBase)</li></ul><h4 id="传输单元"><a href="#传输单元" class="headerlink" title="传输单元"></a>传输单元</h4><ul><li>Event<br>  Flume数据传输的基本单元，以事件的形式将数据从源头送至目的地</li></ul><h4 id="传输过程"><a href="#传输过程" class="headerlink" title="传输过程"></a>传输过程</h4><p>source监控某个文件，文件产生新的数据，拿到该数据后，将数据封装在一个Event中，并put<br>到channel后commit提交，channel队列先出先进，Sink去Channel队列中拉取数据，然后写入<br>到HDFS或者HBase中。</p><h3 id="安装配置Flume"><a href="#安装配置Flume" class="headerlink" title="安装配置Flume"></a>安装配置Flume</h3><p>  flume-env.sh<br>  配置java的环境变量<br>  进入Flume的目录，修改conf下的flume-env.sh，在里面配置JAVA_HOME</p><h3 id="Flume帮助命令"><a href="#Flume帮助命令" class="headerlink" title="Flume帮助命令"></a>Flume帮助命令</h3><p>  $bin/flume-ng</p><h3 id="案例讲解"><a href="#案例讲解" class="headerlink" title="案例讲解"></a>案例讲解</h3><h4 id="案例一-Flume监听端口，输出端口数据"><a href="#案例一-Flume监听端口，输出端口数据" class="headerlink" title="案例一:Flume监听端口，输出端口数据"></a>案例一:Flume监听端口，输出端口数据</h4><p>  ① 创建Flume Agent配置文件flume-telnet.修改conf<br>  ② cp -a fllume-conf.properties.template flume-telnet.conf<br>  ③ 进入文件，写入如下内容<br>    <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"># Name the components on this agent（起名）</span></span><br><span class="line"><span class="built_in">a1</span>.sources = r1</span><br><span class="line"><span class="built_in">a1</span>.sinks = <span class="built_in">k1</span></span><br><span class="line"><span class="built_in">a1</span>.channels = c1</span><br><span class="line"></span><br><span class="line"><span class="comment"># Describe/configure the source（监听端口的方式）</span></span><br><span class="line"><span class="built_in">a1</span>.sources.r1.type = netcat（源数据的数据类型）</span><br><span class="line"><span class="built_in">a1</span>.sources.r1.<span class="keyword">bind </span>= localhost</span><br><span class="line"><span class="built_in">a1</span>.sources.r1.port = <span class="number">44444</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Describe the sink</span></span><br><span class="line"><span class="built_in">a1</span>.sinks.k1.type = logger</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use a channel which buffers events in memory</span></span><br><span class="line"><span class="built_in">a1</span>.channels.c1.type = memory</span><br><span class="line"><span class="built_in">a1</span>.channels.c1.capacity = <span class="number">1000</span></span><br><span class="line"><span class="built_in">a1</span>.channels.c1.transactionCapacity = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Bind the source and sink to the channel</span></span><br><span class="line"><span class="built_in">a1</span>.sources.r1.channels = c1</span><br><span class="line"><span class="built_in">a1</span>.sinks.k1.channel = c1</span><br></pre></td></tr></table></figure></p><p>  a1是指agent缩写<br>  ④ 安装telnet工具(没有反应正常)<br>    $ sudo rpm -ivh telnet-server-0.17-59.el7.x86_64.rpm<br>    $ sudo rpm -ivh telnet-0.17-59.el7.x86_64.rpm</p><p>  ⑤首先判断44444端口是否被占用<br>    $ netstat -an | grep 44444</p><p>  ⑥先开启flume先听端口(flume家目录执行)<br>    $ bin/flume-ng agent –conf conf/ –name a1 –conf-file conf/flume-telnet.conf -Dflume.root.logger==INFO,console</p><p>  ⑦使用telnet工具向本机的44444端口发送内容(新开一个窗口执行，不需非要家目录，本窗口输入信息。另外窗口可以监听到）<br>    $ telnet localhost 44444</p><h4 id="案例二-监听上传Hive日志文件到HDFS"><a href="#案例二-监听上传Hive日志文件到HDFS" class="headerlink" title="案例二:监听上传Hive日志文件到HDFS"></a>案例二:监听上传Hive日志文件到HDFS</h4><p>  ① 拷贝Hadoop相关jar到Flume的lib目录下<br>    share/hadoop/common/lib/hadoop-auth-2.5.0-cdh5.3.6.jar<br>    share/hadoop/common/lib/commons-configuration-1.6.jar<br>    share/hadoop/mapreduce1/lib/hadoop-hdfs-2.5.0-cdh5.3.6.jar<br>    share/hadoop/common/hadoop-common-2.5.0-cdh5.3.6.jar<br>    $cp share/hadoop/common/lib/hadoop-auth-2.5.0-cdh5.3.6.jar  /opt/modules/apache-flume-1.5.0-cdh5.3.6-bin/lib<br>  ② 创建flume-hdfs.conf文件<br>    <figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment"># Name the components on this agent</span></span><br><span class="line">a2.<span class="attr">sources</span> = r2</span><br><span class="line">a2.<span class="attr">sinks</span> = k2</span><br><span class="line">a2.<span class="attr">channels</span> = c2</span><br><span class="line"></span><br><span class="line"><span class="comment"># Describe/configure the source</span></span><br><span class="line">a2.sources.r2.<span class="attr">type</span> = exec</span><br><span class="line">a2.sources.r2.<span class="attr">command</span> = tail -f /opt/modules/cdh/hive-<span class="number">0.13</span>.<span class="number">1</span>-cdh5.<span class="number">3.6</span>/logs/hive.log</span><br><span class="line">a2.sources.r2.<span class="attr">shell</span> = /bin/bash -c</span><br><span class="line"></span><br><span class="line"><span class="comment"># Describe the sink</span></span><br><span class="line">a2.sinks.k2.<span class="attr">type</span> = hdfs</span><br><span class="line">a2.sinks.k2.hdfs.<span class="attr">path</span> = hdfs://<span class="number">192.168</span>.<span class="number">122.20</span>:<span class="number">8020</span>/flume/%Y%m%d/%H</span><br><span class="line"><span class="comment">#上传文件的前缀</span></span><br><span class="line">a2.sinks.k2.hdfs.<span class="attr">filePrefix</span> = events-hive-</span><br><span class="line"><span class="comment">#是否按照时间滚动文件夹</span></span><br><span class="line">a2.sinks.k2.hdfs.<span class="attr">round</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment">#多少时间单位创建一个新的文件夹</span></span><br><span class="line">a2.sinks.k2.hdfs.<span class="attr">roundValue</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">#重新定义时间单位</span></span><br><span class="line">a2.sinks.k2.hdfs.<span class="attr">roundUnit</span> = hour</span><br><span class="line"><span class="comment">#是否使用本地时间戳</span></span><br><span class="line">a2.sinks.k2.hdfs.<span class="attr">useLocalTimeStamp</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment">#积攒多少个Event才flush到HDFS一次</span></span><br><span class="line">a2.sinks.k2.hdfs.<span class="attr">batchSize</span> = <span class="number">1000</span></span><br><span class="line"><span class="comment">#设置文件类型，可支持压缩</span></span><br><span class="line">a2.sinks.k2.hdfs.<span class="attr">fileType</span> = DataStream</span><br><span class="line"><span class="comment">#多久生成一个新的文件</span></span><br><span class="line">a2.sinks.k2.hdfs.<span class="attr">rollInterval</span> = <span class="number">600</span></span><br><span class="line"><span class="comment">#设置每个文件的滚动大小</span></span><br><span class="line">a2.sinks.k2.hdfs.<span class="attr">rollSize</span> = <span class="number">134217700</span></span><br><span class="line"><span class="comment">#文件的滚动与Event数量无关</span></span><br><span class="line">a2.sinks.k2.hdfs.<span class="attr">rollCount</span> = <span class="number">0</span></span><br><span class="line"><span class="comment">#最小冗余数</span></span><br><span class="line">a2.sinks.k2.hdfs.<span class="attr">minBlockReplicas</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use a channel which buffers events in memory</span></span><br><span class="line">a2.channels.c2.<span class="attr">type</span> = memory</span><br><span class="line">a2.channels.c2.<span class="attr">capacity</span> = <span class="number">1000</span></span><br><span class="line">a2.channels.c2.<span class="attr">transactionCapacity</span> = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Bind the source and sink to the channel</span></span><br><span class="line">a2.sources.r2.<span class="attr">channels</span> = c2</span><br><span class="line">a2.sinks.k2.<span class="attr">channel</span> = c2</span><br></pre></td></tr></table></figure></p><h4 id="案例三-Flume监听整个目录"><a href="#案例三-Flume监听整个目录" class="headerlink" title="案例三:Flume监听整个目录"></a>案例三:Flume监听整个目录</h4><p>① 创建配置文件flume-dir.conf<br>$ cp -a flume-hdfs.conf flume-dir.conf<br>② 文件内容<br>      <figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">  a3.<span class="attr">sources</span> = r3</span><br><span class="line">a3.<span class="attr">sinks</span> = k3</span><br><span class="line">a3.<span class="attr">channels</span> = c3</span><br><span class="line"></span><br><span class="line"><span class="comment"># Describe/configure the source</span></span><br><span class="line">a3.sources.r3.<span class="attr">type</span> = spooldir</span><br><span class="line">a3.sources.r3.<span class="attr">spoolDir</span> = /opt/modules/cdh/apache-flume-<span class="number">1.5</span>.<span class="number">0</span>-cdh5.<span class="number">3.6</span>-bin/upload</span><br><span class="line">a3.sources.r3.<span class="attr">fileHeader</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment">#忽略所有以.tmp结尾的文件，不上传</span></span><br><span class="line">a3.sources.r3.<span class="attr">ignorePattern</span> = ([^ ]*\.tmp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Describe the sink</span></span><br><span class="line">a3.sinks.k3.<span class="attr">type</span> = hdfs</span><br><span class="line">a3.sinks.k3.hdfs.<span class="attr">path</span> = hdfs://<span class="number">192.168</span>.<span class="number">122.20</span>:<span class="number">8020</span>/flume/upload/%Y%m%d/%H</span><br><span class="line"><span class="comment">#上传文件的前缀</span></span><br><span class="line">a3.sinks.k3.hdfs.<span class="attr">filePrefix</span> = upload-</span><br><span class="line"><span class="comment">#是否按照时间滚动文件夹</span></span><br><span class="line">a3.sinks.k3.hdfs.<span class="attr">round</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment">#多少时间单位创建一个新的文件夹</span></span><br><span class="line">a3.sinks.k3.hdfs.<span class="attr">roundValue</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">#重新定义时间单位</span></span><br><span class="line">a3.sinks.k3.hdfs.<span class="attr">roundUnit</span> = hour</span><br><span class="line"><span class="comment">#是否使用本地时间戳</span></span><br><span class="line">a3.sinks.k3.hdfs.<span class="attr">useLocalTimeStamp</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment">#积攒多少个Event才flush到HDFS一次</span></span><br><span class="line">a3.sinks.k3.hdfs.<span class="attr">batchSize</span> = <span class="number">1000</span></span><br><span class="line"><span class="comment">#设置文件类型，可支持压缩</span></span><br><span class="line">a3.sinks.k3.hdfs.<span class="attr">fileType</span> = DataStream</span><br><span class="line"><span class="comment">#多久生成一个新的文件</span></span><br><span class="line">a3.sinks.k3.hdfs.<span class="attr">rollInterval</span> = <span class="number">600</span></span><br><span class="line"><span class="comment">#设置每个文件的滚动大小</span></span><br><span class="line">a3.sinks.k3.hdfs.<span class="attr">rollSize</span> = <span class="number">134217700</span></span><br><span class="line"><span class="comment">#文件的滚动与Event数量无关</span></span><br><span class="line">a3.sinks.k3.hdfs.<span class="attr">rollCount</span> = <span class="number">0</span></span><br><span class="line"><span class="comment">#最小冗余数</span></span><br><span class="line">a3.sinks.k3.hdfs.<span class="attr">minBlockReplicas</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use a channel which buffers events in memory</span></span><br><span class="line">a3.channels.c3.<span class="attr">type</span> = memory</span><br><span class="line">a3.channels.c3.<span class="attr">capacity</span> = <span class="number">1000</span></span><br><span class="line">a3.channels.c3.<span class="attr">transactionCapacity</span> = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Bind the source and sink to the channel</span></span><br><span class="line">a3.sources.r3.<span class="attr">channels</span> = c3</span><br><span class="line">a3.sinks.k3.<span class="attr">channel</span> = c3</span><br></pre></td></tr></table></figure></p><p>③ 执行测试<br>$ bin/flume-ng agent –conf conf/ –name a3 –conf-file conf/flume-dir.conf &amp;</p>]]></content>
      
      <categories>
          
          <category> Flume </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flume </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hadoop生态圈(二) ----- Kafka的使用(一)</title>
      <link href="/2018/04/23/BigData-Kafka/"/>
      <url>/2018/04/23/BigData-Kafka/</url>
      <content type="html"><![CDATA[<p><img src="/2018/04/23/BigData-Kafka/kafka.png" alt="Kafka内部实现原理"><br><a id="more"></a></p><h3 id="Kafka概述"><a href="#Kafka概述" class="headerlink" title="Kafka概述"></a>Kafka概述</h3><hr><h4 id="Kafka是什么"><a href="#Kafka是什么" class="headerlink" title="Kafka是什么"></a>Kafka是什么</h4><p>  在流式计算中，Kafka一般用来缓存数据，Storm通过消费Kafka的数据进行计算。<br>  1）Apache Kafka是一个开源消息系统，由Scala写成。是由Apache软件基金会开发的一个开源消息系统项目。<br>  2）Kafka最初是由LinkedIn开发，并于2011年初开源。2012年10月从Apache Incubator毕业。该项目的目标是为处理实时数据提供一个统一、高通量、低等待的平台。<br>  3）Kafka是一个分布式消息队列:生产者，消费者的功能。Kafka对消息保存时根据Topic进行归类，发送消息者称为Producer，消息接受者称为Consumer，此外kafka集群有多个kafka实例组成，每个实例(server)成为broker。<br>  4）无论是kafka集群，还是producer和consumer都依赖于zookeeper集群保存一些meta信息，来保证系统可用性。</p><h4 id="Kafka内部实现原理"><a href="#Kafka内部实现原理" class="headerlink" title="Kafka内部实现原理"></a>Kafka内部实现原理</h4><p>  <img src="/2018/04/23/BigData-Kafka/kafka.png" alt="Kafka内部实现原理"><br>  （1）点对点模式（一对一，消费者主动拉取数据，消息收到后消息清除）<br>  点对点模型通常是一个基于拉取或者轮询的消息传送模型，这种模型从队列中请求信息，而不是将消息推送到,l客户端。这个模型的特点是发送到队列的消息被一个且只有一个接收者接收处理，即使有多个消息监听者也是如此。<br>  （2）发布/订阅模式（一对多，数据生产后，推送给所有订阅者）<br>  发布订阅模型则是一个基于推送的消息传送模型。发布订阅模型可以有多种不同的订阅者，临时订阅者只在主动监听主题时才接收消息，而持久订阅者则监听主题的所有消息，即使当前订阅者不可用，处于离线状态。</p><h4 id="为什么需要消息队列"><a href="#为什么需要消息队列" class="headerlink" title="为什么需要消息队列"></a>为什么需要消息队列</h4><p>  1）解耦：<br>  　　允许你独立的扩展或修改两边的处理过程，只要确保它们遵守同样的接口约束。<br>  2）冗余：<br>  消息队列把数据进行持久化直到它们已经被完全处理，通过这一方式规避了数据丢失风险。许多消息队列所采用的”插入-获取-删除”范式中，在把一个消息从队列中删除之前，需要你的处理系统明确的指出该消息已经被处理完毕，从而确保你的数据被安全的保存直到你使用完毕。<br>  3）扩展性：<br>  因为消息队列解耦了你的处理过程，所以增大消息入队和处理的频率是很容易的，只要另外增加处理过程即可。<br>  4）灵活性 &amp; 峰值处理能力：<br>  在访问量剧增的情况下，应用仍然需要继续发挥作用，但是这样的突发流量并不常见。如果为以能处理这类峰值访问为标准来投入资源随时待命无疑是巨大的浪费。使用消息队列能够使关键组件顶住突发的访问压力，而不会因为突发的超负荷的请求而完全崩溃。<br>  5）可恢复性：<br>  系统的一部分组件失效时，不会影响到整个系统。消息队列降低了进程间的耦合度，所以即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。<br>  6）顺序保证：<br>  在大多使用场景下，数据处理的顺序都很重要。大部分消息队列本来就是排序的，并且能保证数据会按照特定的顺序来处理。（Kafka保证一个Partition内的消息的有序性）<br>  7）缓冲：<br>  有助于控制和优化数据流经过系统的速度，解决生产消息和消费消息的处理速度不一致的情况。<br>  8）异步通信：<br>  很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</p><h4 id="Kafka架构"><a href="#Kafka架构" class="headerlink" title="Kafka架构"></a>Kafka架构</h4><p>  <img src="/2018/04/23/BigData-Kafka/kafka1.png" alt="Kafka架构"></p><p>  1）Producer ：消息生产者，就是向kafka broker发消息的客户端。<br>  2）Consumer ：消息消费者，向kafka broker取消息的客户端<br>  3）Topic ：可以理解为一个队列。<br>  4） Consumer Group （CG）：这是kafka用来实现一个topic消息的广播（发给所有的consumer）和单播（发给任意一个consumer）的手段。一个topic可以有多个CG。topic的消息会复制（不是真的复制，是概念上的）到所有的CG，但每个partion只会把消息发给该CG中的一个consumer。如果需要实现广播，只要每个consumer有一个独立的CG就可以了。要实现单播只要所有的consumer在同一个CG。用CG还可以将consumer进行自由的分组而不需要多次发送消息到不同的topic。<br>  5）Broker ：一台kafka服务器就是一个broker。一个集群由多个broker组成。一个broker可以容纳多个topic。<br>  6）Partition：为了实现扩展性，一个非常大的topic可以分布到多个broker（即服务器）上，一个topic可以分为多个partition，每个partition是一个有序的队列。partition中的每条消息都会被分配一个有序的id（offset）。kafka只保证按一个partition中的顺序将消息发给consumer，不保证一个topic的整体（多个partition间）的顺序。<br>  7）Offset：kafka的存储文件都是按照offset.kafka来命名，用offset做名字的好处是方便查找。例如你想找位于2049的位置，只要找到2048.kafka的文件即可。当然the first offset就是00000000000.kafka</p><h4 id="kafka命令行操作"><a href="#kafka命令行操作" class="headerlink" title="kafka命令行操作"></a>kafka命令行操作</h4><p>  1) 查看当前服务器中的所有topic</p><blockquote><p><strong>$</strong> bin/kafka-topics.sh --list --zookeeper hadoop102:2181</p></blockquote><p>  2) 创建topic</p><blockquote><p><strong>$</strong> bin/kafka-topics.sh --create --zookeeper hadoop102:2181 –replication-factor 3 –partitions 1 –topic first<br>    选项说明:<br>    --topic 定义topic名<br>    --replication-factor 定义副本数<br>    --partitions 定义分区数</p></blockquote><p>  3)  删除topic</p><blockquote><p><strong>$</strong> bin/kafka-topics.sh --delete --zookeeper hadoop102:2181 --topic first<br>  需要server.properties中设置delete.topic.enable=true否则只会标记删除或者直接重启</p></blockquote><p>  4) 发送消息</p><blockquote><p><strong>$</strong> bin/kafka-console-producer.sh --broker-list hadoop102:9092 --topic first<br>    $&gt;hello world<br>    $&gt;kongluo kongluo</p></blockquote><p>  5) 消费消息</p><blockquote><p><strong>$</strong> bin/kafka-console-consumer.sh --zookeeper hadoop102:2181 --from-beginning --topic first</p></blockquote><p>  6) 查看某个Topic的详情</p><blockquote><p><strong>$</strong> bin/kafka-topics.sh --topic first --describe --zookeeper hadoop102:2181</p></blockquote>]]></content>
      
      <categories>
          
          <category> Kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>myFirstPageForTag</title>
      <link href="/2018/04/21/myFirstPageForTag/"/>
      <url>/2018/04/21/myFirstPageForTag/</url>
      <content type="html"><![CDATA[<a id="more"></a>]]></content>
      
      
        <tags>
            
            <tag> Scala </tag>
            
            <tag> Spark </tag>
            
            <tag> java </tag>
            
            <tag> HDFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2018/04/20/first-one/"/>
      <url>/2018/04/20/first-one/</url>
      <content type="html"><![CDATA[<p><img src="/2018/04/20/first-one/bye.jpg" alt="Bye"><br><a id="more"></a></p><p><i class="icon-pencil"></i> <strong>个人感想</strong></p><h4 id="第一点"><a href="#第一点" class="headerlink" title="  第一点"></a><i class="icon-file"></i>  <strong>第一点</strong></h4><p>我很庆幸在2016毕业的那一年去了北京，我更庆幸在2018年离开了北京。走出校园后，经过这两年的社会的洗礼，我已然能轻易的分清楚所有的善与恶，好与坏，真与假。</p><h4 id="第二点"><a href="#第二点" class="headerlink" title="  第二点"></a><i class="icon-file"></i>  <strong>第二点</strong></h4><p>这辈子很短，<strong>真诚</strong>，比什么都重要。</p><h4 id="第三点"><a href="#第三点" class="headerlink" title="  第三点"></a><i class="icon-file"></i>  <strong>第三点</strong></h4><p><strong>实力</strong> 才是硬道理，永远不要做语言的巨人。</p><h4 id="第四点"><a href="#第四点" class="headerlink" title="  第四点"></a><i class="icon-file"></i>  <strong>第四点</strong></h4><p>不要给那些让你觉得恶心的人任何有机可乘的机会，因为时间很宝贵，要把时间给那些带给你温暖的人。</p>]]></content>
      
      <categories>
          
          <category> thoughts </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>article title</title>
      <link href="/2018/04/20/article-title/"/>
      <url>/2018/04/20/article-title/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
  
  
</search>
