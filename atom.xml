<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>空落单行雨</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-18T01:06:13.535Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Kongluo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>随笔(二)</title>
    <link href="http://yoursite.com/2018/05/18/jottings-2/"/>
    <id>http://yoursite.com/2018/05/18/jottings-2/</id>
    <published>2018-05-18T00:54:17.000Z</published>
    <updated>2018-05-18T01:06:13.535Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/05/18/jottings-2/jottings2.jpg" alt="jottings"><br><a id="more"></a></p><p>太好了，太好了。我也算卸下包袱，这下总算可以回去了。<br>你这人还真是的，<br>又冒失，<br>又愚蠢，<br>又厌学，<br>有懦弱，<br>又懒惰，<br>又迟钝，<br>运动又不行，<br>又胆小，<br>又糊涂，<br>又不可靠….<br>又讨厌麻烦….<br>又没出息….<br>记性又差….<br>是个老好人….<br>还总是得意忘形….<br>又爱撒娇….</p><p>咦？</p><p>该怎么办呢？还真是伤脑筋啊！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/05/18/jottings-2/jottings2.jpg&quot; alt=&quot;jottings&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="thoughts" scheme="http://yoursite.com/categories/thoughts/"/>
    
    
      <category term="jottings" scheme="http://yoursite.com/tags/jottings/"/>
    
  </entry>
  
  <entry>
    <title>Python科学计算库 ----- Numpy</title>
    <link href="http://yoursite.com/2018/05/17/Python-Numpy/"/>
    <id>http://yoursite.com/2018/05/17/Python-Numpy/</id>
    <published>2018-05-17T08:57:43.000Z</published>
    <updated>2018-05-17T10:02:58.581Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Numpy基础结构"><a href="#Numpy基础结构" class="headerlink" title="Numpy基础结构"></a>Numpy基础结构</h3><p>按照”,”分隔，以str形式读取txt文件<br>type():数据类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import numpy</span><br><span class="line">world_alcohol = numpy.genfromtxt(&quot;world_alcohol.txt&quot;, delimiter=&quot;,&quot;,dtype=str)</span><br><span class="line">print(type(world_alcohol))</span><br><span class="line">print(world_alcohol)</span><br><span class="line">print(help(numpy.genfromtxt))</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>读取array数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector = numpy.array([5,10,15,20])</span><br><span class="line"></span><br><span class="line">matrix = numpy.array([[5,10,15],[20,25,30],[35,40,45]])</span><br><span class="line">print vector</span><br><span class="line">print matrix</span><br></pre></td></tr></table></figure></p><p>shape显示数组的维度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector = numpy.array([1,2,3,4])</span><br><span class="line">print(vector.shape)</span><br><span class="line"></span><br><span class="line">matrix = numpy.array([[5,10,15],[20,25,30]])</span><br><span class="line">print(matrix.shape)</span><br></pre></td></tr></table></figure></p><p>dtype:数组元素类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import numpy</span><br><span class="line">numbers = numpy.array([1,2,3,4])</span><br><span class="line"></span><br><span class="line">print(numbers)</span><br><span class="line">numbers.dtype</span><br></pre></td></tr></table></figure></p><p>skip_header:略过多少行从 n+1行开始读取数据<br>[m,n]\:第m+1行、第n+1列数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">world_alcohol = numpy.genfromtxt(&quot;world_alcohol.txt&quot;,delimiter=&quot;,&quot;,dtype=str,skip_header=1)</span><br><span class="line">print(world_alcohol)</span><br><span class="line"># print(world_alcohol.shape)</span><br><span class="line"></span><br><span class="line">uruguay_other_1986 = world_alcohol[1,4]</span><br><span class="line">third_country = world_alcohol[2,2]</span><br><span class="line">print(uruguay_other_1986)</span><br><span class="line">print(third_country)</span><br></pre></td></tr></table></figure></p><p>读取数组1~3列的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector = numpy.array([5,10,15,20])</span><br><span class="line">print(vector[0:3])</span><br></pre></td></tr></table></figure></p><p>[:,n] \: 读取所有行第n+1列的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">matrix = numpy.array([</span><br><span class="line">    [5,10,15],</span><br><span class="line">    [20,25,30],</span><br><span class="line">    [35,40,45]</span><br><span class="line">])</span><br><span class="line">print(matrix[:,1])</span><br></pre></td></tr></table></figure></p><p>[:,0:2] \: 读取所有行第1~2列的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">matrix = numpy.array([</span><br><span class="line">    [5,10,15],</span><br><span class="line">    [20,25,30],</span><br><span class="line">    [35,40,45]</span><br><span class="line">])</span><br><span class="line">print(matrix[:,0:2])</span><br></pre></td></tr></table></figure></p><p>[1:3,0:2] \: 读取数组的第2~3行，第1~2列数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">matrix = numpy.array([</span><br><span class="line">    [5,10,15],</span><br><span class="line">    [20,25,30],</span><br><span class="line">    [35,40,45]</span><br><span class="line">])</span><br><span class="line">print(matrix[1:3,0:2])</span><br></pre></td></tr></table></figure></p><h3 id="Numpy矩阵基础"><a href="#Numpy矩阵基础" class="headerlink" title="Numpy矩阵基础"></a>Numpy矩阵基础</h3><p>== : 返回boolean型 [False,True,False,False]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector = numpy.array([5,10,15,20])</span><br><span class="line">print(vector==10)</span><br><span class="line"></span><br><span class="line">matrix = numpy.array([</span><br><span class="line">    [5,10,15],</span><br><span class="line">    [20,25,30],</span><br><span class="line">    [35,40,45]</span><br><span class="line">])</span><br><span class="line">print(matrix == 25)</span><br></pre></td></tr></table></figure></p><p>根据==返回的boolean数组，可以通过boolean数组，从原数据中获取数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector = numpy.array([5,10,15,20])</span><br><span class="line">equal_to_ten = (vector == 10)</span><br><span class="line"></span><br><span class="line">print(equal_to_ten)</span><br><span class="line">print(vector[equal_to_ten])</span><br></pre></td></tr></table></figure></p><p>根据matrix[:,1]==25的条件获取所在列的boolean数组，可以根据boolean数组找到原数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">matrix = numpy.array([</span><br><span class="line">    [5,10,15],</span><br><span class="line">    [20,25,30],</span><br><span class="line">    [35,40,45]</span><br><span class="line">])</span><br><span class="line">second_column_25 = (matrix[:,1]==25)</span><br><span class="line">print(second_column_25)</span><br><span class="line">print(matrix[second_column_25,:])</span><br></pre></td></tr></table></figure></p><p>条件与 : &amp;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import numpy</span><br><span class="line">vector = numpy.array([5,10,15,20])</span><br><span class="line">equal_to_ten_and_five = (vector==10) &amp; (vector==5)</span><br><span class="line">print(equal_to_ten_and_five)</span><br></pre></td></tr></table></figure></p><p>条件或 ： |</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector = numpy.array([5,10,15,20])</span><br><span class="line">equal_to_ten_or_five = (vector == 10) | (vector == 5)</span><br><span class="line">print(equal_to_ten_or_five)</span><br></pre></td></tr></table></figure><p>根据[:,1]==25的boolean数据条件更改原数组数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">matrix = numpy.array([</span><br><span class="line">    [5,10,15],</span><br><span class="line">    [20,25,30],</span><br><span class="line">    [35,40,45]</span><br><span class="line">])</span><br><span class="line">second_column_25 = matrix[:,1] == 25</span><br><span class="line">print(second_column_25)</span><br><span class="line">matrix[second_column_25,1] = 10</span><br><span class="line">print(matrix)</span><br></pre></td></tr></table></figure></p><p>astype:类型转换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector = numpy.array([&quot;1&quot;,&quot;2&quot;,&quot;3&quot;])</span><br><span class="line">print(vector.dtype)</span><br><span class="line">print(vector)</span><br><span class="line">vector = vector.astype(float)</span><br><span class="line">print(vector.dtype)</span><br><span class="line">print(vector)</span><br></pre></td></tr></table></figure></p><h3 id="Numpy常用函数"><a href="#Numpy常用函数" class="headerlink" title="Numpy常用函数"></a>Numpy常用函数</h3><p>min:数组最小值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector = numpy.array([5,10,15,20])</span><br><span class="line">print(vector.min())</span><br></pre></td></tr></table></figure></p><p>axis=1 按行求和<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">matrix = numpy.array([</span><br><span class="line">    [5,10,15],</span><br><span class="line">    [20,25,30],</span><br><span class="line">    [35,40,45]</span><br><span class="line">])</span><br><span class="line">print(matrix.sum(axis=1))</span><br></pre></td></tr></table></figure></p><p>axis=0 按列求和<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">matrix = numpy.array([</span><br><span class="line">    [5,10,15],</span><br><span class="line">    [20,25,30],</span><br><span class="line">    [35,40,45]</span><br><span class="line">])</span><br><span class="line">print(matrix.sum(axis=0))</span><br></pre></td></tr></table></figure></p><p>arange(n): 0~n-1的值<br>reshape : 更改数组维度<br>ndim : 数组维度(比如二维数组、三维数组等)<br>dtype : 数据类型<br>size : 大小<br>zeros((m,n)) : 二维值都为0的数组<br>ones((a,b,c)):三维值都为1的数组</p><p>arange(a,b,c) :按照c跳值<br>np.random.random : 随机值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">print(np.arange(15))</span><br><span class="line">a = np.arange(15).reshape(3,5)</span><br><span class="line">print(a)</span><br><span class="line">print(a.shape)</span><br><span class="line"></span><br><span class="line">print(a.ndim) #维度</span><br><span class="line"></span><br><span class="line">print(a.dtype.name)</span><br><span class="line"></span><br><span class="line">print(a.size)</span><br><span class="line"></span><br><span class="line">print(np.zeros((3,4)))</span><br><span class="line"></span><br><span class="line">print(np.ones((2,3,4),dtype=np.int32))</span><br><span class="line"></span><br><span class="line">print(np.arange(10,30,5))</span><br><span class="line"></span><br><span class="line">print(np.arange(0,2,0.3))</span><br><span class="line"></span><br><span class="line">print(np.arange(12).reshape(4,3))</span><br><span class="line"></span><br><span class="line">print(np.random.random((2,3)))</span><br></pre></td></tr></table></figure></p><h3 id="矩阵常用操作"><a href="#矩阵常用操作" class="headerlink" title="矩阵常用操作"></a>矩阵常用操作</h3><p>**2 : 平方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([20,30,40,50])</span><br><span class="line">b = np.arange(4)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line">c= a-b</span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line">b**2</span><br><span class="line">print(b**2)</span><br><span class="line">print(a&lt;35)</span><br></pre></td></tr></table></figure></p><p>.dot : 矩阵相乘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">A = np.array([[1,1],</span><br><span class="line">              [0,1]])</span><br><span class="line"></span><br><span class="line">B = np.array([[2,0],</span><br><span class="line">              [3,4]])</span><br><span class="line">print(A)</span><br><span class="line">print(&quot;--------&quot;)</span><br><span class="line">print(B)</span><br><span class="line">print(&quot;--------&quot;)</span><br><span class="line">print(A* B)</span><br><span class="line">print(&quot;--------&quot;)</span><br><span class="line">print(A.dot(B))</span><br><span class="line">print(&quot;--------&quot;)</span><br><span class="line">print(np.dot(A,B))</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">B = np.arange(3)</span><br><span class="line"></span><br><span class="line">print(B)</span><br><span class="line">print(np.exp(B))  # e的多少次幂</span><br><span class="line">print(np.sqrt(B))  # 开根号</span><br><span class="line"></span><br><span class="line">print(&quot;-----------------------&quot;)</span><br><span class="line">a = np.floor(10*np.random.random((3,4)))</span><br><span class="line">print(a)</span><br><span class="line">print(&quot;-----------------------&quot;)</span><br><span class="line"></span><br><span class="line">print(a.ravel())   #把矩阵拉成向量</span><br><span class="line">print(&quot;-----------------------&quot;)</span><br><span class="line"></span><br><span class="line">a.shape = (6,2)</span><br><span class="line">print(a)</span><br><span class="line">print(&quot;-----------------&quot;)</span><br><span class="line">print(a.T)</span><br><span class="line"></span><br><span class="line">print(a.reshape(4,-1))</span><br></pre></td></tr></table></figure><p>hstack : 矩阵拼接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;---&quot;)</span><br><span class="line">a = np.floor(10*np.random.random((2,3)))</span><br><span class="line">b = np.floor(10*np.random.random((2,2)))</span><br><span class="line">print(a)</span><br><span class="line">print(&quot;---&quot;)</span><br><span class="line">print(b)</span><br><span class="line">print(&quot;---&quot;)</span><br><span class="line">print(np.hstack((a,b)))   #横着对矩阵进行拼接</span><br><span class="line"></span><br><span class="line">a = np.floor(10*np.random.random((2,2)))</span><br><span class="line">b = np.floor(10*np.random.random((2,2)))</span><br><span class="line">print(a)</span><br><span class="line">print(&quot;----&quot;)</span><br><span class="line">print(b)</span><br><span class="line">print(&quot;----&quot;)</span><br><span class="line">print(np.vstack((a,b)))     #竖着对矩阵进行拼接</span><br></pre></td></tr></table></figure></p><p>hsplit:矩阵切割<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;=========&quot;)</span><br><span class="line">a = np.floor(10*np.random.random((2,12)))</span><br><span class="line">print(a)</span><br><span class="line">print(&quot;-----&quot;)</span><br><span class="line">print(np.hsplit(a,3))</span><br><span class="line">print(&quot;-----&quot;)</span><br><span class="line">print(np.hsplit(a,(3,4)))</span><br><span class="line">a = np.floor(10*np.random.random((12,2)))</span><br><span class="line">print(&quot;-----&quot;)</span><br><span class="line">print(a)</span><br><span class="line">print(np.vsplit(a,3))</span><br></pre></td></tr></table></figure></p><p>矩阵的arg找index、排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">data = np.sin(np.arange(20)).reshape(5,4)</span><br><span class="line">print(data)</span><br><span class="line">ind = data.argmax(axis=0)                  #axis = 0 按照列，找每一列的最大值所在的index</span><br><span class="line">print(ind)</span><br><span class="line">data_max = data[ind,range(data.shape[1])]</span><br><span class="line">print(data_max)</span><br><span class="line"></span><br><span class="line">a = np.arange(0,40,10)</span><br><span class="line">print(a)</span><br><span class="line">b = np.tile(a,(3,5))     #对矩阵进行扩展</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = np.array(\[[4,3,5\],\[1,2,1\]])</span><br><span class="line">print(a)</span><br><span class="line">print(&quot;---------&quot;)</span><br><span class="line">b = np.sort(a,axis=1)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">a.sort(axis=1)</span><br><span class="line">print(&quot;---------&quot;)</span><br><span class="line">print(a)</span><br><span class="line">a = np.array(\[4,3,1,2\])</span><br><span class="line">j = np.argsort(a)          #找的index</span><br><span class="line">print(&quot;---------&quot;)</span><br><span class="line">print(j)</span><br><span class="line">print(&quot;---------&quot;)</span><br><span class="line">print(a[j])</span><br></pre></td></tr></table></figure></p><h3 id="不同复制操作对比"><a href="#不同复制操作对比" class="headerlink" title="不同复制操作对比"></a>不同复制操作对比</h3><p>矩阵中的值的复制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.arange(12)</span><br><span class="line">b = a</span><br><span class="line">print(b is a)</span><br><span class="line">b.shape = (3,4)</span><br><span class="line">print(a.shape)</span><br><span class="line">print(id(a))</span><br><span class="line">print(id(b))</span><br><span class="line"></span><br><span class="line">c = a.view()</span><br><span class="line">print(c is a )</span><br><span class="line">c.shape = 2,6</span><br><span class="line">print(a.shape)</span><br><span class="line">c[0,4]=1234    #指向的位置不相同，但是共用的是一套值</span><br><span class="line">print(a)</span><br><span class="line">print(id(a))</span><br><span class="line">print(id(c))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d = a.copy()</span><br><span class="line">print(d is a)</span><br><span class="line">d[0,0] = 9999</span><br><span class="line">print(d)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Numpy基础结构&quot;&gt;&lt;a href=&quot;#Numpy基础结构&quot; class=&quot;headerlink&quot; title=&quot;Numpy基础结构&quot;&gt;&lt;/a&gt;Numpy基础结构&lt;/h3&gt;&lt;p&gt;按照”,”分隔，以str形式读取txt文件&lt;br&gt;type():数据类型&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;import numpy&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;world_alcohol = numpy.genfromtxt(&amp;quot;world_alcohol.txt&amp;quot;, delimiter=&amp;quot;,&amp;quot;,dtype=str)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(type(world_alcohol))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(world_alcohol)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(help(numpy.genfromtxt))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Spark生态圈之Scala(十四) ----- Scala中的函数式编程之隐式转换</title>
    <link href="http://yoursite.com/2018/05/17/BigData-Scala8/"/>
    <id>http://yoursite.com/2018/05/17/BigData-Scala8/</id>
    <published>2018-05-17T08:29:48.000Z</published>
    <updated>2018-05-17T08:44:23.268Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Scala" scheme="http://yoursite.com/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Spark生态圈之Scala(十三) ----- Scala中的函数式编程之类型参数</title>
    <link href="http://yoursite.com/2018/05/17/BigData-Scala7/"/>
    <id>http://yoursite.com/2018/05/17/BigData-Scala7/</id>
    <published>2018-05-17T08:29:43.000Z</published>
    <updated>2018-05-17T09:01:57.785Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Scala" scheme="http://yoursite.com/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Spark生态圈之Scala(十二) ----- Scala中的函数式编程之模式匹配</title>
    <link href="http://yoursite.com/2018/05/17/BigData-Scala6/"/>
    <id>http://yoursite.com/2018/05/17/BigData-Scala6/</id>
    <published>2018-05-17T08:29:36.000Z</published>
    <updated>2018-05-17T10:02:04.394Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p>scala是没有Java中的switch case语法的，相对应的，Scala提供了更加强大的match case语法，即模式匹配，类代替switch case，match case也被称为模式匹配<br>Scala的match case与Java的switch case最大的不同点在于，Java的switch case仅能匹配变量的值，比如1、2、3等；而Scala的match case可以匹配各种情况，比如变量的类型、集合的元素、有值或无值<br>match case的语法如下 : 变量match{case 值=&gt; 语法}。如果值为下划线，则代表了不满足以上所有情况下的默认情况如何处理。此外，match case中，主要一个case分支满足并处理了，就不会继续判断下一个case分支了。（与Java不同，java的switch case需要用break阻止）<br>match case语法最基本的应用，就是对变量的值进行模式匹配</p><p>案例：成绩评价<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def judgeGrade(grade:String)&#123;</span><br><span class="line"> grade match&#123;</span><br><span class="line">      case &quot;A&quot; =&gt; println(&quot;Excellent&quot;)</span><br><span class="line">      case &quot;B&quot;=&gt; println(&quot;Good&quot;)</span><br><span class="line">      case &quot;C&quot;=&gt; println(&quot;Just so so&quot;)</span><br><span class="line">      case _ =&gt; println(&quot;you need work harder&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="在模式匹配中使用if守卫"><a href="#在模式匹配中使用if守卫" class="headerlink" title="在模式匹配中使用if守卫"></a>在模式匹配中使用if守卫</h3><p>Scala的模式匹配语法，有一个特点在于，可以在case后的条件判断中，不仅仅只是提供一个值，而是可以在值后面再加一个if守卫，进行双重过滤</p><p>案例：成绩评价（升级版）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def judgeGrade(name:String,grade:String)&#123;</span><br><span class="line">  grade match&#123;</span><br><span class="line">    case &quot;A&quot;=&gt;println(name+&quot;,you are excellent&quot;)</span><br><span class="line">    case &quot;B&quot;=&gt;println(name+&quot;,you are good&quot;)</span><br><span class="line">    case &quot;C&quot;=&gt;println(name+&quot;,you are just so so&quot;)</span><br><span class="line">    case \_if name==&quot;leo&quot; =&gt;println(name+&quot;,you are a good boy,come on&quot;)</span><br><span class="line">    case \_ =&gt;println(&quot;you need to work harder&quot;)  </span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="在模式匹配中进行变量赋值"><a href="#在模式匹配中进行变量赋值" class="headerlink" title="在模式匹配中进行变量赋值"></a>在模式匹配中进行变量赋值</h3><p>Scala的模式匹配语法，有一个特点在于，可以将模式匹配的默认情况，下划线，替换为一个变量名，此时模式匹配语法就会将要匹配的值赋值给这个变量，从而可以在后面的处理语句中使用要匹配的值</p><p>为什么有这种语法？？思考一下。因为只要使用用case匹配到的值，是不是我们就知道这个值啦！在这个case的处理语句中，是不是就直接可以使用写程序时就已知的值！<br>但是对于下划线<em>这种情况，所有不满足前面的case的值，都会进行</em>这种默认情况进行处理，此时如果我们在处理语句中需要拿到具体的值进行处理呢？那就需要使用这种在模式匹配中进行变量赋值的语法！！</p><p>案例：成绩评价（升级版）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def juegeGrade(name:String,grade:String)&#123;</span><br><span class="line">  grade match&#123;</span><br><span class="line">    case &quot;A&quot; =&gt; println(name+&quot;,you are excellent&quot;)</span><br><span class="line">    case &quot;B&quot;=&gt; println(name+&quot;, you are good&quot;)</span><br><span class="line">    case &quot;C&quot; =&gt; println(name+&quot;,you are just so so&quot;)</span><br><span class="line">    case \_grade if name == &quot;leo&quot; =&gt; println(name+&quot;,you are a good boy,come on,your grade is&quot;+\_grade)</span><br><span class="line">    case \_grade =&gt; println(&quot;you need to work harder,your grade is &quot;+\_grade)</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="对类型进行模式匹配"><a href="#对类型进行模式匹配" class="headerlink" title="对类型进行模式匹配"></a>对类型进行模式匹配</h3><p>Scala的模式匹配一个强大之处就在于，可以直接匹配类型，而不是值！！！这点是java的switch case绝对做不到的。</p><p> 理论知识：对类型如何进行匹配？其他语法与匹配值其实是一样的，但是匹配类型的话，就是要用“case变量：类型=&gt;代码”这种语法，而不是匹配值的“case值=&gt; 代码”这种语法</p><p>案例：异常处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import java.io._</span><br><span class="line"></span><br><span class="line">def processException(e:Exception)</span><br><span class="line">&#123;</span><br><span class="line">  e match&#123;</span><br><span class="line">    case e1 : lllegalArgumentException =&gt; println(&quot;you have illegal arguments! exception is :&quot;+e1)</span><br><span class="line"></span><br><span class="line">    case e2 : FileNotFoundException =&gt; println(&quot;cannot find the file you need read or write!, exception is :&quot;+e2)</span><br><span class="line"></span><br><span class="line">    case e3 : IOException =&gt; println(&quot;you got an error while you were doing IO operation! exception is:&quot;+e3)</span><br><span class="line"></span><br><span class="line">    case _ : Exception =&gt; println(&quot;cannot know which exception you have!&quot;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">processException(new IllegalArgumentException(&quot;except two arguments,but found one argument.&quot;))</span><br><span class="line"></span><br><span class="line">processException(new FileNotFoundException(&quot;text.txt not found&quot;))</span><br><span class="line"></span><br><span class="line">processException(new IOException(&quot;get data from socket fail.&quot;))</span><br><span class="line"></span><br><span class="line">processException(new ArrayIndexOutOfBoundsException(&quot;array is null&quot;))</span><br></pre></td></tr></table></figure></p><h3 id="对Array和List进行模式匹配"><a href="#对Array和List进行模式匹配" class="headerlink" title="对Array和List进行模式匹配"></a>对Array和List进行模式匹配</h3><p>对Array进行模式匹配，分别可以匹配带有指定元素的数组、带有指定个数元素的数组、以某元素打头的数组<br>对List进行模式匹配，与Array类似，但是需要使用List特有的::操作符</p><p>案例：对朋友打招呼<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def greeting(arr:Array[String])&#123;</span><br><span class="line">  arr match&#123;</span><br><span class="line">    case Array(&quot;Leo&quot;) =&gt; println(&quot;Hi,Leo!&quot;)</span><br><span class="line">    case Array(girl1,girl2,girl3) =&gt; println(&quot;Hi,girls,nice to meet you.&quot;+girl1+&quot;and&quot;+girl2+&quot;and&quot;+girl3)</span><br><span class="line">    case Array(&quot;Leo&quot;,\_*) =&gt; println(&quot;Hi,Leo,please introduce you friends to me&quot;)</span><br><span class="line">    case \_ =&gt; println(&quot;hey,who are you?&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def greeting(list:List[String])&#123;</span><br><span class="line">  list match&#123;</span><br><span class="line">    case &quot;Leo&quot;::Nil =&gt; println(&quot;Hi,Leo!&quot;)</span><br><span class="line">    case girl1::girl2::girl3::Nil =&gt; println(&quot;Hi,girls,nice to meet you.&quot;+girl1+&quot;and&quot;+girl2+&quot;and&quot;+girl3)</span><br><span class="line">    case &quot;Leo&quot;::tail =&gt; println(&quot;Hi,Leo,please introduce your friends to me&quot;)</span><br><span class="line">    case \_=&gt; println(&quot;hey,who are you?&quot;)</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="case-class与模式匹配"><a href="#case-class与模式匹配" class="headerlink" title="case class与模式匹配"></a>case class与模式匹配</h3><p>Scala中提供了一种特殊的类，用case class进行声明，中文也可以称作样例类。case class其实有点类似于Java中的JavaBean的概念。即只定义field，并且由Scala编译时自动提供getter和setter方法，但是没有method</p><p>case class的主构造函数接收的参数通常不需要使用var或val修饰，Scala自动就会使用val修饰（但是如果你自己使用var修饰，那么还是会按照var来）</p><p>Scala自动为case class定义了伴生对象，也就是object，并且定义了apply()方法，该方法接收主构造函数中相同的参数，并返回case class对象</p><p>//案例:学校门禁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line"></span><br><span class="line">case class Teacher(name:String,subject:String) extends Person</span><br><span class="line">case class Studnet(name:String,classroom:String) extends Person</span><br><span class="line"></span><br><span class="line">def judgeIdentify(p:Person)&#123;</span><br><span class="line">  p match&#123;</span><br><span class="line">     case Teacher(name,subject)=&gt; println(&quot;Teacher,name is &quot;+name+&quot;,subject is &quot;+subject)</span><br><span class="line">     case Student(name,classroom)=&gt; println(&quot;Student,name is &quot;+name+&quot;,classroom is&quot;+classroom)</span><br><span class="line">     case \_=&gt; println(&quot;illegal access,please go out of the school!&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">val leo:Person = Student(&quot;leo&quot;,&quot;class1&quot;)</span><br><span class="line">val tom:Person =Teacher(&quot;tom&quot;,&quot;Math&quot;)</span><br><span class="line"></span><br><span class="line">case class Worker(name:String) extends Person</span><br><span class="line"></span><br><span class="line">val jack:Person = Worker(&quot;jack&quot;)</span><br><span class="line"></span><br><span class="line">judgeIdentify(leo)</span><br><span class="line">judgeIdentify(tom)</span><br><span class="line">judgeIdentify(jack)</span><br></pre></td></tr></table></figure></p><h3 id="Option与模式匹配"><a href="#Option与模式匹配" class="headerlink" title="Option与模式匹配"></a>Option与模式匹配</h3><p>Scala有一种特殊的类型，叫做Option。Option有两种值，一种是Some，表示有值，一种是None，表示没有值</p><p>Option通常会用于模式匹配中，用于判断某个变量是有值还是没有值，这比null来的更加简洁明了<br>Option的用法必须掌握，因为Spark源码中大量地使用了Option，比如Some(a),None这种语法，因此必须看得懂Option模式匹配，才能够读懂Spark源码</p><p>//案例：成绩查询<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val grades = Map(&quot;Leo&quot;-&gt;&quot;A&quot;,&quot;Jack&quot;-&gt;&quot;B&quot;,&quot;Jen&quot;-&gt;&quot;C&quot;)</span><br><span class="line"></span><br><span class="line">def getGrade(name:String)&#123;</span><br><span class="line">    val grade = grades.get(name)</span><br><span class="line">    grade match&#123;</span><br><span class="line">      case Some(grade) =&gt; println(&quot;your grade is &quot;+grade)</span><br><span class="line">      case None =&gt; println(&quot;Sorry , your grade information is not in the system&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;模式匹配&quot;&gt;&lt;a href=&quot;#模式匹配&quot; class=&quot;headerlink&quot; title=&quot;模式匹配&quot;&gt;&lt;/a&gt;模式匹配&lt;/h3&gt;&lt;p&gt;scala是没有Java中的switch case语法的，相对应的，Scala提供了更加强大的match case语法，即模式匹配，类代替switch case，match case也被称为模式匹配&lt;br&gt;Scala的match case与Java的switch case最大的不同点在于，Java的switch case仅能匹配变量的值，比如1、2、3等；而Scala的match case可以匹配各种情况，比如变量的类型、集合的元素、有值或无值&lt;br&gt;match case的语法如下 : 变量match{case 值=&amp;gt; 语法}。如果值为下划线，则代表了不满足以上所有情况下的默认情况如何处理。此外，match case中，主要一个case分支满足并处理了，就不会继续判断下一个case分支了。（与Java不同，java的switch case需要用break阻止）&lt;br&gt;match case语法最基本的应用，就是对变量的值进行模式匹配&lt;/p&gt;
&lt;p&gt;案例：成绩评价&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;def judgeGrade(grade:String)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; grade match&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      case &amp;quot;A&amp;quot; =&amp;gt; println(&amp;quot;Excellent&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      case &amp;quot;B&amp;quot;=&amp;gt; println(&amp;quot;Good&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      case &amp;quot;C&amp;quot;=&amp;gt; println(&amp;quot;Just so so&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      case _ =&amp;gt; println(&amp;quot;you need work harder&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Scala" scheme="http://yoursite.com/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Spark生态圈之Scala(十一) ----- Scala中的函数式编程之集合操作</title>
    <link href="http://yoursite.com/2018/05/17/BigData-Scala5-2/"/>
    <id>http://yoursite.com/2018/05/17/BigData-Scala5-2/</id>
    <published>2018-05-17T08:25:19.000Z</published>
    <updated>2018-05-17T08:39:01.202Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Scala的集合体系"><a href="#Scala的集合体系" class="headerlink" title="Scala的集合体系"></a>Scala的集合体系</h3><p>Scala中的集合体系主要包括:Iterable、Seq、Set、Map。其中Iterable是所有集合Trait的根trai。这个结构与Java的集合体系非常相似。<br>Scala中的集合是分成可变和不可变两类集合的，其中可变集合就是说，集合的元素可以动态修改，而不可变集合的元素在初始化之后，就无法修改了。分别对应scala.collection.mutable和scala.collection.immutable两个包<br>Seq下包含了Range、ArrayBuffer、List等子trait。其中Range就代表了一个序列，通常可以使用“1  to 10”这种语法来产生一个Range。ArrayBuffer就类似于Java中的ArrayList<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">range: 1 to 10  1.to(10)   1.until(10)</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List 代表一个不可变的列表<br>List的创建，val list = List(1,2,3,4)<br>List有head和tail，head代表Lit的第一个元素，tail代表第一个元素之后的所有元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.head , list.tail</span><br></pre></td></tr></table></figure><p>List有特殊的::操作符，可以用于将head和tail合并成一个List,0::list</p><p>::这种操作符要清楚，在spark源码中都是有体现的，一定要能够看懂！</p><p>如果一个List只有一个元素，那么它的head就是这个元素，它的tail就是Nil</p><p>案例：用递归函数来给List中每个元素都加上指定前缀，并打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def decorator(l:List[Int],prefix:String)&#123;</span><br><span class="line">  if(l ! = Nil)</span><br><span class="line">  &#123;</span><br><span class="line">     println(prefix+l.head)</span><br><span class="line">     decorator(l.tail,prefix)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList代表一个可变的列表，使用elem可以引用其头部，使用next可以引用其尾部<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val l = scala.collection.LinkedList(1,2,3,4,5);  l.elem;l.next</span><br><span class="line"></span><br><span class="line">//案例：使用while循环将LinkedList中的每个元素都乘以2</span><br><span class="line">val list = scala.collection.mutable.LinkedList(1,2,3,4,5)</span><br><span class="line">var currentList = list</span><br><span class="line">while(currentList !=Nil)</span><br><span class="line">&#123;</span><br><span class="line">  currentList.elem = currentList.elem * 2</span><br><span class="line">  currentList.elem = currentList.elem * 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>案例：使用while循环将LinkedList中，从第一个元素开始，每隔一个元素，乘以2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">val list = scala.collection.mutable.LinkedList(1,2,3,4,5,6,7,8,9,10)</span><br><span class="line">var currentList = list</span><br><span class="line">var first = true</span><br><span class="line">while(currentList !=Nil &amp;&amp; currentList.next!=Nil)</span><br><span class="line">&#123;</span><br><span class="line">  if(first) &#123;currentList.elem = currentList.elem * 2;first = false &#125;</span><br><span class="line">  currentList = currentList.next.next</span><br><span class="line"></span><br><span class="line">  if(currentList != Nil)</span><br><span class="line">  currentList.elem = currentList.elem * 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set代表一个没有重复元素的集合<br>将重复元素加入Set是没有用的，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val s = Set(1,2,3);s+1;s+4</span><br></pre></td></tr></table></figure><p>而且Set是不保证插入顺序的，也就是说，Set中的元素是乱序的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val s = new scala.collection.mutable.HashSet[Int] ; s+=1;s+=2;s+=5</span><br></pre></td></tr></table></figure><p>LinkedHashSet会用一个链表维护插入顺序，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val s = new scala.collection.mutable.LinkedHashSet[Int]()；i+=1;s+=2;s+=5</span><br></pre></td></tr></table></figure><p>SortedSet会自动根据key来进行排序，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val s = scala.collection.mutable.SortedSet(&quot;orange&quot;,&quot;apple&quot;,&quot;banana&quot;)</span><br></pre></td></tr></table></figure><h3 id="集合的函数式编程"><a href="#集合的函数式编程" class="headerlink" title="集合的函数式编程"></a>集合的函数式编程</h3><p>集合的函数式编程非常非常之重要<br>必须完全掌握和理解Scala的高阶函数是什么意思，Scala的集合类的map、flatMap、reduce、reduceLeft、foreach等这些函数，就是高阶函数，因为可以接收其他函数作为参数</p><p>高阶函数的使用，也是Scala与Java最大的一点不同！！！因为Java里面是没有函数式编程的，也肯定没有高阶函数，也肯定无法直接将函数传入一个方法，或者让一个方法返回一个函数<br>对Scala高阶函数的理解、掌握和使用，可以大大增强你的技术，而且也是Scala最有诱惑力、最有优势的一个功能！！！</p><p>此外，在Spark源码中，有大量的函数式编程，以及基于集合的高阶函数的使用！！！所以必须掌握，才能看懂spark源码</p><p>map案例实战：为List中每个元素都添加一个前缀<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List(&quot;Leo&quot;,&quot;Jen&quot;,&quot;Peter&quot;,&quot;Jack&quot;).map(&quot;name  is &quot;+ \_)</span><br></pre></td></tr></table></figure></p><p>flatMap案例实战：将List中的多行句子拆分成单词<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List(&quot;Hello World&quot;,&quot;You Me&quot;).flatMap(\_.split(&quot; &quot;))</span><br></pre></td></tr></table></figure></p><p>foreach案例实战：打印List中的每个单词<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List(&quot;I&quot;,&quot;have&quot;,&quot;a&quot;,&quot;beautiful&quot;,&quot;house&quot;).foreach(println(\_))</span><br></pre></td></tr></table></figure></p><p>zip案例实战：对学生姓名和学生成绩进行关联<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List(&quot;Leo&quot;,&quot;Jen&quot;,&quot;Peter&quot;,&quot;Jack&quot;).zip(List(100,90,75,83))</span><br></pre></td></tr></table></figure></p><h3 id="综合案例：单词计数"><a href="#综合案例：单词计数" class="headerlink" title="综合案例：单词计数"></a>综合案例：单词计数</h3><p>使用scala的io包将文本文件内的数据读取出来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val lines1 = scala.io.Source.fromFile(&quot;&quot;).mkString</span><br><span class="line">val lines2 = scala.io.Source.fromFile(&quot;&quot;).mkString</span><br></pre></td></tr></table></figure></p><p>使用List的伴生对象，将多个文件内的内容创建为一个List<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val lines = List(lines1,lines2)</span><br></pre></td></tr></table></figure></p><p>下面这一行才是我们的案例的核心和重点，因为有多个高阶函数的链式调用，以及大量下划线的使用，如果没有透彻掌握之前的课程讲解的Scala函数式编程，那么下面这一行代码，完全可能会看不懂！！！<br>但是下面这行代码其实就是Scala编程的精髓所在，就是函数式编程，也是Scala相较于Java等编程员最大的功能优势所在<br>而且，spark的源码中大量使用了这种复杂的链式调用的函数式编程<br>而且，spark本身提供的开发人员使用的编程api的风格，完全沿用了Scala的函数式编程，比如Spark本身的api中就提供了map、flatMap、reduce、foreach，以及更高级的reduceByKey、groupbyKey等高阶函数<br>如果要使用Scala进行spark工程的开发，那么就必须掌握这种复杂的高阶函数的链式调用！！！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lines.flatMap(_.split(&quot; &quot;)).map((\_,1)).map(\_.\_2).reduceLeft(\_ + \_)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Scala的集合体系&quot;&gt;&lt;a href=&quot;#Scala的集合体系&quot; class=&quot;headerlink&quot; title=&quot;Scala的集合体系&quot;&gt;&lt;/a&gt;Scala的集合体系&lt;/h3&gt;&lt;p&gt;Scala中的集合体系主要包括:Iterable、Seq、Set、Map。其中Iterable是所有集合Trait的根trai。这个结构与Java的集合体系非常相似。&lt;br&gt;Scala中的集合是分成可变和不可变两类集合的，其中可变集合就是说，集合的元素可以动态修改，而不可变集合的元素在初始化之后，就无法修改了。分别对应scala.collection.mutable和scala.collection.immutable两个包&lt;br&gt;Seq下包含了Range、ArrayBuffer、List等子trait。其中Range就代表了一个序列，通常可以使用“1  to 10”这种语法来产生一个Range。ArrayBuffer就类似于Java中的ArrayList&lt;br&gt; &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;range: 1 to 10  1.to(10)   1.until(10)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Scala" scheme="http://yoursite.com/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Spark生态圈之Scala(十) ----- Scala中的函数式编程</title>
    <link href="http://yoursite.com/2018/05/17/BigData-Scala5-1/"/>
    <id>http://yoursite.com/2018/05/17/BigData-Scala5-1/</id>
    <published>2018-05-17T08:14:16.000Z</published>
    <updated>2018-05-17T08:39:02.131Z</updated>
    
    <content type="html"><![CDATA[<h3 id="将函数赋值给变量"><a href="#将函数赋值给变量" class="headerlink" title="将函数赋值给变量"></a>将函数赋值给变量</h3><p>Scala中的函数是一等公民，可以独立定义，独立存在，而且直接将函数作为值赋值给变量<br>Scala的语法规定，将函数复制给变量时，必须在函数后面加上空格和下划线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def sayHello(name:String) &#123;println(&quot;Hello,&quot;+name)&#125;</span><br><span class="line"></span><br><span class="line">val sayHelloFunc = sayHello _</span><br><span class="line"></span><br><span class="line">sayHelloFunc(&quot;leo&quot;)</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>Scala中，函数也可以不需要命名，此时函数被称为匿名函数。<br>可以直接定义函数之后，将函数赋值给某个变量；也可以将直接定义的匿名函数传入其他函数之中<br>Scala定义匿名函数的语法规则就是:(参数名:参数类型) =&gt; 函数体<br>这种匿名函数的语法必须深刻理解和掌握，在spark的中有大量这样的语法，如果没有掌握，是看不懂spark源码的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val sayHelloFunc = (name:String) =&gt; println(&quot;Hello,&quot;+name)</span><br></pre></td></tr></table></figure></p><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>Scala中，由于函数是一等公民，因此可以直接将某个函数传入其他函数，作为参数。这个功能是极其强大的，也是Java这种面向对象的编程语言所不具备的。<br>接收其他函数作为参数的函数，也被称作高阶函数(higher-order function)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val sayHelloFunc = (name:String) =&gt; println(&quot;Hello,&quot;+name)</span><br><span class="line">def greeting(func:(String) =&gt;Unit , name:String) &#123;func(name)&#125;</span><br><span class="line">greeting(sayeHelloFunc,&quot;leo&quot;)</span><br><span class="line"></span><br><span class="line">Array(1,2,3,4,5).map((num:Int) =&gt; num*num)</span><br></pre></td></tr></table></figure></p><p>高阶函数的另外一个功能是将函数作为返回值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def getGreetingFunc(msg:String) = (name:String) =&gt; println(msg+&quot;,&quot;+name)</span><br><span class="line">val greetingFunc = getGreetingFunc(&quot;hello&quot;)</span><br><span class="line">greetingFunc(&quot;leo&quot;)</span><br></pre></td></tr></table></figure></p><h3 id="高阶函数的类型推断"><a href="#高阶函数的类型推断" class="headerlink" title="高阶函数的类型推断"></a>高阶函数的类型推断</h3><p>高阶函数可以自动推断出参数类型，而不需要写明类型；而且对于只有一个参数的函数，还可以省去其小括号；如果仅有的一个参数在右侧的函数体内只使用一次，则还可以将接收参数省略，并且将参数用<em>来代替<br> 诸如3*\</em>的这种语法，必须掌握！！Spark源码中大量使用了这种语法！！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def greeting(func:(String) =&gt; Unit,name:String) &#123;func(name)&#125;</span><br><span class="line"></span><br><span class="line">greeting((name:String) =&gt; println(&quot;Hello,&quot;+name),&quot;leo&quot;)</span><br><span class="line"></span><br><span class="line">greeting((name)=&gt;println(&quot;Hello&quot;+name),&quot;leo&quot;)</span><br><span class="line"></span><br><span class="line">greeting(name=&gt;println(&quot;Hello,&quot;+name),&quot;leo&quot;)</span><br><span class="line"></span><br><span class="line">def triple(func:(Int)=&gt;Int)=&#123;func(3)&#125;</span><br><span class="line"></span><br><span class="line">triple(3*_)</span><br></pre></td></tr></table></figure></p><h3 id="Scala的常用高阶函数"><a href="#Scala的常用高阶函数" class="headerlink" title="Scala的常用高阶函数"></a>Scala的常用高阶函数</h3><p>map:对传入的每个元素都进行映射，返回一个处理后的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array(1,2,3,4,5).map(2*\_)</span><br></pre></td></tr></table></figure></p><p>foreach:对传入的每个元素都进行处理，但是没有返回值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1 to 9).map(&quot;*&quot; \* \_).foreach(println)</span><br></pre></td></tr></table></figure></p><p>filter:对传入的每个元素都进行条件判断，如果对元素返回true，则保留该元素，否则过滤掉该元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1 to 20).filter(_ % 2 == 0 )</span><br></pre></td></tr></table></figure></p><p>reduceLeft:从左侧元素开始，进行reduce操作，即先对元素1和元素2进行处理，然后将结果与元素3处理，再将结果与元素4处理，依次类推，即为reduce<br>下面这个操作就相当于1<em>2</em>3<em>4</em>5<em>6</em>7<em>8</em>9<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1 to 9).reduceLeft(\_*\_)</span><br></pre></td></tr></table></figure></p><p>sortWith:对元素进行两两比较，进行排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array(3,2,5,4,10,1).sortWith(\_&lt;\_)</span><br></pre></td></tr></table></figure></p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包最简洁的解释，函数在变量不处于其有效作用域时，还能够对变量进行访问，即为闭包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def getGreetingFunc(msg:String) = (name:String) =&gt; println(msg+&quot;,&quot;+name)</span><br><span class="line"></span><br><span class="line">val greetingFuncHello = getGreetingFunc(&quot;hello&quot;)</span><br><span class="line"></span><br><span class="line">val greetingFuncHi = getGreetingFunc(&quot;hi&quot;)</span><br></pre></td></tr></table></figure></p><p>两次调用getGreetingFunc函数，传入不同的msg，并创建不同的函数返回<br>然而，msg只有一个局部变量，却在getGreetingFunc执行完之后，还可以继续存在创建的函数之中；greetingFuncHello(“leo”)，调用时，值为”hello”的msg被保留在了函数体内部，可以反复的使用</p><p>这种变量超出了其作用域，还可以使用的情况，即为闭包<br>Scala通过为每个函数创建对象来实现闭包，实际上对于getGreetingFunc函数创建的函数，msg是作为函数对象的变量存在的，因此每个函数才可以拥有不同的msg<br>Scala编译器会确保上述闭包机制</p><h3 id="SAM转换"><a href="#SAM转换" class="headerlink" title="SAM转换"></a>SAM转换</h3><p>在Java中，不支持直接将函数传入一个方法作为参数，通常来说，唯一的方法就是定义一个实现了某个接口的类的实例对象，该对象只有一个方法；而这些接口都只有单个的抽象方法，也就是single abstract method，简称为SAM</p><p>由于Scala是可以调用Java的代码的，因此当我们调用Java的某个方法时，可能就不得不创建SAM传递给方法，非常麻烦；但是Scala又是支持直接传递函数的。此时就可以使用Scala提供的，在调用Java方法时，使用的功能，SAM转换，即将SAM转换为Scala函数</p><p>要使用SAM转换，需要使用Scala提供的特性，隐式转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import javax.swing._</span><br><span class="line">import java.awt.event._</span><br><span class="line"></span><br><span class="line">val button = new JButton(&quot;Click&quot;)</span><br><span class="line">button.addActionListener(new ActionListener&#123;</span><br><span class="line">  override def actionPerformed(event:ActionEvent)&#123;</span><br><span class="line">    println(&quot;Click Me!!!&quot;)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">implicit def getActionListener(actionProcessFunc:(ActionEvent)=&gt;Unit) = new ActionListener&#123;</span><br><span class="line">  override def actionPerformed(event:ActionEvent)&#123;</span><br><span class="line">    actionProcessFunc(event)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Currying函数"><a href="#Currying函数" class="headerlink" title="Currying函数"></a>Currying函数</h3><p>Curring函数，指的是，将原来接收两个参数的一个函数，转换为两个函数，第一个函数接收原先的第一个参数，然后返回接收原先第二个参数的第二个函数。<br>在函数调用的过程中，就变为两个函数连续调用的形式<br>在Spark的源码中也有体现，所以对()()这种形式的Curring函数，必须掌握！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def sum(a:Int,b:Int)=a+b</span><br><span class="line">sum(1,1)</span><br><span class="line"></span><br><span class="line">def sum2(a:Int) = (b:Int)=&gt;a+b</span><br><span class="line">sum2(1)(1)</span><br><span class="line"></span><br><span class="line">def sum3(a:Int)(b:Int)=a+b</span><br></pre></td></tr></table></figure><h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>Scala中，不需要使用return来返回函数的值，函数最后一行语句的值，就是函数的返回值。在Scala中，return用于在匿名函数中返回值给包含匿名函数的带名函数，并作为带名函数的返回值。<br>使用return的匿名函数，是必须给出返回类型的，否则无法通过编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def greeting(name:String)=&#123;</span><br><span class="line"> def sayHello(name:String):String=&#123;</span><br><span class="line">     return &quot;Hello,&quot;+name</span><br><span class="line">  &#125;</span><br><span class="line"> sayHello(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;将函数赋值给变量&quot;&gt;&lt;a href=&quot;#将函数赋值给变量&quot; class=&quot;headerlink&quot; title=&quot;将函数赋值给变量&quot;&gt;&lt;/a&gt;将函数赋值给变量&lt;/h3&gt;&lt;p&gt;Scala中的函数是一等公民，可以独立定义，独立存在，而且直接将函数作为值赋值给变量&lt;br&gt;Scala的语法规定，将函数复制给变量时，必须在函数后面加上空格和下划线&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;def sayHello(name:String) &amp;#123;println(&amp;quot;Hello,&amp;quot;+name)&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;val sayHelloFunc = sayHello _&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sayHelloFunc(&amp;quot;leo&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Scala" scheme="http://yoursite.com/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Spark生态圈之Scala(九) ----- Scala中的面向对象编程之Trait</title>
    <link href="http://yoursite.com/2018/05/17/BigData-Scala4-4/"/>
    <id>http://yoursite.com/2018/05/17/BigData-Scala4-4/</id>
    <published>2018-05-17T08:13:01.000Z</published>
    <updated>2018-05-17T08:39:02.957Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Scala" scheme="http://yoursite.com/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Spark生态圈之Scala(八) ----- Scala中的面向对象编程之继承</title>
    <link href="http://yoursite.com/2018/05/17/BigData-Scala4-3/"/>
    <id>http://yoursite.com/2018/05/17/BigData-Scala4-3/</id>
    <published>2018-05-17T08:04:10.000Z</published>
    <updated>2018-05-17T08:39:17.363Z</updated>
    
    <content type="html"><![CDATA[<h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><p>scala中，让子类继承父类，与Java一样，也是使用extends关键字<br>继承就代表，子类可以从父类继承父类的field和method，然后子类可以在自己内部放入父类所没有，子类特有的field和method；使用继承可以有效复用代码<br>子类可以覆盖父类的field和method；但是如果父类用final修饰，field和method用final修饰，则该类是无法被继承的，field和method是无法被覆盖的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  private var name = &quot;leo&quot;</span><br><span class="line">  def getName = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">  private var score = &quot;A&quot;</span><br><span class="line">  def getScore = score</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="override和super"><a href="#override和super" class="headerlink" title="override和super"></a>override和super</h3><p>Scala中，如果子类要覆盖一个父类中的非抽象方法，则必须使用override关键字<br>override关键字可以帮助我们尽早地发现代码里的错误，比如:override修饰的父类方法的方法名我们拼写错了；比如要覆盖的父类方法的参数我们写错了；等等<br>此外，在子类覆盖父类方法之后，如果我们在子类中就是要调用父类的被覆盖的方法呢？那就可以使用super关键字。显式地指定要调用父类的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  private var name = &quot;leo&quot;</span><br><span class="line">  def getName = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">  private var score = &quot;A&quot;</span><br><span class="line">  def getScore = score</span><br><span class="line">  override def getName = &quot;Hi,I&apos;m &quot;+super.getName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="override-field"><a href="#override-field" class="headerlink" title="override field"></a>override field</h3><p>Scala中，子类可以覆盖父类的val field，而且子类的val field还可以覆盖父类的val field的getter方法；只要在子类中使用override关键字即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  val name:String = &quot;Person&quot;</span><br><span class="line">  def age:Int = 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person&#123;</span><br><span class="line"> override val name:String = &quot;leo&quot;</span><br><span class="line"> override val age:Int = 30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="isInstanceOf和asInstanceOf"><a href="#isInstanceOf和asInstanceOf" class="headerlink" title="isInstanceOf和asInstanceOf"></a>isInstanceOf和asInstanceOf</h3><p>如果我们创建了子类的对象，但是又将其赋予了父类类型的变量。则在后续的程序中，我们又需要将父类类型的变量转换为子类类型的变量，应该如何做?<br>首先，需要使用isInstanceOf判断对象是否是指定类的对象，如果是的话，则可以使用asInstanceOf将对象转换为指定类型<br>注意，如果对象时null,则isInstanceOf一定返回false，asInstanceOf一定返回null<br>注意，如果没有用isInstanceOf先判断对象是否为指定类的实例，就直接用asInstanceOf转换，则可能抛出异常<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">class Student extends Person</span><br><span class="line"></span><br><span class="line">val p:Person  = new Student</span><br><span class="line"></span><br><span class="line">val s:Student = null</span><br><span class="line">if(p.isInstanceOf[Student]) s = p.asInstanceOf[Student]</span><br></pre></td></tr></table></figure></p><h3 id="getClass和classOf"><a href="#getClass和classOf" class="headerlink" title="getClass和classOf"></a>getClass和classOf</h3><p>isInstanceOf只能判断出对象是否是指定类以及其子类的对象，而不能精确判断出，对象就是指定类的对象<br>如果要求精确地判断对象就是指定类的对象，那么就只能使用getClass和classOf了<br>对象.getClass可以精确获取对象的类，classOf[类]可以精确获取类，然后使用==操作符即可判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line"></span><br><span class="line">class Student extends Person</span><br><span class="line"></span><br><span class="line">val p:Person = new Student</span><br><span class="line"></span><br><span class="line">p.isInstanceOf[Person]</span><br><span class="line"></span><br><span class="line">p.getClass == classOf[Person]</span><br><span class="line"></span><br><span class="line">p.getClass == classOf[Student]</span><br></pre></td></tr></table></figure></p><h3 id="使用模式匹配进行类型判断"><a href="#使用模式匹配进行类型判断" class="headerlink" title="使用模式匹配进行类型判断"></a>使用模式匹配进行类型判断</h3><p>但是在实际开发中，比如spark的源码中，大量的地方都是使用了模式匹配的方式来进行类型的判断，这种方式更加地简介明了，而且代码得可维护性和可扩展性也非常的高<br>使用模式匹配，功能性上来说，与isInstanceOf一样，也是判断主要是该类以及该类的子类的对象即可，不是精确判断的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line"></span><br><span class="line">class Student extends Person</span><br><span class="line"></span><br><span class="line">val p:Person = new Student</span><br><span class="line"></span><br><span class="line">p match&#123;</span><br><span class="line"> case per:Person =&gt; println(&quot;it&apos;s Person&apos;s object&quot;)</span><br><span class="line"> case_ =&gt; println(&quot;unknown type&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h3><p>跟java一样，scala中同样可以使用protected关键字来修饰field和method，这样在子类中就不需要super关键字，直接就可以访问field和method<br>还可以使用protected[this]，则只能在当前子类对象中访问父类的field和method，无法通过其他子类对象访问父类的field和method<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  protected var name:String = &quot;leo&quot;</span><br><span class="line">  protected[this] var hobby:String = &quot;game&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person</span><br><span class="line">&#123;</span><br><span class="line">  def sayHello=println(&quot;Hello,&quot;+name)</span><br><span class="line">  def makeFriends(s:Student)&#123;</span><br><span class="line">   println(&quot;my hobby is &quot;+hobby+&quot;,your hobby is&quot;+s.hobby)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其它实例可以访问:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  protected var name:String = &quot;leo&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">  def makeFriends(s:Student): Unit =&#123;</span><br><span class="line">    println(&quot;Hi,my name is &quot;+name+&quot;,your name is &quot;+s.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val s1 = new Student</span><br><span class="line">val s2 = new Student</span><br><span class="line">s1.makeFriends(s2)</span><br></pre></td></tr></table></figure></p><p>其他实例不能访问 : (使用protected[this])</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  protected[this] var name:String = &quot;leo&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">  def makeFriends(s:Student): Unit =&#123;</span><br><span class="line">    println(&quot;Hi,my name is &quot;+name+&quot;,your name is &quot;+s.name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val s1 = new Student</span><br><span class="line">val s2 = new Student</span><br><span class="line">s1.makeFriends(s2)</span><br></pre></td></tr></table></figure><h3 id="调用父类的constructor"><a href="#调用父类的constructor" class="headerlink" title="调用父类的constructor"></a>调用父类的constructor</h3><p>Scala中，每个类可以有一个主constructor和任意多个辅助constructor，而每个辅助constructor的第一行都必须是调用其他辅助constructor或者是主constructor；因此子类的辅助constructor是一定不可能直接调用父类的constructor的<br>只能在子类的主constructor中调用父类的constructor，以下这种语法，就是通过子类的主构造函数来调用父类的构造函数<br>注意！如果是父类中接收的参数，比如name和age，子类中接收时，就不要用任何val或var来修饰了，否则会认为是子类要覆盖父类的field<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person(val name:String,val age:Int)</span><br><span class="line"></span><br><span class="line">class Student(name:String,age:Int,var score:Double) extends Person(name,age)&#123;</span><br><span class="line">    def this(name:String)&#123;</span><br><span class="line">     this(name,0,0)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def this(age:Int)</span><br><span class="line">  &#123;</span><br><span class="line">    this(&quot;leo&quot;,age,0)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;extends&quot;&gt;&lt;a href=&quot;#extends&quot; class=&quot;headerlink&quot; title=&quot;extends&quot;&gt;&lt;/a&gt;extends&lt;/h3&gt;&lt;p&gt;scala中，让子类继承父类，与Java一样，也是使用extends关键字&lt;br&gt;继承就代表，子类可以从父类继承父类的field和method，然后子类可以在自己内部放入父类所没有，子类特有的field和method；使用继承可以有效复用代码&lt;br&gt;子类可以覆盖父类的field和method；但是如果父类用final修饰，field和method用final修饰，则该类是无法被继承的，field和method是无法被覆盖的&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class Person&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  private var name = &amp;quot;leo&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  def getName = name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class Student extends Person&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  private var score = &amp;quot;A&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  def getScore = score&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Scala" scheme="http://yoursite.com/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Spark生态圈之Scala(七) ----- Scala中的面向对象编程之对象</title>
    <link href="http://yoursite.com/2018/05/17/BigData-Scala4-2/"/>
    <id>http://yoursite.com/2018/05/17/BigData-Scala4-2/</id>
    <published>2018-05-17T07:53:35.000Z</published>
    <updated>2018-05-17T08:39:59.063Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>object,相当于class的单个实例，通常在里面放一些静态的field或者method<br>第一次调用Object的方法时，就会执行object的constructor，也就是object内部不在method中的代码；但是object不能定义接受参数的constructor<br>注意，object的constructor只会在其第一次被调用时执行一次，以后再次调用就不会再次执行constructor了<br>object通常用于作为单例模式的实现，或者放class的静态成员，比如工具方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">object Person&#123;</span><br><span class="line">  private var eyeNum = 2</span><br><span class="line">  println(&quot;this Person object!&quot;)</span><br><span class="line">  def getEysNum = eyeNum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="Object继承抽象类"><a href="#Object继承抽象类" class="headerlink" title="Object继承抽象类"></a>Object继承抽象类</h3><p>object 的功能其实和class类似，除了不能定义接受参数的constructor之外<br>object也可以继承抽象类，并覆盖抽象类中的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">abstract class Hello(var message:String)&#123;</span><br><span class="line">  def sayHello(name:String):Unit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object HelloImpl extends Hello(&quot;Hello&quot;)&#123;</span><br><span class="line">  override def sayHello(name:String)=&#123;</span><br><span class="line">    println(message+&quot;,&quot;+name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h3><p>如果有一个class,还有一个与class同名的object，那么就称这个object是class的伴生对象，class是object的伴生类<br> 伴生类和伴生对象必须存放在一个.scala文件之中<br>伴生类和伴生对象，最大的特点就在于，互相可以访问private field<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person(val name:String,val age:Int)&#123;</span><br><span class="line">  def sayHello = println(&quot;Hi,&quot;+name+&quot;,I guess you are&quot;+age+&quot;years old!&quot;+&quot;,and usually you must have &quot;+Person.eyeNum+&quot; eyes.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object Person&#123;</span><br><span class="line">  private val eyeNum = 2</span><br><span class="line">  def getEyeNum = eyeNum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="apply方法"><a href="#apply方法" class="headerlink" title="apply方法"></a>apply方法</h3><p>object 中非常重要的一个特殊方法，就是apply方法<br>通常在伴生对象中实现apply方法，并在其中实现构造半生类的对象的功能<br>而创建伴生类的对象时，通常不会使用new Class的方式，而是使用Class()的方式，隐式地调用伴生对象得apply方法，这样会让对象创建更加简洁<br>比如，Array类的伴生对象得apply方法就实现了接收可变数量的参数，并创建一个Array对象的功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val a = Array(1,2,3,4,5)</span><br></pre></td></tr></table></figure></p><p>比如，定义自己的伴生类和伴生对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Person(val name:String)</span><br><span class="line">object Person&#123;</span><br><span class="line">  def apply(name:String) = new Person(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h3><p>就如同java中，如果要运行一个程序，必须编写一个包含main方法类一样；在scala中，如果要运行一个应用程序，那么必须有一个main方法，作为入口<br>scala中的main方法定义为def main(args:Array[String]),并且必须定义在object中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">object HelloWorld&#123;</span><br><span class="line">  def main(args:Array[String])&#123;</span><br><span class="line">    println(&quot;Hello World!!!&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除了自己实现main方法之外，还可以继承App Trait，然后将需要在main方法中运行的代码，直接作为object的constructor代码；而且用args可以接受传入的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">object HelloWorld extends App&#123;</span><br><span class="line">  if(args.length&gt;0) println(&quot;hello,&quot;+args(0))</span><br><span class="line">  else println(&quot;Hello World!!!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果要运行上述代码，需要将其方法.scala文件，然后先使用scalac编译，再用scala执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scalac HelloWorld.scala</span><br><span class="line">scala -Dscala.time HelloWorld</span><br></pre></td></tr></table></figure></p><p>App Trait的工作原理为：App Trait继承自DeployedInit Trait,scalac命令进行编译时，会把继承App Trait的object的constructor代码放到DeplayedInit Trait的deplayedInit方法中执行</p><h3 id="Object实现枚举功能"><a href="#Object实现枚举功能" class="headerlink" title="Object实现枚举功能"></a>Object实现枚举功能</h3><p>Scala没有直接提供类似于java中的Enum这样的枚举特性，如果要实现枚举，则需要用object继承Enumerationlei，并且调用value方法来初始化枚举值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">object Season extends Enumeration&#123;</span><br><span class="line">  val SPRING,SUMMER,AUTUMN,WINTER = Value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还可以通过Value传入枚举值的id和name，通过id和toString可以获取，还可以通过id和name来查找枚举值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">object Season extends Enumeration&#123;</span><br><span class="line">  val SPRING = Value(0,&quot;spring&quot;)</span><br><span class="line">  val SUMMER = Value(1,&quot;summer&quot;)</span><br><span class="line">  val AUTUMN = Value(2,&quot;autumn&quot;)</span><br><span class="line">  val WINTER = Value(3,&quot;winter&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Season(0)</span><br><span class="line">Season.withName(&quot;spring&quot;)</span><br></pre></td></tr></table></figure></p><p>使用枚举object.values可以遍历枚举值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(ele &lt;- Season.values) println(ele)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Object&quot;&gt;&lt;a href=&quot;#Object&quot; class=&quot;headerlink&quot; title=&quot;Object&quot;&gt;&lt;/a&gt;Object&lt;/h3&gt;&lt;p&gt;object,相当于class的单个实例，通常在里面放一些静态的field或者method&lt;br&gt;第一次调用Object的方法时，就会执行object的constructor，也就是object内部不在method中的代码；但是object不能定义接受参数的constructor&lt;br&gt;注意，object的constructor只会在其第一次被调用时执行一次，以后再次调用就不会再次执行constructor了&lt;br&gt;object通常用于作为单例模式的实现，或者放class的静态成员，比如工具方法&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;object Person&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  private var eyeNum = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  println(&amp;quot;this Person object!&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  def getEysNum = eyeNum&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Scala" scheme="http://yoursite.com/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Spark生态圈之Scala(六) ----- Scala中的面向对象编程之类</title>
    <link href="http://yoursite.com/2018/05/17/BigData-Scala4-1/"/>
    <id>http://yoursite.com/2018/05/17/BigData-Scala4-1/</id>
    <published>2018-05-17T07:44:10.000Z</published>
    <updated>2018-05-17T08:39:09.105Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><p>定义类，包含field以及方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class HelloWorld</span><br><span class="line">&#123;</span><br><span class="line">   private var name = &quot;leo&quot;</span><br><span class="line">   def sayHello() &#123; print(&quot;Hello , &quot;+name)&#125;</span><br><span class="line">   def getName = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建类的对象，并调用其方法</span><br><span class="line">val helloWorld = new HelloWorld</span><br><span class="line">helloWorld.sayHello()</span><br><span class="line"></span><br><span class="line">//也可以不加括号，如果定义方法时不带括号，则调用方法时也不能带括号</span><br><span class="line">print(helloWorld.getName)</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="field的getter与setter"><a href="#field的getter与setter" class="headerlink" title="field的getter与setter"></a>field的getter与setter</h3><p>定义不带private的var field，此时scala生成的面向JVM的类时，会定义为private的name字段，并提供public的getter和setter方法,而如果使用private修饰field，则生成的getter和setter也是private的,如果定义val field，则只会生成getter方法,如果不希望生成setter和getter方法，则将field声明为private[this]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Student&#123;</span><br><span class="line">    var name = &quot;leo&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用getter和setter方法，分别叫做name和name_ =</span><br><span class="line"></span><br><span class="line">val leo = new Student</span><br><span class="line">print(leo.name)</span><br><span class="line">leo.name = &quot;leo1&quot;</span><br></pre></td></tr></table></figure><h3 id="自定义getter和setter方法"><a href="#自定义getter和setter方法" class="headerlink" title="自定义getter和setter方法"></a>自定义getter和setter方法</h3><p>如果只是希望拥有简单的getter和setter方法，那么就按照scala提供的语法规则，根据需求为field选择合适的修饰符就好:var、val、private、private[this]<br>但是如果希望能够自己对getter与setter进行控制，则可以自定义getter和setter方法<br>自定义setter方法的时候一定需要注意scala的语法限制，签名、=、参数间不能有空格<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Student&#123;</span><br><span class="line">    private var myName = &quot;leo&quot;</span><br><span class="line">    def name = &quot;your name is &quot; + myName</span><br><span class="line">    def name_=(newValue:String)&#123;</span><br><span class="line">     print(&quot;you cannot edit your name !!!&quot;)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val leo = new Student</span><br><span class="line">print(leo.name)</span><br><span class="line">leo.name = &quot;leo1&quot;</span><br></pre></td></tr></table></figure></p><h3 id="private-this-的使用"><a href="#private-this-的使用" class="headerlink" title="private[this]的使用"></a>private[this]的使用</h3><p>如果将field使用private来修饰，那么代表这个field是类私有的，在类的方法中，可以直接访问类的其他对象的private field<br>这种情况下，如果不希望field被其他对象访问到，那么可以使用private[this]，意味着对象私有的field，只有本对象内可以访问到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Student&#123;</span><br><span class="line">   private var myAge = 0</span><br><span class="line">   def age_ = (newValue:Int)&#123;</span><br><span class="line">   if(newValue&gt;0) myAge = newValue</span><br><span class="line">     else print(&quot;illegal age!&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  def age = myAge</span><br><span class="line">  def older(s:Student) = &#123;</span><br><span class="line">     myAge &gt; s.myAge</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java风格的getter和setter方法"><a href="#Java风格的getter和setter方法" class="headerlink" title="Java风格的getter和setter方法"></a>Java风格的getter和setter方法</h3><p>Scala的getter和setter方法的命名与java是不同的，是field和field_=的方式<br>如果要让scala自动生成java风格的getter和setter方法，只要给field添加@BeanProperty注解即可<br>此时会生成4个方法，name:String、name_=(newValue:String):Unit、getName():String、setName(newValue:String):Unit<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import scala.reflect.BeanProperty</span><br><span class="line">class Student&#123;</span><br><span class="line">   @BeanProperty var name:String =_</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student(@BeanProperty var name:String)</span><br><span class="line"></span><br><span class="line">val s = new Student</span><br><span class="line">s.getName(&quot;leo&quot;)</span><br><span class="line">s.getName()</span><br></pre></td></tr></table></figure></p><h3 id="辅助constructor"><a href="#辅助constructor" class="headerlink" title="辅助constructor"></a>辅助constructor</h3><p>Scala中，可以给类定义多个辅助constructor，类似于java中的构造函数重载<br>辅助constructor之间可以互相调用，而且必须第一行调用主constructor<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Student</span><br><span class="line">&#123;</span><br><span class="line">  private var name =&quot;&quot;</span><br><span class="line">  private var age = 0</span><br><span class="line">   def this(name:String)</span><br><span class="line">  &#123;</span><br><span class="line">     this()</span><br><span class="line">     this.name = name</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    def this(name:String,age:Int)</span><br><span class="line">   &#123;</span><br><span class="line">     this(name)</span><br><span class="line">     this.age = age</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;定义类&quot;&gt;&lt;a href=&quot;#定义类&quot; class=&quot;headerlink&quot; title=&quot;定义类&quot;&gt;&lt;/a&gt;定义类&lt;/h3&gt;&lt;p&gt;定义类，包含field以及方法&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class HelloWorld&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   private var name = &amp;quot;leo&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   def sayHello() &amp;#123; print(&amp;quot;Hello , &amp;quot;+name)&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   def getName = name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//创建类的对象，并调用其方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;val helloWorld = new HelloWorld&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;helloWorld.sayHello()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//也可以不加括号，如果定义方法时不带括号，则调用方法时也不能带括号&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(helloWorld.getName)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Scala" scheme="http://yoursite.com/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Spark生态圈之Scala(五) ----- Scala中的Map和Tuple</title>
    <link href="http://yoursite.com/2018/05/08/BigData-Scala3/"/>
    <id>http://yoursite.com/2018/05/08/BigData-Scala3/</id>
    <published>2018-05-08T01:53:48.000Z</published>
    <updated>2018-05-17T08:39:20.191Z</updated>
    
    <content type="html"><![CDATA[<h3 id="创建Map"><a href="#创建Map" class="headerlink" title="创建Map"></a>创建Map</h3><p>创建一个不可变的Map<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val ages = Map(&quot;Leo&quot;-&gt;30,&quot;Jen&quot;-&gt;25,&quot;Jack&quot;-&gt;23)</span><br><span class="line">ages(&quot;Leo&quot;)=31</span><br></pre></td></tr></table></figure></p><p>创建一个可变的Map<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val ages = scala.collection.mutable.Map(&quot;Leo&quot;-&gt;30,&quot;Jen&quot;-&gt;25,&quot;Jack&quot;-&gt;23)</span><br><span class="line">ages(&quot;Leo&quot;)=31</span><br></pre></td></tr></table></figure></p><p>使用另外一种方式定义Map元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val ages = Map((&quot;Leo&quot;,30),(&quot;Jen&quot;,25),(&quot;Jack&quot;,23))</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>创建一个空的HashMap<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val ages = new scala.collection.mutable.HashMap[String,Int]</span><br></pre></td></tr></table></figure></p><h3 id="访问Map的元素"><a href="#访问Map的元素" class="headerlink" title="访问Map的元素"></a>访问Map的元素</h3><p>获取指定key对应的value，如果key不存在，会报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val leoAge = ages(&quot;leo&quot;)</span><br><span class="line">val leoAge = ages(&quot;leo&quot;)</span><br></pre></td></tr></table></figure></p><p>使用contains函数检查key是否存在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val leoAge = if(ages.contains(&quot;leo&quot;)) ages(&quot;leo&quot;) else 0</span><br></pre></td></tr></table></figure></p><p>getOrElse函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val leoAge = ages.getOrElse(&quot;leo&quot;,0)</span><br></pre></td></tr></table></figure></p><h3 id="修改Map元素"><a href="#修改Map元素" class="headerlink" title="修改Map元素"></a>修改Map元素</h3><p>更新Map的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ages(&quot;Leo&quot;) = 31</span><br></pre></td></tr></table></figure></p><p>增加多个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ages+=(&quot;Mike&quot;-&gt;35,&quot;Tom&quot;-&gt;40)</span><br></pre></td></tr></table></figure></p><p>移除元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ages -= &quot;Mike&quot;</span><br></pre></td></tr></table></figure></p><p>更新不可变的map<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val ages2 = ages+(&quot;Leo&quot;-&gt;30,&quot;Jen&quot;-&gt;25,&quot;Jack&quot;-&gt;23)</span><br></pre></td></tr></table></figure></p><p>移除不可变map的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val ages3 = ages-&quot;Tom&quot;</span><br></pre></td></tr></table></figure></p><h3 id="遍历Map"><a href="#遍历Map" class="headerlink" title="遍历Map"></a>遍历Map</h3><p>遍历map的entrySet<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for((key,value)&lt;- ages) println(key+&quot; &quot;+value)</span><br></pre></td></tr></table></figure></p><p>遍历map的key<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(key &lt;- ages.keySet) println(key)</span><br></pre></td></tr></table></figure></p><p>遍历map的value<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(value &lt;- ages.values) println(value)</span><br></pre></td></tr></table></figure></p><p>生成新map，反转key和value<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for((key,value) &lt;- ages) yield (value,key)</span><br></pre></td></tr></table></figure></p><h3 id="SortedMap和LinkedHashMap"><a href="#SortedMap和LinkedHashMap" class="headerlink" title="SortedMap和LinkedHashMap"></a>SortedMap和LinkedHashMap</h3><p>SortedMap可以自动对Map的key的排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val ages = scala.collection.immutable.SortedMap(&quot;leo&quot;-&gt;30 , &quot;alice&quot;-&gt;15 , &quot;jen&quot;-&gt;25)</span><br></pre></td></tr></table></figure></p><p>LinkedHashMap可以记住插入entry的顺序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val ages = new scala.collection.mutable.LinkedHashMap[String,Int]</span><br><span class="line">ages(&quot;leo&quot;) = 30</span><br><span class="line">ages(&quot;alice&quot;) = 15</span><br><span class="line">ages(&quot;jen&quot;) = 25</span><br></pre></td></tr></table></figure></p><h3 id="Map的元素类型-Tuple"><a href="#Map的元素类型-Tuple" class="headerlink" title="Map的元素类型-Tuple"></a>Map的元素类型-Tuple</h3><p>简单Tuple<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val t = (&quot;leo&quot;,30)</span><br></pre></td></tr></table></figure></p><p>访问Tuple</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t._1</span><br></pre></td></tr></table></figure><p>zip操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val names = Array(&quot;leo&quot;,&quot;jack&quot;,&quot;mike&quot;)</span><br><span class="line">val ages = Array(30,24,26)</span><br><span class="line">val nameAges = names.zip(ages)</span><br><span class="line">for((name,age) &lt;- nameAges) println(name+&quot;:&quot;+age)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;创建Map&quot;&gt;&lt;a href=&quot;#创建Map&quot; class=&quot;headerlink&quot; title=&quot;创建Map&quot;&gt;&lt;/a&gt;创建Map&lt;/h3&gt;&lt;p&gt;创建一个不可变的Map&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;val ages = Map(&amp;quot;Leo&amp;quot;-&amp;gt;30,&amp;quot;Jen&amp;quot;-&amp;gt;25,&amp;quot;Jack&amp;quot;-&amp;gt;23)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ages(&amp;quot;Leo&amp;quot;)=31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;创建一个可变的Map&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;val ages = scala.collection.mutable.Map(&amp;quot;Leo&amp;quot;-&amp;gt;30,&amp;quot;Jen&amp;quot;-&amp;gt;25,&amp;quot;Jack&amp;quot;-&amp;gt;23)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ages(&amp;quot;Leo&amp;quot;)=31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;使用另外一种方式定义Map元素&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;val ages = Map((&amp;quot;Leo&amp;quot;,30),(&amp;quot;Jen&amp;quot;,25),(&amp;quot;Jack&amp;quot;,23))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Scala" scheme="http://yoursite.com/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Spark生态圈之Scala(四) ----- Scala中的数组操作(三)</title>
    <link href="http://yoursite.com/2018/05/08/BigData-Scala1-4/"/>
    <id>http://yoursite.com/2018/05/08/BigData-Scala1-4/</id>
    <published>2018-05-08T01:46:54.000Z</published>
    <updated>2018-05-18T00:55:05.728Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数组转换"><a href="#数组转换" class="headerlink" title="数组转换"></a>数组转换</h3><p>使用yield和函数式编程转换数组</p><p>对Array进行转换，获取的还是Array<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val a = Array(1,2,3,4,5)</span><br><span class="line">val a2 = for(ele &lt;- a) yield ele*ele</span><br></pre></td></tr></table></figure></p><p>对ArrayBuffer进行转换，获取的还是ArrayBuffer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val b = ArrayBuffer[Int]()</span><br><span class="line">b += (1,2,3,4,5)</span><br><span class="line">val b2 = for(ele &lt;-b ) yield ele*ele</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>结合if守卫，仅转换需要的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val a3 = for(ele &lt;- if ele %2 ==0) yield ele*ele</span><br></pre></td></tr></table></figure></p><p>使用函数式编程转换数组(通常使用第一种方式)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.filter( _%2 ==0).map(2*_)</span><br><span class="line">a.filter&#123;_%2==0&#125;map(2*_)</span><br></pre></td></tr></table></figure></p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>算法案例：移出第一个负数之后的所有依赖</p><p>构建数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val = ArrayBuffer[Int]()</span><br><span class="line">a+=(1,2,3,4,5,-1,-3,-5,-9)</span><br></pre></td></tr></table></figure></p><p>每发现一个第一个负数之后的负数，就进行移除，性能较差，多次移动数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var foundFirstNegative = false</span><br><span class="line">var arrayLength = a.length</span><br><span class="line">var  index = 0</span><br><span class="line">while(index&lt;arrayLength)</span><br><span class="line">&#123;</span><br><span class="line">  if(a(index)&gt;=0)</span><br><span class="line">   &#123;</span><br><span class="line">     index+=1</span><br><span class="line">    &#125;else</span><br><span class="line">    &#123;</span><br><span class="line">       if(!foundFirstNegative)</span><br><span class="line">        &#123;</span><br><span class="line">          foundFirstNegative=true;index+=1</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;a.remove(index);arrayLength-=1&#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="案例改良版"><a href="#案例改良版" class="headerlink" title="案例改良版"></a>案例改良版</h3><p>算法案例：移出第一个负数之后的所有负数(改良版)</p><p>重新构建数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val a = ArrayBuffer[Int]()</span><br><span class="line">a +=(1,2,3,4,5,-1,-3,-5,-9)</span><br></pre></td></tr></table></figure></p><p>每记录所有不需要移除的元素的索引，稍后一次性移除所有需要移除的元素<br>性能较高，数组内的元素迁移只要执行一次即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val foundFirstNegative = false</span><br><span class="line"></span><br><span class="line">val keepIndexes = for(i&lt;- 0 until a.length if!foundFirstNegative || a(i)&gt;=0) yield&#123;</span><br><span class="line"> if(a(i)&lt;0) foundFirstNegative = true</span><br><span class="line"> i</span><br><span class="line">&#125;</span><br><span class="line">for(i&lt;- 0 until keepIndexes.length) &#123;a(i) = a(keepIndexes(i))&#125;</span><br><span class="line">a.trimEnd(a.length - keepIndexes.length)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数组转换&quot;&gt;&lt;a href=&quot;#数组转换&quot; class=&quot;headerlink&quot; title=&quot;数组转换&quot;&gt;&lt;/a&gt;数组转换&lt;/h3&gt;&lt;p&gt;使用yield和函数式编程转换数组&lt;/p&gt;
&lt;p&gt;对Array进行转换，获取的还是Array&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;val a = Array(1,2,3,4,5)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;val a2 = for(ele &amp;lt;- a) yield ele*ele&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;对ArrayBuffer进行转换，获取的还是ArrayBuffer&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;val b = ArrayBuffer[Int]()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b += (1,2,3,4,5)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;val b2 = for(ele &amp;lt;-b ) yield ele*ele&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Scala" scheme="http://yoursite.com/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Spark生态圈之Scala(三) ----- Scala中的数组操作(二)</title>
    <link href="http://yoursite.com/2018/05/08/BigData-Scala1-3/"/>
    <id>http://yoursite.com/2018/05/08/BigData-Scala1-3/</id>
    <published>2018-05-08T01:40:54.000Z</published>
    <updated>2018-05-18T00:55:08.949Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数组常见操作"><a href="#数组常见操作" class="headerlink" title="数组常见操作"></a>数组常见操作</h3><p>数组元素求和<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val a = Array(1,2,3,4,5)</span><br><span class="line">val sum = a.sum</span><br></pre></td></tr></table></figure></p><p>获取数组最大值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val max = a.max</span><br></pre></td></tr></table></figure></p><p>对数组进行排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scala.util.Sorting.quickSort(a)</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>获取数组中所有元素内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.mkString</span><br><span class="line">a.mkString(&quot;,&quot;)</span><br><span class="line">a.mkString(&quot;&lt;&quot;,&quot;,&quot;,&quot;&gt;&quot;)</span><br></pre></td></tr></table></figure></p><p>toString函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.toString</span><br><span class="line">b.toString</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;数组常见操作&quot;&gt;&lt;a href=&quot;#数组常见操作&quot; class=&quot;headerlink&quot; title=&quot;数组常见操作&quot;&gt;&lt;/a&gt;数组常见操作&lt;/h3&gt;&lt;p&gt;数组元素求和&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;val a = Array(1,2,3,4,5)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;val sum = a.sum&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;获取数组最大值&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;val max = a.max&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;对数组进行排序&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;scala.util.Sorting.quickSort(a)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Scala" scheme="http://yoursite.com/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Spark生态圈之Scala(二) ----- Scala中的数组操作(一)</title>
    <link href="http://yoursite.com/2018/05/07/BigData-Scala1-2/"/>
    <id>http://yoursite.com/2018/05/07/BigData-Scala1-2/</id>
    <published>2018-05-07T10:02:33.000Z</published>
    <updated>2018-05-18T00:55:07.516Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Array数组"><a href="#Array数组" class="headerlink" title="Array数组"></a>Array数组</h3><p>在Scala中，Array代表的含义与Java类似，也是长度不可变的数组。此外，由于Scala与Java都是运行在JVM中，双方可以互相调用。因此，Scala数组的底层实际上是Java数组。例如，字符串数组在底层就是Java的String[],整数数组在底层就是Java的Int[]</p><p>数组初始化后，长度就固定下来了，而且元素全部根据其类型初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val a = new Array[Int](10)</span><br><span class="line">val a = new Array[String](10)</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>可以直接使用Array()创建数组，元素类型自动推断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val a = Array(&quot;hello&quot;,&quot;world&quot;)</span><br><span class="line">a(0)=&quot;hi&quot;</span><br></pre></td></tr></table></figure></p><h3 id="ArrayBuffer数组"><a href="#ArrayBuffer数组" class="headerlink" title="ArrayBuffer数组"></a>ArrayBuffer数组</h3><p>在Scala中，如果需要类似于Java中的ArrayList这种长度可变的集合类，则可以使用ArrayBuffer</p><p>如果不想每次都使用全限定名，则可以预先导入ArrayBuffer类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import scala.collection.mutable.ArrayBuffer</span><br></pre></td></tr></table></figure></p><p>使用ArrayBuffer()的方式可以创建一个空的ArrayBuffer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val b = ArrayBuffer[Int]()</span><br></pre></td></tr></table></figure></p><p>使用+=操作符，可以添加一个元素，或者多个元素<br>这个语法必须要谨记在心！因为Spark源码里大量使用了这种集合操作语法！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b+=1</span><br><span class="line">b+=(2,3,4,5)</span><br></pre></td></tr></table></figure></p><p>使用++=操作符，可以添加其他集合中的所有元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b++=Array(6,7,8,9,10)</span><br></pre></td></tr></table></figure></p><p>使用trimEnd()函数，可以从尾部截断指定个数的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.trimEnd(5)</span><br></pre></td></tr></table></figure></p><p>使用insert()函数可以在指定位置插入元素<br>但是这种操作效率较低，因为需要移动指定位置后的所有元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b.insert(5,6)</span><br><span class="line">b.insert(6,7,8,9,10)</span><br></pre></td></tr></table></figure></p><p>使用remove()函数可以移除指定位置的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b.remove(1)</span><br><span class="line">b.remove(1,3)</span><br></pre></td></tr></table></figure></p><p>Array与ArrayBuffer可以互相进行转换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b.toArray</span><br><span class="line">a.toBuffer</span><br></pre></td></tr></table></figure></p><h3 id="遍历Array和ArrayBuffer数组"><a href="#遍历Array和ArrayBuffer数组" class="headerlink" title="遍历Array和ArrayBuffer数组"></a>遍历Array和ArrayBuffer数组</h3><p>使用for循环和until遍历Array/ArrayBuffer<br>使until是RichInt提供的函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(i &lt;- 0 until b.length)</span><br><span class="line">println(b(i))</span><br></pre></td></tr></table></figure></p><p>跳跃遍历Array / ArrayBuffer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(i &lt;- 0 until (b.length,2))</span><br><span class="line"> println(b(i))</span><br></pre></td></tr></table></figure></p><p>从尾部遍历Array / ArrayBuffer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(i &lt;- (0 to b.length).reverse)</span><br><span class="line"> println(b(i))</span><br></pre></td></tr></table></figure></p><p>使用“增强for循环” 遍历Array/ArrayBuffer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for(e &lt;- b)</span><br><span class="line"> println(e)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Array数组&quot;&gt;&lt;a href=&quot;#Array数组&quot; class=&quot;headerlink&quot; title=&quot;Array数组&quot;&gt;&lt;/a&gt;Array数组&lt;/h3&gt;&lt;p&gt;在Scala中，Array代表的含义与Java类似，也是长度不可变的数组。此外，由于Scala与Java都是运行在JVM中，双方可以互相调用。因此，Scala数组的底层实际上是Java数组。例如，字符串数组在底层就是Java的String[],整数数组在底层就是Java的Int[]&lt;/p&gt;
&lt;p&gt;数组初始化后，长度就固定下来了，而且元素全部根据其类型初始化&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;val a = new Array[Int](10)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;val a = new Array[String](10)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Scala" scheme="http://yoursite.com/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Spark生态圈之Scala(一) ----- Scala中的函数</title>
    <link href="http://yoursite.com/2018/05/07/BigData-Scala1-1/"/>
    <id>http://yoursite.com/2018/05/07/BigData-Scala1-1/</id>
    <published>2018-05-07T07:39:13.000Z</published>
    <updated>2018-05-18T00:54:54.676Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Scala中的函数"><a href="#Scala中的函数" class="headerlink" title="Scala中的函数"></a>Scala中的函数</h3><h4 id="Scala定义函数"><a href="#Scala定义函数" class="headerlink" title="Scala定义函数"></a>Scala定义函数</h4><p>在Scala中定义函数时，需要定义函数的函数名、参数、函数体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def sayHello(name:String,age:Int):Int =</span><br><span class="line">&#123;</span><br><span class="line">  if(age&gt;18)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Hi,%s,you are a big boy!!!&quot;,name)</span><br><span class="line">  &#125;</span><br><span class="line">  else&#123;</span><br><span class="line">    prinf(&quot;Hi,%s,you are a children&quot;,name)</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>Scala要求必须给出所有参数的类型，但是不一定给出函数返回值的类型，只要右侧的函数体中不包含递归的语句，Scala就可以自己根据右侧的表达式推断出返回类型。</p><p>单行函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def sayHello(name:String):Unit = println(&quot;Hello&quot;+name)</span><br></pre></td></tr></table></figure></p><p>sum函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def sum(n:Int):Int=</span><br><span class="line">&#123;</span><br><span class="line">  var result = 0</span><br><span class="line">  for(i&lt;- 1 to n)</span><br><span class="line">  &#123;</span><br><span class="line">    result +=i</span><br><span class="line">  &#125;</span><br><span class="line">  result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>递归函数(斐波那契数列)：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def fab(n:Int):Int =</span><br><span class="line">&#123;</span><br><span class="line">  if(n&lt;=0) 1</span><br><span class="line">  else fab(n-1)+fab(n-2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Scala函数中的默认参数"><a href="#Scala函数中的默认参数" class="headerlink" title="Scala函数中的默认参数"></a>Scala函数中的默认参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def sayHello(FirstName:String,MiddleName:String=&quot;&quot;,LastName:String=&quot;&quot;):Unit =</span><br><span class="line">print(FirstName+&quot; &quot;+MiddleName+&quot; &quot;+LastName)</span><br></pre></td></tr></table></figure><p>Java与Scala实现默认参数的区别:</p><p>Java:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void sayHello(String name,int age)        </span><br><span class="line">&#123;                                                </span><br><span class="line">    if(name = null)                                </span><br><span class="line">   &#123;                                           </span><br><span class="line">      name = &quot;defaultName&quot;                        </span><br><span class="line">   &#125;</span><br><span class="line">   if(age ==0)</span><br><span class="line">    &#123;</span><br><span class="line">      age = 18</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Scala:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def sayHello(name:String,age:Int=20)</span><br><span class="line">&#123;</span><br><span class="line">    print(&quot;Hello,&quot;+name+&quot;, your age is &quot;+age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Scala函数中的带名参数"><a href="#Scala函数中的带名参数" class="headerlink" title="Scala函数中的带名参数"></a>Scala函数中的带名参数</h4><p>在调用函数时，也可以不按照函数定义的参数顺序来传递参数，而是使用带名参数的方式来传递<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sayHello(FirstName=&quot;Mick&quot;,LastName=&quot;Nina&quot;,MiddleName=&quot;jack&quot;)</span><br></pre></td></tr></table></figure></p><p>还可以混合使用未命名参数和带名参数，但是未命名参数必须排在带名参数前面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sayHello(&quot;Mick&quot;,LastName=&quot;Nina&quot;,MiddleName=&quot;Jack&quot;)</span><br></pre></td></tr></table></figure></p><h4 id="Scala函数中的变长参数"><a href="#Scala函数中的变长参数" class="headerlink" title="Scala函数中的变长参数"></a>Scala函数中的变长参数</h4><p>在Scala中，有时我们需要将函数定义为参数个数可变的形式，则此时可以使用变长参数定义函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def sum(nums : Int*)</span><br><span class="line">&#123;</span><br><span class="line">    var res = 0</span><br><span class="line">    for(num &lt;- nums)</span><br><span class="line">       res += num</span><br><span class="line">    res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用序列调用变长参数：</p><p>在如果想要将一个已有的序列直接调用变长参数函数，是不对的。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val s = sum(1 to 5)</span><br></pre></td></tr></table></figure></p><p>此时需要使用Scala特殊的语法将参数定义为序列，让Scala解释器能够识别。这种语法非常有用！一定要好好注意，在Spark的源码中大量地使用到了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val s = sum(1 to 5:_*)</span><br></pre></td></tr></table></figure></p><p>案例：使用递归函数实现累加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def sum2(nums:Int*):Int=</span><br><span class="line">&#123;</span><br><span class="line">    if(nums.length == 0) 0</span><br><span class="line">     else nums.head+sum2(nums.tail : _*)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Scala函数的过程、lazy值和异常"><a href="#Scala函数的过程、lazy值和异常" class="headerlink" title="Scala函数的过程、lazy值和异常"></a>Scala函数的过程、lazy值和异常</h4><p>1、过程:<br>  在Scala中，定义函数时，如果函数体直接包裹在了花括号里面，而没有使用=连接，则函数的返回值类型就是Unit。这样的函数就被称之为过程。过程通常用于不需要返回值的函数</p><p>  过程还有一种写法，就是将函数的返回值类型定义为Unit<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def sayHello(name:String) = &quot;Hello,&quot;+name</span><br><span class="line">def sayHello(name:String) &#123;print(&quot;Hello,&quot;+name);&quot;Hello,&quot;+name&#125;</span><br><span class="line">def sayHello(name:String):Unit = &quot;Hello,&quot;+name</span><br></pre></td></tr></table></figure></p><p>2、lazy值：<br>  在Scala中，提供了lazy值的特性，也就是说，如果将一个变量声明为lazy，则只有在第一次使用该变量时，变量对应的表达式才会发生计算。这种特性对于特别耗时的计算操作特别有用，比如打开文件进行IO，进行网络IO等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import scala.io.Source._</span><br><span class="line">lazy val lines = fromFile(&quot;C://Users//Administrator//Desktop//test.txt&quot;).mkString</span><br></pre></td></tr></table></figure><p>即使文件不存在，也不会报错，只有第一个使用变量时会报错，证明了表达式计算的lazy特性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val lines = fromFile(&quot;C://Users//Administrator//Desktop//test.txt&quot;).mkString</span><br><span class="line">lazy val lines = fromFile(&quot;C://Users//Administractor//Desktop//test.txt&quot;).mkString</span><br><span class="line">def lines = fromFile(&quot;C://Users//Administrator//Desktop//test.txt&quot;).mkString</span><br></pre></td></tr></table></figure></p><p>3、异常:<br>  在Scala中，异常处理和捕获机制与Java是非常相似的</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Scala中的函数&quot;&gt;&lt;a href=&quot;#Scala中的函数&quot; class=&quot;headerlink&quot; title=&quot;Scala中的函数&quot;&gt;&lt;/a&gt;Scala中的函数&lt;/h3&gt;&lt;h4 id=&quot;Scala定义函数&quot;&gt;&lt;a href=&quot;#Scala定义函数&quot; class=&quot;headerlink&quot; title=&quot;Scala定义函数&quot;&gt;&lt;/a&gt;Scala定义函数&lt;/h4&gt;&lt;p&gt;在Scala中定义函数时，需要定义函数的函数名、参数、函数体&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;def sayHello(name:String,age:Int):Int =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  if(age&amp;gt;18)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printf(&amp;quot;Hi,%s,you are a big boy!!!&amp;quot;,name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  else&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    prinf(&amp;quot;Hi,%s,you are a children&amp;quot;,name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    age&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Scala" scheme="http://yoursite.com/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>随笔(一)</title>
    <link href="http://yoursite.com/2018/05/02/jottings-%E4%B8%80/"/>
    <id>http://yoursite.com/2018/05/02/jottings-一/</id>
    <published>2018-05-02T00:36:33.000Z</published>
    <updated>2018-05-18T00:55:29.384Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/05/02/jottings-一/jottings-1.jpg" alt="jottings"><br><a id="more"></a><br><strong>或许世界不是你预期的模样<br>柴米油盐包裹着大胆的梦想<br>学会了成熟，一直保持善良<br>勇敢哭、用力笑、别逞强<br>不勉强追寻飞到多高的地方<br>只要你快乐才是唯一的真相<br>当你扮大人，扮到疲惫了<br>有个家让你做回孩子。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/05/02/jottings-一/jottings-1.jpg&quot; alt=&quot;jottings&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="thoughts" scheme="http://yoursite.com/categories/thoughts/"/>
    
    
      <category term="jottings" scheme="http://yoursite.com/tags/jottings/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop生态圈(二) ----- Kafka的使用(四)</title>
    <link href="http://yoursite.com/2018/04/28/BigData-Kafka-%E5%9B%9B/"/>
    <id>http://yoursite.com/2018/04/28/BigData-Kafka-四/</id>
    <published>2018-04-28T01:38:52.000Z</published>
    <updated>2018-05-02T00:49:17.070Z</updated>
    
    <content type="html"><![CDATA[<p>  <img src="/2018/04/28/BigData-Kafka-四/kafka6.png" alt="Kafka拦截器"><br><a id="more"></a></p><h3 id="Kafka-producer拦截器-interceptor"><a href="#Kafka-producer拦截器-interceptor" class="headerlink" title="Kafka producer拦截器(interceptor)"></a>Kafka producer拦截器(interceptor)</h3><h4 id="拦截器原理"><a href="#拦截器原理" class="headerlink" title="拦截器原理"></a>拦截器原理</h4><p>Producer拦截器(interceptor)是在Kafka 0.10版本被引入的，主要用于实现clients端的定制化控制逻辑。</p><p>　　对于producer而言，interceptor使得用户在消息发送前以及producer回调逻辑前有机会对消息做一些定制化需求，比如修改消息等。同时，producer允许用户指定多个interceptor按序作用于同一条消息从而形成一个拦截链(interceptor chain)。Intercetpor的实现接口是org.apache.kafka.clients.producer.ProducerInterceptor，其定义的方法包括：</p><p>  （1）onSend(ProducerRecord)：<br>  该方法封装进KafkaProducer.send方法中，即它运行在用户主线程中。Producer确保在消息被序列化以计算分区前调用该方法。用户可以在该方法中对消息做任何操作，但最好保证不要修改消息所属的topic和分区，否则会影响目标分区的计算</p><p>  （2）onAcknowledgement(RecordMetadata, Exception)：<br>  该方法会在消息被应答之前或消息发送失败时调用，并且通常都是在producer回调逻辑触发之前。onAcknowledgement运行在producer的IO线程中，因此不要在该方法中放入很重的逻辑，否则会拖慢producer的消息发送效率</p><p>  （3）close：<br>  关闭interceptor，主要用于执行一些资源清理工作</p><p>如前所述，interceptor可能被运行在多个线程中，因此在具体实现时用户需要自行确保线程安全。另外倘若指定了多个interceptor，则producer将按照指定顺序调用它们，并仅仅是捕获每个interceptor可能抛出的异常记录到错误日志中而非在向上传递。这在使用过程中要特别留意。</p><h4 id="拦截器案例"><a href="#拦截器案例" class="headerlink" title="拦截器案例"></a>拦截器案例</h4><p>  1）需求：<br>  实现一个简单的双interceptor组成的拦截链。第一个interceptor会在消息发送前将时间戳信息加到消息value的最前部；第二个interceptor会在消息发送后更新成功发送消息数或失败发送消息数。<br>  <img src="/2018/04/28/BigData-Kafka-四/kafka6.png" alt="Kafka拦截器"></p><p>  2）案例实操<br>    (1)增加时间戳拦截器<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">    package com.atguigu.kafka.interceptor;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import org.apache.kafka.clients.producer.ProducerInterceptor;</span><br><span class="line">import org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line">import org.apache.kafka.clients.producer.RecordMetadata;</span><br><span class="line"></span><br><span class="line">public class TimeInterceptor implements ProducerInterceptor&lt;String, String&gt; &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void configure(Map&lt;String, ?&gt; configs) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public ProducerRecord&lt;String, String&gt; onSend(ProducerRecord&lt;String, String&gt; record) &#123;</span><br><span class="line">// 创建一个新的record，把时间戳写入消息体的最前部</span><br><span class="line">return new ProducerRecord(record.topic(), record.partition(), record.timestamp(), record.key(),</span><br><span class="line">System.currentTimeMillis() + &quot;,&quot; + record.value().toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onAcknowledgement(RecordMetadata metadata, Exception exception) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void close() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（2）统计发送消息成功和发送失败消息数，并在producer关闭时打印这两个计数器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.kafka.interceptor;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import org.apache.kafka.clients.producer.ProducerInterceptor;</span><br><span class="line">import org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line">import org.apache.kafka.clients.producer.RecordMetadata;</span><br><span class="line"></span><br><span class="line">public class CounterInterceptor implements ProducerInterceptor&lt;String, String&gt;&#123;</span><br><span class="line">    private int errorCounter = 0;</span><br><span class="line">    private int successCounter = 0;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void configure(Map&lt;String, ?&gt; configs) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public ProducerRecord&lt;String, String&gt; onSend(ProducerRecord&lt;String, String&gt; record) &#123;</span><br><span class="line"> return record;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onAcknowledgement(RecordMetadata metadata, Exception exception) &#123;</span><br><span class="line">// 统计成功和失败的次数</span><br><span class="line">        if (exception == null) &#123;</span><br><span class="line">            successCounter++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            errorCounter++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void close() &#123;</span><br><span class="line">        // 保存结果</span><br><span class="line">        System.out.println(&quot;Successful sent: &quot; + successCounter);</span><br><span class="line">        System.out.println(&quot;Failed sent: &quot; + errorCounter);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>（3）producer主程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.kafka.interceptor;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Properties;</span><br><span class="line">import org.apache.kafka.clients.producer.KafkaProducer;</span><br><span class="line">import org.apache.kafka.clients.producer.Producer;</span><br><span class="line">import org.apache.kafka.clients.producer.ProducerConfig;</span><br><span class="line">import org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line"></span><br><span class="line">public class InterceptorProducer &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">// 1 设置配置信息</span><br><span class="line">Properties props = new Properties();</span><br><span class="line">props.put(&quot;bootstrap.servers&quot;, &quot;hadoop102:9092&quot;);</span><br><span class="line">props.put(&quot;acks&quot;, &quot;all&quot;);</span><br><span class="line">props.put(&quot;retries&quot;, 0);</span><br><span class="line">props.put(&quot;batch.size&quot;, 16384);</span><br><span class="line">props.put(&quot;linger.ms&quot;, 1);</span><br><span class="line">props.put(&quot;buffer.memory&quot;, 33554432);</span><br><span class="line">props.put(&quot;key.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);</span><br><span class="line">props.put(&quot;value.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);</span><br><span class="line"></span><br><span class="line">// 2 构建拦截链</span><br><span class="line">List&lt;String&gt; interceptors = new ArrayList&lt;&gt;();</span><br><span class="line">interceptors.add(&quot;com.atguigu.kafka.interceptor.TimeInterceptor&quot;); interceptors.add(&quot;com.atguigu.kafka.interceptor.CounterInterceptor&quot;);</span><br><span class="line">props.put(ProducerConfig.INTERCEPTOR_CLASSES_CONFIG, interceptors);</span><br><span class="line"></span><br><span class="line">String topic = &quot;first&quot;;</span><br><span class="line">Producer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line">// 3 发送消息</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line"></span><br><span class="line">    ProducerRecord&lt;String, String&gt; record = new ProducerRecord&lt;&gt;(topic, &quot;message&quot; + i);</span><br><span class="line">    producer.send(record).get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 4 一定要关闭producer，这样才会调用interceptor的close方法</span><br><span class="line">producer.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4）测试<br>（1）在kafka上启动消费者，然后运行客户端java程序。</p><blockquote><p>[atguigu@hadoop102 kafka]$ in/kafka-console-consumer.sh –zookeeper hadoop102:2181 –from-beginning –topic first<br>1501904047034,message0<br>1501904047225,message1<br>1501904047230,message2<br>1501904047234,message3<br>1501904047236,message4<br>1501904047240,message5<br>1501904047243,message6<br>1501904047246,message7<br>1501904047249,message8<br>1501904047252,message9</p></blockquote><p>（2）观察java平台控制台输出数据如下：</p><blockquote><p>Successful sent: 10<br>Failed sent: 0</p></blockquote><h3 id="Kafka-stream"><a href="#Kafka-stream" class="headerlink" title="Kafka stream"></a>Kafka stream</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>1) Kafka Stream<br>  Kafka Streams。Apache Kafka开源项目的一个组成部分。是一个功能强大，易于使用的库。用于在Kafka上构建高可分布式、拓展性，容错的应用程序。它建立在流处理的一系列重要功能基础之上，比如正确区分事件和处理时间，处理迟到数据以及高效的应用程序状态管理。</p><p>2)  Kafka Stream 特点<br>  ① 功能强大<br>  高拓展性，弹性，容错<br>  有状态和无状态处理<br>  基于事件时间的Window，Join，Aggergations<br>  ② 轻量级<br>  无需专门的集群<br>  一个库，而不是框架<br>  ③ 完全集成<br>  100%的Kafka 0.10.0版本兼容<br>  易于集成到现有的应用程序<br>  程序部署无需手工处理(这个指的应该是Kafka多分区机制对Kafka Streams多实例的自动匹配)<br>  ④ 实时性<br>  毫秒级延迟<br>  并非微批处理<br>  窗口允许乱序数据<br>  允许迟到数据</p><p>3) 为什么要有Kafka Stream<br>当前已经有非常多的流式处理系统，最知名且应用最多的开源流式处理系统有Spark Streaming和Apache Storm。Apache Storm发展多年，应用广泛，提供记录级别的处理能力，当前也支持SQL on Stream。而Spark Streaming基于Apache Spark，可以非常方便与图计算，SQL处理等集成，功能强大，对于熟悉其它Spark应用开发的用户而言使用门槛低。另外，目前主流的Hadoop发行版，如MapR，Cloudera和Hortonworks，都集成了Apache Storm和Apache Spark，使得部署更容易。<br>既然Apache Spark与Apache Storm拥用如此多的优势，那为何还需要Kafka Stream呢？笔者认为主要有如下原因。<br>  第一，Spark和Storm都是流式处理框架，而Kafka Stream提供的是一个基于Kafka的流式处理类库。框架要求开发者按照特定的方式去开发逻辑部分，供框架调用。开发者很难了解框架的具体运行方式，从而使得调试成本高，并且使用受限。而Kafka Stream作为流式处理类库，直接提供具体的类给开发者调用，整个应用的运行方式主要由开发者控制，方便使用和调试。<br>  第二，虽然Cloudera与Hortonworks方便了Storm和Spark的部署，但是这些框架的部署仍然相对复杂。而Kafka Stream作为类库，可以非常方便的嵌入应用程序中，它对应用的打包和部署基本没有任何要求。更为重要的是，Kafka Stream充分利用了Kafka的分区机制和Consumer的Rebalance机制，使得Kafka Stream可以非常方便的水平扩展，并且各个实例可以使用不同的部署方式。具体来说，每个运行Kafka Stream的应用程序实例都包含了Kafka Consumer实例，多个同一应用的实例之间并行处理数据集。而不同实例之间的部署方式并不要求一致，比如部分实例可以运行在Web容器中，部分实例可运行在Docker或Kubernetes中。<br>  第三，就流式处理系统而言，基本都支持Kafka作为数据源。例如Storm具有专门的kafka-spout，而Spark也提供专门的spark-streaming-kafka模块。事实上，Kafka基本上是主流的流式处理系统的标准数据源。换言之，大部分流式系统中都已部署了Kafka，此时使用Kafka Stream的成本非常低。<br>  第四，使用Storm或Spark Streaming时，需要为框架本身的进程预留资源，如Storm的supervisor和Spark on YARN的node manager。即使对于应用实例而言，框架本身也会占用部分资源，如Spark Streaming需要为shuffle和storage预留内存。<br>  第五，由于Kafka本身提供数据持久化，因此Kafka Stream提供滚动部署和滚动升级以及重新计算的能力。<br>  第六，由于Kafka Consumer Rebalance机制，Kafka Stream可以在线动态调整并行度。</p><h4 id="Kafka-Stream案例"><a href="#Kafka-Stream案例" class="headerlink" title="Kafka Stream案例"></a>Kafka Stream案例</h4><p>  去除单词前缀“&gt;&gt;&gt;”案例<br>  0）需求：<br>    实时处理单词带有”&gt;&gt;&gt;”前缀的内容。例如输入”atguigu&gt;&gt;&gt;jingjing”，最终处理成“jingjing”</p><p>  1）创建主类<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">  package com.atguigu.kafka.stream;</span><br><span class="line">import java.util.Properties;</span><br><span class="line">import org.apache.kafka.streams.KafkaStreams;</span><br><span class="line">import org.apache.kafka.streams.StreamsConfig;</span><br><span class="line">import org.apache.kafka.streams.processor.Processor;</span><br><span class="line">import org.apache.kafka.streams.processor.ProcessorSupplier;</span><br><span class="line">import org.apache.kafka.streams.processor.TopologyBuilder;</span><br><span class="line"></span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">// 定义输入的topic</span><br><span class="line">        String from = &quot;first&quot;;</span><br><span class="line">        // 定义输出的topic</span><br><span class="line">        String to = &quot;second&quot;;</span><br><span class="line"></span><br><span class="line">        // 设置参数</span><br><span class="line">        Properties settings = new Properties();</span><br><span class="line">        settings.put(StreamsConfig.APPLICATION_ID_CONFIG, &quot;logFilter&quot;);</span><br><span class="line">        settings.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;hadoop102:9092&quot;);</span><br><span class="line"></span><br><span class="line">        StreamsConfig config = new StreamsConfig(settings);</span><br><span class="line"></span><br><span class="line">        // 构建拓扑</span><br><span class="line">        TopologyBuilder builder = new TopologyBuilder();</span><br><span class="line"></span><br><span class="line">        builder.addSource(&quot;SOURCE&quot;, from)</span><br><span class="line">               .addProcessor(&quot;PROCESS&quot;, new ProcessorSupplier&lt;byte[], byte[]&gt;() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Processor&lt;byte[], byte[]&gt; get() &#123;</span><br><span class="line">// 具体分析处理</span><br><span class="line">return new LogProcessor();</span><br><span class="line">&#125;</span><br><span class="line">&#125;, &quot;SOURCE&quot;)</span><br><span class="line">                .addSink(&quot;SINK&quot;, to, &quot;PROCESS&quot;);</span><br><span class="line"></span><br><span class="line">        // 创建kafka stream</span><br><span class="line">        KafkaStreams streams = new KafkaStreams(builder, config);</span><br><span class="line">        streams.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  2)具体业务处理<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  package com.atguigu.kafka.stream;</span><br><span class="line">import org.apache.kafka.streams.processor.Processor;</span><br><span class="line">import org.apache.kafka.streams.processor.ProcessorContext;</span><br><span class="line"></span><br><span class="line">public class LogProcessor implements Processor&lt;byte[], byte[]&gt; &#123;</span><br><span class="line"></span><br><span class="line">private ProcessorContext context;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void init(ProcessorContext context) &#123;</span><br><span class="line">this.context = context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void process(byte[] key, byte[] value) &#123;</span><br><span class="line">String input = new String(value);</span><br><span class="line"></span><br><span class="line">// 如果包含“&gt;&gt;&gt;”则只保留该标记后面的内容</span><br><span class="line">if (input.contains(&quot;&gt;&gt;&gt;&quot;)) &#123;</span><br><span class="line">input = input.split(&quot;&gt;&gt;&gt;&quot;)[1].trim();</span><br><span class="line">// 输出到下一个topic</span><br><span class="line">context.forward(&quot;logProcessor&quot;.getBytes(), input.getBytes());</span><br><span class="line">&#125;else&#123;</span><br><span class="line">context.forward(&quot;logProcessor&quot;.getBytes(), input.getBytes());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void punctuate(long timestamp) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void close() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3）将程序用eclipse插件打成jar包</p><p>4）将jar包拷贝hadoop102上运行</p><blockquote><p>[atguigu@hadoop102 kafka]$ java -jar kafka0508_fat.jar com.atguigu.kafka.stream.Application</p></blockquote><p>5）在hadoop104上启动生产者</p><blockquote><p>[atguigu@hadoop104 kafka]$ bin/kafka-console-producer.sh –broker-list hadoop102:9092 –topic first<br>$&gt;hello&gt;&gt;&gt;world<br>$&gt;h&gt;&gt;&gt;atguigu<br>$&gt;hahaha</p></blockquote><p>6）在hadoop103山启动消费者</p><blockquote><p>[atguigu@hadoop103 kafka]$ bin/kafka-console-consumer.sh –zookeeper hadoop102:2181 –from-beginning –topic second<br>world<br>atguigu<br>hahaha</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  &lt;img src=&quot;/2018/04/28/BigData-Kafka-四/kafka6.png&quot; alt=&quot;Kafka拦截器&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Kafka" scheme="http://yoursite.com/categories/Kafka/"/>
    
    
      <category term="Kafka" scheme="http://yoursite.com/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop生态圈(二) ----- Kafka的使用(三)</title>
    <link href="http://yoursite.com/2018/04/28/BigData-Kafka-%E4%B8%89/"/>
    <id>http://yoursite.com/2018/04/28/BigData-Kafka-三/</id>
    <published>2018-04-28T01:24:46.000Z</published>
    <updated>2018-05-02T00:49:13.314Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Kafka-API操作"><a href="#Kafka-API操作" class="headerlink" title="Kafka API操作"></a>Kafka API操作</h3><h4 id="创建生产者"><a href="#创建生产者" class="headerlink" title="创建生产者"></a>创建生产者</h4><p>过时的API:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.kafka;</span><br><span class="line">import java.util.Properties;</span><br><span class="line">import kafka.javaapi.producer.Producer;</span><br><span class="line">import kafka.producer.KeyedMessage;</span><br><span class="line">import kafka.producer.ProducerConfig;</span><br><span class="line"></span><br><span class="line">public class OldProducer &#123;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Properties properties = new Properties();</span><br><span class="line">properties.put(&quot;metadata.broker.list&quot;, &quot;hadoop102:9092&quot;);</span><br><span class="line">properties.put(&quot;request.required.acks&quot;, &quot;1&quot;);</span><br><span class="line">properties.put(&quot;serializer.class&quot;, &quot;kafka.serializer.StringEncoder&quot;);</span><br><span class="line"></span><br><span class="line">Producer&lt;Integer, String&gt; producer = new Producer&lt;Integer,String&gt;(new ProducerConfig(properties));</span><br><span class="line"></span><br><span class="line">KeyedMessage&lt;Integer, String&gt; message = new KeyedMessage&lt;Integer, String&gt;(&quot;first&quot;, &quot;hello world&quot;);</span><br><span class="line">producer.send(message );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>新的API:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.kafka;</span><br><span class="line">import java.util.Properties;</span><br><span class="line">import org.apache.kafka.clients.producer.KafkaProducer;</span><br><span class="line">import org.apache.kafka.clients.producer.Producer;</span><br><span class="line">import org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line"></span><br><span class="line">public class NewProducer &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Properties props = new Properties();</span><br><span class="line">// Kafka服务端的主机名和端口号</span><br><span class="line">props.put(&quot;bootstrap.servers&quot;, &quot;hadoop103:9092&quot;);</span><br><span class="line">// 等待所有副本节点的应答</span><br><span class="line">props.put(&quot;acks&quot;, &quot;all&quot;);</span><br><span class="line">// 消息发送最大尝试次数</span><br><span class="line">props.put(&quot;retries&quot;, 0);</span><br><span class="line">// 一批消息处理大小</span><br><span class="line">props.put(&quot;batch.size&quot;, 16384);</span><br><span class="line">// 请求延时</span><br><span class="line">props.put(&quot;linger.ms&quot;, 1);</span><br><span class="line">// 发送缓存区内存大小</span><br><span class="line">props.put(&quot;buffer.memory&quot;, 33554432);</span><br><span class="line">// key序列化</span><br><span class="line">props.put(&quot;key.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);</span><br><span class="line">// value序列化</span><br><span class="line">props.put(&quot;value.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);</span><br><span class="line"></span><br><span class="line">Producer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(props);</span><br><span class="line">for (int i = 0; i &lt; 50; i++) &#123;</span><br><span class="line">producer.send(new ProducerRecord&lt;String, String&gt;(&quot;first&quot;, Integer.toString(i), &quot;hello world-&quot; + i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">producer.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="创建生产者带回调函数"><a href="#创建生产者带回调函数" class="headerlink" title="创建生产者带回调函数"></a>创建生产者带回调函数</h4><p>新API:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.kafka;</span><br><span class="line">import java.util.Properties;</span><br><span class="line">import org.apache.kafka.clients.producer.Callback;</span><br><span class="line">import org.apache.kafka.clients.producer.KafkaProducer;</span><br><span class="line">import org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line">import org.apache.kafka.clients.producer.RecordMetadata;</span><br><span class="line"></span><br><span class="line">public class CallBackProducer &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Properties props = new Properties();</span><br><span class="line">// Kafka服务端的主机名和端口号</span><br><span class="line">props.put(&quot;bootstrap.servers&quot;, &quot;hadoop103:9092&quot;);</span><br><span class="line">// 等待所有副本节点的应答</span><br><span class="line">props.put(&quot;acks&quot;, &quot;all&quot;);</span><br><span class="line">// 消息发送最大尝试次数</span><br><span class="line">props.put(&quot;retries&quot;, 0);</span><br><span class="line">// 一批消息处理大小</span><br><span class="line">props.put(&quot;batch.size&quot;, 16384);</span><br><span class="line">// 增加服务端请求延时</span><br><span class="line">props.put(&quot;linger.ms&quot;, 1);</span><br><span class="line">// 发送缓存区内存大小</span><br><span class="line">props.put(&quot;buffer.memory&quot;, 33554432);</span><br><span class="line">// key序列化</span><br><span class="line">props.put(&quot;key.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);</span><br><span class="line">// value序列化</span><br><span class="line">props.put(&quot;value.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);</span><br><span class="line"></span><br><span class="line">KafkaProducer&lt;String, String&gt; kafkaProducer = new KafkaProducer&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line">for (int i = 0; i &lt; 50; i++) &#123;</span><br><span class="line"></span><br><span class="line">kafkaProducer.send(new ProducerRecord&lt;String, String&gt;(&quot;first&quot;, &quot;hello&quot; + i), new Callback() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onCompletion(RecordMetadata metadata, Exception exception) &#123;</span><br><span class="line"></span><br><span class="line">if (metadata != null) &#123;</span><br><span class="line"></span><br><span class="line">System.err.println(metadata.partition() + &quot;---&quot; + metadata.offset());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kafkaProducer.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="自定义分区生产者"><a href="#自定义分区生产者" class="headerlink" title="自定义分区生产者"></a>自定义分区生产者</h4><p>  0) 需求:将所有数据存储到topic的第0将所有数据存储到topic的第0号分区上</p><p>  1) 定义一个类实现Partitioner接口，重写里面的方法(过时API)<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  package com.atguigu.kafka;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import kafka.producer.Partitioner;</span><br><span class="line"></span><br><span class="line">public class CustomPartitioner implements Partitioner &#123;</span><br><span class="line"></span><br><span class="line">public CustomPartitioner() &#123;</span><br><span class="line">super();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int partition(Object key, int numPartitions) &#123;</span><br><span class="line">// 控制分区</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  2) 自定义分区(新API)<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  package com.atguigu.kafka;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import org.apache.kafka.clients.producer.Partitioner;</span><br><span class="line">import org.apache.kafka.common.Cluster;</span><br><span class="line"></span><br><span class="line">public class CustomPartitioner implements Partitioner &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void configure(Map&lt;String, ?&gt; configs) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster) &#123;</span><br><span class="line">        // 控制分区</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void close() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  3) 在代码中调用<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  package com.atguigu.kafka;</span><br><span class="line">import java.util.Properties;</span><br><span class="line">import org.apache.kafka.clients.producer.KafkaProducer;</span><br><span class="line">import org.apache.kafka.clients.producer.Producer;</span><br><span class="line">import org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line"></span><br><span class="line">public class PartitionerProducer &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Properties props = new Properties();</span><br><span class="line">// Kafka服务端的主机名和端口号</span><br><span class="line">props.put(&quot;bootstrap.servers&quot;, &quot;hadoop103:9092&quot;);</span><br><span class="line">// 等待所有副本节点的应答</span><br><span class="line">props.put(&quot;acks&quot;, &quot;all&quot;);</span><br><span class="line">// 消息发送最大尝试次数</span><br><span class="line">props.put(&quot;retries&quot;, 0);</span><br><span class="line">// 一批消息处理大小</span><br><span class="line">props.put(&quot;batch.size&quot;, 16384);</span><br><span class="line">// 增加服务端请求延时</span><br><span class="line">props.put(&quot;linger.ms&quot;, 1);</span><br><span class="line">// 发送缓存区内存大小</span><br><span class="line">props.put(&quot;buffer.memory&quot;, 33554432);</span><br><span class="line">// key序列化</span><br><span class="line">props.put(&quot;key.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);</span><br><span class="line">// value序列化</span><br><span class="line">props.put(&quot;value.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);</span><br><span class="line">// 自定义分区</span><br><span class="line">props.put(&quot;partitioner.class&quot;, &quot;com.atguigu.kafka.CustomPartitioner&quot;);</span><br><span class="line"></span><br><span class="line">Producer&lt;String, String&gt; producer = new KafkaProducer&lt;&gt;(props);</span><br><span class="line">producer.send(new ProducerRecord&lt;String, String&gt;(&quot;first&quot;, &quot;1&quot;, &quot;atguigu&quot;));</span><br><span class="line"></span><br><span class="line">producer.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  4) 测试<br>  （1）在hadoop102上监控/opt/module/kafka/logs/目录下first主题3个分区的log日志动态变化情况</p><blockquote><p>[atguigu@hadoop102 first-0]$ tail -f 00000000000000000000.log<br>  [atguigu@hadoop102 first-1]$ tail -f 00000000000000000000.log<br>  [atguigu@hadoop102 first-2]$ tail -f 00000000000000000000.log</p></blockquote><p>  （2）发现数据都存储到指定的分区了。</p><h4 id="Kafka-消费者API"><a href="#Kafka-消费者API" class="headerlink" title="Kafka 消费者API"></a>Kafka 消费者API</h4><p>0）在控制台创建发送者</p><blockquote><p>[atguigu@hadoop104 kafka]$ bin/kafka-console-producer.sh –broker-list hadoop102:9092 –topic first<br>$&gt;hello world</p></blockquote><p>1）创建消费者（过时API）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.kafka.consume;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Properties;</span><br><span class="line">import kafka.consumer.Consumer;</span><br><span class="line">import kafka.consumer.ConsumerConfig;</span><br><span class="line">import kafka.consumer.ConsumerIterator;</span><br><span class="line">import kafka.consumer.KafkaStream;</span><br><span class="line">import kafka.javaapi.consumer.ConsumerConnector;</span><br><span class="line"></span><br><span class="line">public class CustomConsumer &#123;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Properties properties = new Properties();</span><br><span class="line"></span><br><span class="line">properties.put(&quot;zookeeper.connect&quot;, &quot;hadoop102:2181&quot;);</span><br><span class="line">properties.put(&quot;group.id&quot;, &quot;g1&quot;);</span><br><span class="line">properties.put(&quot;zookeeper.session.timeout.ms&quot;, &quot;500&quot;);</span><br><span class="line">properties.put(&quot;zookeeper.sync.time.ms&quot;, &quot;250&quot;);</span><br><span class="line">properties.put(&quot;auto.commit.interval.ms&quot;, &quot;1000&quot;);</span><br><span class="line"></span><br><span class="line">// 创建消费者连接器</span><br><span class="line">ConsumerConnector consumer = Consumer.createJavaConsumerConnector(new ConsumerConfig(properties));</span><br><span class="line"></span><br><span class="line">HashMap&lt;String, Integer&gt; topicCount = new HashMap&lt;&gt;();</span><br><span class="line">topicCount.put(&quot;first&quot;, 1);</span><br><span class="line"></span><br><span class="line">Map&lt;String, List&lt;KafkaStream&lt;byte[], byte[]&gt;&gt;&gt; consumerMap = consumer.createMessageStreams(topicCount);</span><br><span class="line"></span><br><span class="line">KafkaStream&lt;byte[], byte[]&gt; stream = consumerMap.get(&quot;first&quot;).get(0);</span><br><span class="line"></span><br><span class="line">ConsumerIterator&lt;byte[], byte[]&gt; it = stream.iterator();</span><br><span class="line"></span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">System.out.println(new String(it.next().message()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2）官方提供案例（自动维护消费情况）（新API）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.kafka.consume;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Properties;</span><br><span class="line">import org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line">import org.apache.kafka.clients.consumer.ConsumerRecords;</span><br><span class="line">import org.apache.kafka.clients.consumer.KafkaConsumer;</span><br><span class="line"></span><br><span class="line">public class CustomNewConsumer &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">Properties props = new Properties();</span><br><span class="line">// 定义kakfa 服务的地址，不需要将所有broker指定上</span><br><span class="line">props.put(&quot;bootstrap.servers&quot;, &quot;hadoop102:9092&quot;);</span><br><span class="line">// 制定consumer group</span><br><span class="line">props.put(&quot;group.id&quot;, &quot;test&quot;);</span><br><span class="line">// 是否自动确认offset</span><br><span class="line">props.put(&quot;enable.auto.commit&quot;, &quot;true&quot;);</span><br><span class="line">// 自动确认offset的时间间隔</span><br><span class="line">props.put(&quot;auto.commit.interval.ms&quot;, &quot;1000&quot;);</span><br><span class="line">// key的序列化类</span><br><span class="line">props.put(&quot;key.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class="line">// value的序列化类</span><br><span class="line">props.put(&quot;value.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class="line">// 定义consumer</span><br><span class="line">KafkaConsumer&lt;String, String&gt; consumer = new KafkaConsumer&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line">// 消费者订阅的topic, 可同时订阅多个</span><br><span class="line">consumer.subscribe(Arrays.asList(&quot;first&quot;, &quot;second&quot;,&quot;third&quot;));</span><br><span class="line"></span><br><span class="line">while (true) &#123;</span><br><span class="line">// 读取数据，读取超时时间为100ms</span><br><span class="line">ConsumerRecords&lt;String, String&gt; records = consumer.poll(100);</span><br><span class="line"></span><br><span class="line">for (ConsumerRecord&lt;String, String&gt; record : records)</span><br><span class="line">System.out.printf(&quot;offset = %d, key = %s, value = %s%n&quot;, record.offset(), record.key(), record.value());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Kafka-API操作&quot;&gt;&lt;a href=&quot;#Kafka-API操作&quot; class=&quot;headerlink&quot; title=&quot;Kafka API操作&quot;&gt;&lt;/a&gt;Kafka API操作&lt;/h3&gt;&lt;h4 id=&quot;创建生产者&quot;&gt;&lt;a href=&quot;#创建生产者&quot; class=&quot;headerlink&quot; title=&quot;创建生产者&quot;&gt;&lt;/a&gt;创建生产者&lt;/h4&gt;&lt;p&gt;过时的API:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;package com.atguigu.kafka;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import java.util.Properties;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import kafka.javaapi.producer.Producer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import kafka.producer.KeyedMessage;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import kafka.producer.ProducerConfig;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public class OldProducer &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	@SuppressWarnings(&amp;quot;deprecation&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	public static void main(String[] args) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Properties properties = new Properties();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		properties.put(&amp;quot;metadata.broker.list&amp;quot;, &amp;quot;hadoop102:9092&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		properties.put(&amp;quot;request.required.acks&amp;quot;, &amp;quot;1&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		properties.put(&amp;quot;serializer.class&amp;quot;, &amp;quot;kafka.serializer.StringEncoder&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Producer&amp;lt;Integer, String&amp;gt; producer = new Producer&amp;lt;Integer,String&amp;gt;(new ProducerConfig(properties));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		KeyedMessage&amp;lt;Integer, String&amp;gt; message = new KeyedMessage&amp;lt;Integer, String&amp;gt;(&amp;quot;first&amp;quot;, &amp;quot;hello world&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		producer.send(message );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Kafka" scheme="http://yoursite.com/categories/Kafka/"/>
    
    
      <category term="Kafka" scheme="http://yoursite.com/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop生态圈(二) ----- Kafka的使用(二)</title>
    <link href="http://yoursite.com/2018/04/28/BigData-Kafka-%E4%BA%8C/"/>
    <id>http://yoursite.com/2018/04/28/BigData-Kafka-二/</id>
    <published>2018-04-28T00:40:48.000Z</published>
    <updated>2018-05-02T00:49:14.870Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/04/28/BigData-Kafka-二/kafka1.png" alt="Kafka内部实现原理"><br><a id="more"></a></p><h3 id="Kafka工作流程分析"><a href="#Kafka工作流程分析" class="headerlink" title="Kafka工作流程分析"></a>Kafka工作流程分析</h3><hr><h4 id="Kafka生产过程分析"><a href="#Kafka生产过程分析" class="headerlink" title="Kafka生产过程分析"></a>Kafka生产过程分析</h4><p>  1) 写入方式<br>  producer采用推（push）模式将消息发布到broker，每条消息都被追加（append）到分区（patition）中，属于顺序写磁盘（顺序写磁盘效率比随机写内存要高，保障kafka吞吐率）。</p><p>  2) 分区<br>  消息发送时都被发送到一个topic，其本质就是一个目录，而topic是由一些Partition Logs(分区日志)组成，其组织结构如下图所示：<br>  <img src="/2018/04/28/BigData-Kafka-二/kafka2.png" alt="分区"></p><p>  <img src="/2018/04/28/BigData-Kafka-二/kafka3.png" alt="分区"><br>  我们可以看到，每个Partition中的消息都是有序的，生产的消息被不断追加到Partition log上，其中的每一个消息都被赋予了一个唯一的offset值。</p><p>  ① 分区的原因<br>  （1）方便在集群中扩展，每个Partition可以通过调整以适应它所在的机器，而一个topic又可以有多个Partition组成，因此整个集群就可以适应任意大小的数据了；<br>  （2）可以提高并发，因为可以以Partition为单位读写了。</p><p>  ② 分区的原则<br>  （1）指定了patition，则直接使用；<br>  （2）未指定patition但指定key，通过对key的value进行hash出一个patition</p><p>  ③ patition和key都未指定，使用轮询选出一个patition。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">DefaultPartitioner类</span><br><span class="line">public int partition(String topic, Object key, byte[] keyBytes, Object value, byte[] valueBytes, Cluster cluster)</span><br><span class="line">&#123;</span><br><span class="line">      List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line">      int numPartitions = partitions.size();</span><br><span class="line">      if (keyBytes == null) &#123;</span><br><span class="line">          int nextValue = nextValue(topic);</span><br><span class="line">          List&lt;PartitionInfo&gt; availablePartitions = cluster.availablePartitionsForTopic(topic);</span><br><span class="line">          if (availablePartitions.size() &gt; 0) &#123;</span><br><span class="line">              int part = Utils.toPositive(nextValue) % availablePartitions.size();</span><br><span class="line">              return availablePartitions.get(part).partition();</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              // no partitions are available, give a non-available partition</span><br><span class="line">              return Utils.toPositive(nextValue) % numPartitions;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          // hash the keyBytes to choose a partition</span><br><span class="line">          return Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>  3) 副本<br>  同一个partition可能会有多个replication（对应 server.properties 配置中的 default.replication.factor=N）。没有replication的情况下，一旦broker 宕机，其上所有 patition 的数据都不可被消费，同时producer也不能再将数据存于其上的patition。引入replication之后，同一个partition可能会有多个replication，而这时需要在这些replication之间选出一个leader，producer和consumer只与这个leader交互，其它replication作为follower从leader 中复制数据。</p><p>  4) 写入流程<br>   producer写入消息流程如下：</p><p>  <img src="/2018/04/28/BigData-Kafka-二/kafka4.png" alt="写入流程"></p><p>  ① producer先从zookeeper的 “/brokers/…/state”节点找到该partition的leader<br>  ② producer将消息发送给该leader<br>  ③ leader将消息写入本地log<br>  ④ followers从leader pull消息，写入本地log后向leader发送ACK<br>  ⑤ leader收到所有ISR中的replication的ACK后，增加HW（high watermark，最后commit 的offset）并向producer发送ACK</p><h4 id="broker保存消息"><a href="#broker保存消息" class="headerlink" title="broker保存消息"></a>broker保存消息</h4><p>  1)存储方式<br>  物理上把topic分成一个或多个partition（对应 server.properties 中的num.partitions=3配置），每个patition物理上对应一个文件夹（该文件夹存储该patition的所有消息和索引文件)</p><p>  2)存储策略<br>  无论消息是否被消费，kafka都会保留所有消息。有两种策略可以删除旧数据：<br>  1）基于时间：log.retention.hours=168<br>  2）基于大小：log.retention.bytes=1073741824<br>  需要注意的是，因为Kafka读取特定消息的时间复杂度为O(1)，即与文件大小无关，所以这里删除过期文件与提高 Kafka 性能无关。</p><p>  3)Zookeeper存储结构<br><img src="/2018/04/28/BigData-Kafka-二/zookeeper.png" alt="写入流程"><br>注意：producer不在zk中注册，消费者在zk中注册。</p><h4 id="Kafka消费过程分析"><a href="#Kafka消费过程分析" class="headerlink" title="Kafka消费过程分析"></a>Kafka消费过程分析</h4><p>kafka提供了两套consumer API：高级Consumer API和低级API。<br>1) 高级API<br>  (1)高级API优点<br>  高级API 写起来简单不需要去自行去管理offset，系统通过zookeeper自行管理不需要管理分区，副本等情况，系统自动管理消费者断线会自动根据上一次记录在zookeeper中的offset去接着获取数据（默认设置1分钟更新一下zookeeper中存的的offset）可以使用group来区分对同一个topic 的不同程序访问分离开来（不同的group记录不同的offset，这样不同程序读取同一个topic才不会因为offset互相影响）<br>  (2)高级API缺点<br>  不能自行控制offset（对于某些特殊需求来说）<br>  不能细化控制如分区、副本、zk等</p><p>2) 低级API<br>  (1)低级API优点<br>  能够开发者自己控制offset，想从哪里读取就从哪里读取。自行控制连接分区，对分区自定义进行负载均衡对zookeeper的依赖性降低（如：offset不一定非要靠zk存储，自行存储offset即可，比如存在文件或者内存中）<br>  (2)低级API缺点<br>  太过复杂，需要自行控制offset，连接哪个分区，找到分区leader 等。</p><p>3) 消费者组<br><img src="/2018/04/28/BigData-Kafka-二/kafka5.png" alt="消费者组"><br>  消费者是以consumer group消费者组的方式工作，由一个或者多个消费者组成一个组，共同消费一个topic。每个分区在同一时间只能由group中的一个消费者读取，但是多个group可以同时消费这个partition。在图中，有一个由三个消费者组成的grouop，有一个消费者读取主题中的两个分区，另外两个分别读取一个分区。某个消费者读取某个分区，也可以叫做某个消费者是某个分区的拥有者。在这种情况下，消费者可以通过水平扩展的方式同时读取大量的消息。另外，如果一个消费者失败了，那么其他的group成员会自动负载均衡读取之前失败的消费者读取的分区。</p><p>4) 消费方式<br><strong>consumer采用pull（拉）模式从broker中读取数据。</strong><br>push（推）模式很难适应消费速率不同的消费者，因为消息发送速率是由broker决定的。它的目标是尽可能以最快速度传递消息，但是这样很容易造成consumer来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而pull模式则可以根据consumer的消费能力以适当的速率消费消息。<br>对于Kafka而言，pull模式更合适，它可简化broker的设计，consumer可自主控制消费消息的速率，同时consumer可以自己控制消费方式——即可批量消费也可逐条消费，同时还能选择不同的提交方式从而实现不同的传输语义。</p><p>5) 消费者组案例<br>(1)需求：测试同一个消费者组中的消费者，同一时刻只能有一个消费者消费。<br>(2)案例实操<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">① 在hadoop102、hadoop103上修改/opt/module/kafka/config/consumer.properties配置文件中的group.id属性为任意组名。</span><br><span class="line">[atguigu@hadoop103 config]$ vi consumer.properties group.id=atguigu</span><br><span class="line">② 在hadoop102、hadoop103上分别启动消费者</span><br><span class="line">[atguigu@hadoop102 kafka]$ bin/kafka-console-consumer.sh --zookeeper hadoop102:2181 --topic first --consumer.config config/consumer.properties</span><br><span class="line">[atguigu@hadoop103 kafka]$ bin/kafka-console-consumer.sh --zookeeper hadoop102:2181 --topic first --consumer.config config/consumer.properties</span><br><span class="line">③ 在hadoop104上启动生产者</span><br><span class="line">[atguigu@hadoop104 kafka]$ bin/kafka-console-producer.sh --broker-list hadoop102:9092 --topic first</span><br><span class="line">hello world</span><br><span class="line">④ 查看hadoop102和hadoop103的接收者。同一时刻只有一个消费者接收到消息。</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/04/28/BigData-Kafka-二/kafka1.png&quot; alt=&quot;Kafka内部实现原理&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Kafka" scheme="http://yoursite.com/categories/Kafka/"/>
    
    
      <category term="Kafka" scheme="http://yoursite.com/tags/Kafka/"/>
    
  </entry>
  
</feed>
