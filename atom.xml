<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>空落单行雨</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-21T12:44:43.210Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Kongluo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>随笔(四)</title>
    <link href="http://yoursite.com/2018/06/21/jottings-4/"/>
    <id>http://yoursite.com/2018/06/21/jottings-4/</id>
    <published>2018-06-21T11:24:29.000Z</published>
    <updated>2018-06-21T12:44:43.210Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/06/21/jottings-4/jottings-4.1.jpg" alt="jottings"><br><a id="more"></a></p><center><br><font face="STZhongsong " size="4" color="Brown">如果冬天有什么可以期待的话<br>糖炒栗子算一个<br>烤红薯算一个<br>还有毛线帽、围巾<br>对了，还有糖葫芦<br>当然这些都抵不上那个冬天星星很亮的夜晚<br><br><img src="/2018/06/21/jottings-4/jottings-4.2.jpg" alt="jottings"><br>我们一起坐在赭山公园的长凳上，聊天<br>你说你笑点低，而我在一直想办法逗你笑<br><br>我讨厌热闹也不喜欢孤独，我总是熬夜<br>会一个人听歌，想自己做个的事<br>我没有面包，也没有清酒<br>我只想做天上明亮的星星伴你前行……</font><br></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/06/21/jottings-4/jottings-4.1.jpg&quot; alt=&quot;jottings&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="thoughts" scheme="http://yoursite.com/categories/thoughts/"/>
    
    
      <category term="jottings" scheme="http://yoursite.com/tags/jottings/"/>
    
  </entry>
  
  <entry>
    <title>Spark生态圈之Spark(七) ----- 常用的Action</title>
    <link href="http://yoursite.com/2018/06/05/BigData-Spark7/"/>
    <id>http://yoursite.com/2018/06/05/BigData-Spark7/</id>
    <published>2018-06-05T12:04:18.000Z</published>
    <updated>2018-06-05T12:45:50.933Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用action介绍"><a href="#常用action介绍" class="headerlink" title="常用action介绍"></a>常用action介绍</h3><style>table th:nth-of-type(1){width: 20%;}table th:nth-of-type(2){width: 80%;}</style><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">介绍</th></tr></thead><tbody><tr><td style="text-align:center">reduce</td><td style="text-align:center">通过func函数聚集RDD中的所有元素</td></tr><tr><td style="text-align:center">collect</td><td style="text-align:center">在驱动程序中，以数组的形式返回数据集的所有元素</td></tr><tr><td style="text-align:center">count</td><td style="text-align:center">返回RDD中的元素个数</td></tr><tr><td style="text-align:center">take</td><td style="text-align:center">返回RDD中的前n个元素</td></tr><tr><td style="text-align:center">saveAsTextFile</td><td style="text-align:center">将RDD以文本文件的方式保存到本地或者HDFS中</td></tr><tr><td style="text-align:center">countByKey</td><td style="text-align:center">针对(K,V)类型的RDD，返回一个(K,Int)的map，表示每一个key对应的元素个数。</td></tr></tbody></table><a id="more"></a><style>table th:nth-of-type(1){width: 20%;}table th:nth-of-type(2){width: 80%;}</style><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">介绍</th></tr></thead><tbody><tr><td style="text-align:center">foreach</td><td style="text-align:center">在数据集的每一个元素上，运行函数func进行更新。</td></tr><tr><td style="text-align:center">takeSample</td><td style="text-align:center">抽样但是返回一个scala集合。</td></tr><tr><td style="text-align:center">first</td><td style="text-align:center">返回RDD中的第一个元素</td></tr><tr><td style="text-align:center">takeOrdered</td><td style="text-align:center">返回前几个的排序</td></tr><tr><td style="text-align:center">aggregate</td><td style="text-align:center">将每个分区里面的元素通过seqOp和初始值进行聚合，然后用combine函数将每个分区的结果和初始值(zeroValue)进行combine操作。</td></tr><tr><td style="text-align:center">fold</td><td style="text-align:center">折叠操作，aggregate的简化操作，seqop和combop一样。</td></tr><tr><td style="text-align:center">saveAsObjectFile</td><td style="text-align:center">将RDD中的元素以序列化后对象形式保存到本地或者HDFS中。</td></tr></tbody></table><!-- more --><h3 id="reduce案例实战"><a href="#reduce案例实战" class="headerlink" title="reduce案例实战"></a>reduce案例实战</h3><h3 id="collect案例实战"><a href="#collect案例实战" class="headerlink" title="collect案例实战"></a>collect案例实战</h3><h3 id="count案例实战"><a href="#count案例实战" class="headerlink" title="count案例实战"></a>count案例实战</h3><h3 id="take案例实战"><a href="#take案例实战" class="headerlink" title="take案例实战"></a>take案例实战</h3><h3 id="saveAsTextFile案例实战"><a href="#saveAsTextFile案例实战" class="headerlink" title="saveAsTextFile案例实战"></a>saveAsTextFile案例实战</h3><h3 id="countByKey案例实战"><a href="#countByKey案例实战" class="headerlink" title="countByKey案例实战"></a>countByKey案例实战</h3><h3 id="foreach案例实战"><a href="#foreach案例实战" class="headerlink" title="foreach案例实战"></a>foreach案例实战</h3><h3 id="takeSample案例实战"><a href="#takeSample案例实战" class="headerlink" title="takeSample案例实战"></a>takeSample案例实战</h3><h3 id="first案例实战"><a href="#first案例实战" class="headerlink" title="first案例实战"></a>first案例实战</h3><h3 id="takeOrdered案例实战"><a href="#takeOrdered案例实战" class="headerlink" title="takeOrdered案例实战"></a>takeOrdered案例实战</h3><h3 id="aggregate案例实战"><a href="#aggregate案例实战" class="headerlink" title="aggregate案例实战"></a>aggregate案例实战</h3><h3 id="fold案例实战"><a href="#fold案例实战" class="headerlink" title="fold案例实战"></a>fold案例实战</h3><h3 id="saveAsObjectFile案例实战"><a href="#saveAsObjectFile案例实战" class="headerlink" title="saveAsObjectFile案例实战"></a>saveAsObjectFile案例实战</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常用action介绍&quot;&gt;&lt;a href=&quot;#常用action介绍&quot; class=&quot;headerlink&quot; title=&quot;常用action介绍&quot;&gt;&lt;/a&gt;常用action介绍&lt;/h3&gt;&lt;style&gt;
table th:nth-of-type(1){
width: 20%;
}
table th:nth-of-type(2){
width: 80%;
}
&lt;/style&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;操作&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;介绍&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;reduce&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;通过func函数聚集RDD中的所有元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;collect&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;在驱动程序中，以数组的形式返回数据集的所有元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;count&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;返回RDD中的元素个数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;take&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;返回RDD中的前n个元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;saveAsTextFile&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将RDD以文本文件的方式保存到本地或者HDFS中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;countByKey&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;针对(K,V)类型的RDD，返回一个(K,Int)的map，表示每一个key对应的元素个数。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="Spark" scheme="http://yoursite.com/categories/Spark/"/>
    
    
      <category term="Spark" scheme="http://yoursite.com/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>Spark生态圈之Spark(六) ----- 常用的Transformation</title>
    <link href="http://yoursite.com/2018/06/05/BigData-Spark6/"/>
    <id>http://yoursite.com/2018/06/05/BigData-Spark6/</id>
    <published>2018-06-05T09:28:13.000Z</published>
    <updated>2018-06-05T12:45:41.583Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用transformation介绍"><a href="#常用transformation介绍" class="headerlink" title="常用transformation介绍"></a>常用transformation介绍</h3><style>table th:nth-of-type(1){width: 20%;}table th:nth-of-type(2){width: 80%;}</style><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">介绍</th></tr></thead><tbody><tr><td style="text-align:center">map</td><td style="text-align:center">将RDD中的每个元素传入自定义函数，获取一个新的元素，然后用新的元素组成新的RDD</td></tr><tr><td style="text-align:center">filter</td><td style="text-align:center">对RDD中每个元素进行判断，如果返回true则保留，返回false则剔除</td></tr><tr><td style="text-align:center">flatMap</td><td style="text-align:center">与map类似，但是对每个元素都可以返回一个或多个新元素。</td></tr><tr><td style="text-align:center">groupByKey</td><td style="text-align:center">根据key进行分组，每个key对应一个Iterable<value></value></td></tr><tr><td style="text-align:center">reduceByKey</td><td style="text-align:center">对每个key对应的value进行reduce操作</td></tr><tr><td style="text-align:center">sortByKey</td><td style="text-align:center">对每个key对应的value进行排序操作</td></tr></tbody></table><a id="more"></a><style>table th:nth-of-type(1){width: 20%;}table th:nth-of-type(2){width: 80%;}</style><table><thead><tr><th style="text-align:center">操作</th><th style="text-align:center">介绍</th></tr></thead><tbody><tr><td style="text-align:center">join</td><td style="text-align:center">对两个包含&lt;key,value&gt;对的RDD进行join操作，每个key join上的pair，都会传入自定义函数进行处理</td></tr><tr><td style="text-align:center">cogroup</td><td style="text-align:center">同join，但是是每个key对应的Iterable<value>都会传入自定义函数进行处理</value></td></tr><tr><td style="text-align:center">mapPartitions</td><td style="text-align:center">将函数应用于RDD的每一个分区，每一个分区运行一次，函数需要能够接受Iterator类型，然后返回Iterator。</td></tr><tr><td style="text-align:center">sample</td><td style="text-align:center">在RDD中移seed为种子返回大致上有fraction比例个数据样本RDD，withReplacement表示是否采用放回式抽样。</td></tr><tr><td style="text-align:center">union</td><td style="text-align:center">将两个RDD中的元素进行合并，返回一个新的RDD</td></tr><tr><td style="text-align:center">intersection</td><td style="text-align:center">将两个RDD做交集，返回一个新的RDD</td></tr><tr><td style="text-align:center">distinct</td><td style="text-align:center">将当前RDD进行去重后，返回一个新的RDD</td></tr><tr><td style="text-align:center">partitionBy</td><td style="text-align:center">根据设置的分区器重新将RDD进行分区，返回新的RDD。</td></tr><tr><td style="text-align:center">combineByKey</td><td style="text-align:center">根据key分别使用CreateCombiner和mergeValue进行相同key的数值聚集，通过mergeCombiners将各个分区最终的结果进行聚集。</td></tr><tr><td style="text-align:center">aggregateByKey</td><td style="text-align:center">通过seqOp函数将每一个分区里面的数据和初始值迭代带入函数返回最终值，comOp将每一个分区返回的最终值根据key进行合并操作。</td></tr><tr><td style="text-align:center">foldByKey</td><td style="text-align:center">aggregateByKey的简化操作，seqop和combop相同</td></tr><tr><td style="text-align:center">sortBy</td><td style="text-align:center">底层实现还是使用sortByKey，只不过使用fun生成的新key进行排序。</td></tr><tr><td style="text-align:center">cartesian</td><td style="text-align:center">做两个RDD的笛卡尔积，返回对偶的RDD</td></tr><tr><td style="text-align:center">pipe</td><td style="text-align:center">对于每个分区，都执行一个perl或者shell脚本，返回输出的RDD，注意，如果你是本地文件系统中，需要将脚本放置到每个节点上。</td></tr><tr><td style="text-align:center">coalesce</td><td style="text-align:center">缩减分区数，用于大数据集过滤后，提高小数据集的执行效率。</td></tr><tr><td style="text-align:center">repartition</td><td style="text-align:center">根据你传入的分区数重新通过网络分区所有数据，重型操作。</td></tr><tr><td style="text-align:center">glom</td><td style="text-align:center">将每一个分区形成一个数组，形成新的RDD类型时RDD[Array[T]]</td></tr><tr><td style="text-align:center">mapValues</td><td style="text-align:center">将函数应用于（k，v）结果中的v，返回新的RDD</td></tr><tr><td style="text-align:center">subtract</td><td style="text-align:center">计算差的一种函数去除两个RDD中相同的元素，不同的RDD将保留下来。</td></tr></tbody></table><!-- more --><h3 id="map案例实战"><a href="#map案例实战" class="headerlink" title="map案例实战"></a>map案例实战</h3><p>将集合中每个元素乘以2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def map(): Unit =&#123;</span><br><span class="line">  val conf  = new SparkConf().setAppName(&quot;map&quot;).setMaster(&quot;local[*]&quot;)</span><br><span class="line">  val sc = new SparkContext(conf)</span><br><span class="line"></span><br><span class="line">  val numbers = Array(1,2,3,4,5)</span><br><span class="line">  val numberRDD = sc.parallelize(numbers,1)</span><br><span class="line"></span><br><span class="line">  val multiRDD = numberRDD.map(_*2)</span><br><span class="line">  multiRDD.foreach(println)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="filter案例实战"><a href="#filter案例实战" class="headerlink" title="filter案例实战"></a>filter案例实战</h3><p>过滤出集合中的偶数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def filter(): Unit =&#123;</span><br><span class="line">  val conf = new SparkConf().setAppName(&quot;filter&quot;).setMaster(&quot;local[*]&quot;)</span><br><span class="line">  val sc = new SparkContext(conf)</span><br><span class="line"></span><br><span class="line">  val numbers = Array(1,2,3,4,5,6,7,8,9,10)</span><br><span class="line"></span><br><span class="line">  val numberRDD = sc.parallelize(numbers,1)</span><br><span class="line"></span><br><span class="line">  val filterRDD = numberRDD.filter(num=&gt;(num%2==0))</span><br><span class="line"></span><br><span class="line">  filterRDD.foreach(println)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flatMap案例实战"><a href="#flatMap案例实战" class="headerlink" title="flatMap案例实战"></a>flatMap案例实战</h3><p>将行拆分为单词<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def flatMap(): Unit =</span><br><span class="line">  &#123;</span><br><span class="line">    val conf = new SparkConf().setAppName(&quot;flatMap&quot;).setMaster(&quot;local[*]&quot;)</span><br><span class="line">    val sc = new SparkContext(conf)</span><br><span class="line"></span><br><span class="line">    val lineArray = Array(&quot;hello you&quot;,&quot;hello me&quot;,&quot;hello world&quot;)</span><br><span class="line">    val lines = sc.parallelize(lineArray,1)</span><br><span class="line">    val words = lines.flatMap(line =&gt; line.split(&quot; &quot;))</span><br><span class="line"></span><br><span class="line">    words.foreach(word =&gt; println(word))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="groupByKey案例实战"><a href="#groupByKey案例实战" class="headerlink" title="groupByKey案例实战"></a>groupByKey案例实战</h3><p>根据key进行分组，每个key对应一个Iterable<value><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def groupByKey(): Unit =</span><br><span class="line">&#123;</span><br><span class="line">  val conf = new SparkConf().setAppName(&quot;groupByKey&quot;).setMaster(&quot;local[*]&quot;)</span><br><span class="line">  val sc = new SparkContext(conf)</span><br><span class="line"></span><br><span class="line">  val scoreList = Array((&quot;class1&quot;,80),(&quot;class2&quot;,75),(&quot;class1&quot;,90),(&quot;class2&quot;,60))</span><br><span class="line">  val scores = sc.parallelize(scoreList)</span><br><span class="line"></span><br><span class="line">  val groupedScores = scores.groupByKey()</span><br><span class="line"></span><br><span class="line">  groupedScores.foreach(score =&gt; &#123;</span><br><span class="line">    println(score._1)</span><br><span class="line">    score._2.foreach(println)</span><br><span class="line">    println(&quot;=========================================&quot;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></value></p><h3 id="reduceByKey案例实战"><a href="#reduceByKey案例实战" class="headerlink" title="reduceByKey案例实战"></a>reduceByKey案例实战</h3><p>对每个key对应的value进行reduce操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def reduceByKey(): Unit =</span><br><span class="line">  &#123;</span><br><span class="line">    val conf = new SparkConf().setAppName(&quot;reduceByKey&quot;).setMaster(&quot;local[*]&quot;)</span><br><span class="line">    val sc = new SparkContext(conf)</span><br><span class="line"></span><br><span class="line">    val scoreList = Array((&quot;class1&quot;,80),(&quot;class2&quot;,75),(&quot;class1&quot;,90),(&quot;class2&quot;,60))</span><br><span class="line">    val scores = sc.parallelize(scoreList)</span><br><span class="line"></span><br><span class="line">    val totalScores = scores.reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line">    totalScores.foreach(classScore=&gt;println(classScore._1+&quot; : &quot;+classScore._2))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="sortByKey案例实战"><a href="#sortByKey案例实战" class="headerlink" title="sortByKey案例实战"></a>sortByKey案例实战</h3><p>对每个key对应的value进行排序操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def sortByKey(): Unit =</span><br><span class="line">&#123;</span><br><span class="line">    val conf = new SparkConf().setAppName(&quot;sortByKey&quot;).setMaster(&quot;local[*]&quot;)</span><br><span class="line">    val sc = new SparkContext(conf)</span><br><span class="line"></span><br><span class="line">    val scoreArray = Array((65, &quot;leo&quot;),(50, &quot;tom&quot;),(100, &quot;marry&quot;),(80, &quot;jack&quot;))</span><br><span class="line"></span><br><span class="line">    val scores = sc.parallelize(scoreArray,1)</span><br><span class="line"></span><br><span class="line">    val scoresSort = scores.sortByKey()</span><br><span class="line"></span><br><span class="line">    scoresSort.foreach(score=&gt;&#123;</span><br><span class="line">      println(score._1+&quot;:&quot;+score._2)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="join案例实战"><a href="#join案例实战" class="headerlink" title="join案例实战"></a>join案例实战</h3><p>对两个包含&lt;key,value&gt;对的RDD进行join操作，每个key join上的pair，都会传入自定义函数进行处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def join(): Unit =&#123;</span><br><span class="line">  val conf = new SparkConf().setAppName(&quot;join&quot;).setMaster(&quot;local[*]&quot;)</span><br><span class="line">  val sc = new SparkContext(conf)</span><br><span class="line"></span><br><span class="line">  val studentList = Array((1,&quot;leo&quot;),(2,&quot;jack&quot;),(3,&quot;tom&quot;))</span><br><span class="line"></span><br><span class="line">  val scoreList = Array((1,100),(2,90),(3,60))</span><br><span class="line">  //并行化两个RDD</span><br><span class="line">  val students = sc.parallelize(studentList)</span><br><span class="line">  val scores = sc.parallelize(scoreList)</span><br><span class="line"></span><br><span class="line">  val studentScores = students.join(scores).sortByKey()</span><br><span class="line"></span><br><span class="line">  studentScores.collect().foreach(studentScore =&gt; &#123;</span><br><span class="line">    println(&quot;student id:&quot;+studentScore._1)</span><br><span class="line">    println(&quot;student score:&quot; + studentScore._2)</span><br><span class="line">    println(&quot;===========================&quot;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="cogroup案例实战"><a href="#cogroup案例实战" class="headerlink" title="cogroup案例实战"></a>cogroup案例实战</h3><p>同join，但是是每个key对应的Iterable<value>都会传入自定义函数进行处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def cogroup: Unit =</span><br><span class="line">&#123;</span><br><span class="line">  val conf = new SparkConf().setAppName(&quot;join&quot;).setMaster(&quot;local[*]&quot;)</span><br><span class="line">  val sc = new SparkContext(conf)</span><br><span class="line"></span><br><span class="line">  val studentList = Array((1,&quot;leo&quot;),(2,&quot;jack&quot;),(3,&quot;tom&quot;))</span><br><span class="line"></span><br><span class="line">  val scoreList = Array((1,100),(2,90),(3,60))</span><br><span class="line">  //并行化两个RDD</span><br><span class="line">  val students = sc.parallelize(studentList)</span><br><span class="line">  val scores = sc.parallelize(scoreList)</span><br><span class="line"></span><br><span class="line">  val studentCogroups = students.cogroup(scores)</span><br><span class="line">  studentCogroups.collect().foreach(studentCogroup =&gt; &#123;</span><br><span class="line">    println(studentCogroup._1 + &quot; : &quot; + studentCogroup._2)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></value></p><h3 id="mapPartitions案例实战"><a href="#mapPartitions案例实战" class="headerlink" title="mapPartitions案例实战"></a>mapPartitions案例实战</h3><h3 id="sample案例实战"><a href="#sample案例实战" class="headerlink" title="sample案例实战"></a>sample案例实战</h3><h3 id="union案例实战"><a href="#union案例实战" class="headerlink" title="union案例实战"></a>union案例实战</h3><h3 id="intersection案例实战"><a href="#intersection案例实战" class="headerlink" title="intersection案例实战"></a>intersection案例实战</h3><h3 id="distinct案例实战"><a href="#distinct案例实战" class="headerlink" title="distinct案例实战"></a>distinct案例实战</h3><h3 id="partitionBy案例实战"><a href="#partitionBy案例实战" class="headerlink" title="partitionBy案例实战"></a>partitionBy案例实战</h3><h3 id="combineByKey案例实战"><a href="#combineByKey案例实战" class="headerlink" title="combineByKey案例实战"></a>combineByKey案例实战</h3><h3 id="aggregateByKey案例实战"><a href="#aggregateByKey案例实战" class="headerlink" title="aggregateByKey案例实战"></a>aggregateByKey案例实战</h3><h3 id="foldByKey案例实战"><a href="#foldByKey案例实战" class="headerlink" title="foldByKey案例实战"></a>foldByKey案例实战</h3><h3 id="sortBy案例实战"><a href="#sortBy案例实战" class="headerlink" title="sortBy案例实战"></a>sortBy案例实战</h3><h3 id="cartesian案例实战"><a href="#cartesian案例实战" class="headerlink" title="cartesian案例实战"></a>cartesian案例实战</h3><h3 id="pipe案例实战"><a href="#pipe案例实战" class="headerlink" title="pipe案例实战"></a>pipe案例实战</h3><h3 id="coalesce案例实战"><a href="#coalesce案例实战" class="headerlink" title="coalesce案例实战"></a>coalesce案例实战</h3><h3 id="repartition案例实战"><a href="#repartition案例实战" class="headerlink" title="repartition案例实战"></a>repartition案例实战</h3><h3 id="glom案例实战"><a href="#glom案例实战" class="headerlink" title="glom案例实战"></a>glom案例实战</h3><h3 id="mapValues案例实战"><a href="#mapValues案例实战" class="headerlink" title="mapValues案例实战"></a>mapValues案例实战</h3><h3 id="subtract案例实战"><a href="#subtract案例实战" class="headerlink" title="subtract案例实战"></a>subtract案例实战</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;常用transformation介绍&quot;&gt;&lt;a href=&quot;#常用transformation介绍&quot; class=&quot;headerlink&quot; title=&quot;常用transformation介绍&quot;&gt;&lt;/a&gt;常用transformation介绍&lt;/h3&gt;&lt;style&gt;
table th:nth-of-type(1){
width: 20%;
}
table th:nth-of-type(2){
width: 80%;
}
&lt;/style&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;操作&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;介绍&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;map&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;将RDD中的每个元素传入自定义函数，获取一个新的元素，然后用新的元素组成新的RDD&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;filter&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;对RDD中每个元素进行判断，如果返回true则保留，返回false则剔除&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;flatMap&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;与map类似，但是对每个元素都可以返回一个或多个新元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;groupByKey&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;根据key进行分组，每个key对应一个Iterable&lt;value&gt;&lt;/value&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;reduceByKey&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;对每个key对应的value进行reduce操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;sortByKey&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;对每个key对应的value进行排序操作&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="Spark" scheme="http://yoursite.com/categories/Spark/"/>
    
    
      <category term="Spark" scheme="http://yoursite.com/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>Spark生态圈之Spark(五) ----- Transformation和Action介绍</title>
    <link href="http://yoursite.com/2018/06/05/BigData-Spark5/"/>
    <id>http://yoursite.com/2018/06/05/BigData-Spark5/</id>
    <published>2018-06-05T09:18:16.000Z</published>
    <updated>2018-06-05T09:28:33.129Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/06/05/BigData-Spark5/spark5.1.png" alt="Spark工作原理"><br><a id="more"></a></p><h3 id="transformation和action介绍"><a href="#transformation和action介绍" class="headerlink" title="transformation和action介绍"></a>transformation和action介绍</h3><p>Spark支持两种RDD操作：transformation和action。transformation操作会针对已有的RDD创建一个新的RDD；而action则主要是对RDD进行最后的操作，比如遍历、reduce、保存到文件等，并可以返回结果给Driver程序。</p><p>例如，map就是一种transformation操作，它用于将已有RDD的每个元素传入一个自定义的函数，并获取一个新的元素，然后将所有的新元素组成一个新的RDD。而reduce就是一种action操作，它用于对RDD中的所有元素进行聚合操作，并获取一个最终的结果，然后返回给Driver程序。</p><p>transformation的特点就是lazy特性。lazy特性指的是，如果一个spark应用中只定义了transformation操作，那么即使你执行该应用，这些操作也不会执行。也就是说，transformation是不会触发spark程序的执行的，它们只是记录了对RDD所做的操作，但是不会自发的执行。只有当transformation之后，接着执行了一个action操作，那么所有的transformation才会执行。Spark通过这种lazy特性，来进行底层的spark应用执行的优化，避免产生过多中间结果</p><p>action操作执行，会触发一个spark job的运行，从而触发这个action之前所有的transformation的执行。这是action的特性。</p><p>整个这一块儿，都是在driver节点上执行的，也就是执行我们自己编写的Spark应用程序。但是呢，在action执行之前，所有的transformation都是lazy的，不会立即执行。只有执行了action之后，才会触发job，提交task到Spark集群上，进行实际的执行。<br><img src="/2018/06/05/BigData-Spark5/spark5.1.png" alt="Spark工作原理"></p><h3 id="案例1：统计文件字数"><a href="#案例1：统计文件字数" class="headerlink" title="案例1：统计文件字数"></a>案例1：统计文件字数</h3><p>这里通过一个之前学习过的案例，统计文件字数，来讲解transformation和action。</p><p>这里通过textFile()方法，针对外部文件创建了一个RDD，lines，但是实际上，程序执行到这里为止，spark.txt文件的数据是不会加载到内存中的。lines，只是代表了一个指向spark.txt文件的引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val lines = sc.textFile(&quot;spark.txt&quot;)</span><br></pre></td></tr></table></figure></p><p>这里对lines RDD进行了map算子，获取了一个转换后的lineLengthsRDD。但是这里连数据都没有，当然也不会做任何操作。lineLengths RDD也只是一个概念上的东西而已。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val lineLengths  = lines.map( line=&gt; line.length)</span><br></pre></td></tr></table></figure></p><p>之列，执行了一个action操作，reduce。此时就会触发之前所有transformation操作的执行，Spark会将操作拆分成多个task到多个机器上并行执行，每个task会在本地执行map操作，并且进行本地的reduce聚合。最后会进行一个全局的reduce聚合，然后将结果返回给Driver程序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val totalLength = lineLengths.reduce(_+_)</span><br></pre></td></tr></table></figure></p><h3 id="案例2：统计文件每行出现的次数"><a href="#案例2：统计文件每行出现的次数" class="headerlink" title="案例2：统计文件每行出现的次数"></a>案例2：统计文件每行出现的次数</h3><p>Spark有些特殊的算子，也就是特殊的transformation操作。比如，groupByKey、sortByKey、reduceByKey等，其实只是针对特殊的RDD的。即包含key-value对的RDD。而这种RDD中的元素，实际上是scala中的一种类型，即Tuple2，也就是包含两个值的Tuple、</p><p>在Scala中，需要手动导入Spark的相关隐式转换，import org.apache.spark.SparkContext._。然后，对应包含Tuple2的RDD，会自动隐式转换为PairRDDFunction，并提供reduceByKey等方法。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val lines = sc.textFile(&quot;hello.txt&quot;)</span><br><span class="line">val linePairs = lines.map( line =&gt; (line,1))</span><br><span class="line">val lineCounts = linePairs.reduceByKey(\_+\_)</span><br><span class="line">lineCounts.foreach(lineCount =&gt; println(lineCount._1+&quot; appears &quot;+lineCount._2+&quot; times.&quot;))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/06/05/BigData-Spark5/spark5.1.png&quot; alt=&quot;Spark工作原理&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Spark" scheme="http://yoursite.com/categories/Spark/"/>
    
    
      <category term="Spark" scheme="http://yoursite.com/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>Spark生态圈之Spark(四) ----- RDD的创建</title>
    <link href="http://yoursite.com/2018/06/05/BigData-Spark4/"/>
    <id>http://yoursite.com/2018/06/05/BigData-Spark4/</id>
    <published>2018-06-05T09:12:15.000Z</published>
    <updated>2018-06-05T09:17:02.596Z</updated>
    
    <content type="html"><![CDATA[<h3 id="创建RDD"><a href="#创建RDD" class="headerlink" title="创建RDD"></a>创建RDD</h3><p>进行Spark核心编程时，首先要做的第一件事，就是创建一个初始的RDD。该RDD中，通常就代表和包含了Spark应用程序的输入源数据。然后在创建了初始的RDD之后，才可以通过Spark Core提供的Transformation算子，对该RDD进行转换，来获取其他的RDD。</p><p>Spark Core提供了三种创建RDD的方式，包括：使用程序中的集合创建RDD；使用本地文件创建RDD；使用HDFS文件创建RDD。</p><p>1、使用程序中的集合创建RDD，主要用于进行测试，可以在实际部署到集群运行之前，自己使用集合构造测试数据，来测试后面的spark应用的流程</p><p>2、使用本地文件创建RDD，主要用于临时性地处理一些存储了大量数据的文件</p><p>3、使用HDFS文件创建RDD，应该是最常用的生产环境处理方式，主要可以针对HDFS上存储的大数据，进行离线批处理操作。<br><a id="more"></a></p><h4 id="并行化集合创建RDD"><a href="#并行化集合创建RDD" class="headerlink" title="并行化集合创建RDD"></a>并行化集合创建RDD</h4><p>如果要通过并行化集合来创建RDD，需要针对程序中的集合，调用SparkContext的parallelize()方法。Spark会将集合中的数据拷贝到集群上去，形成一个分布式的数据集合，也就是一个RDD。相当于是，集合中的部分数据会到一个节点上，而另一部分数据会到其他节点上。然后就可以用并行的方式来操作这个分布式数据集合，即RDD。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val arr = Array(1,2,3,4,5,6,7,8,9,10)</span><br><span class="line">val rdd = sc.parallelize(arr)</span><br><span class="line">val sum = rdd.reduce(_+_)</span><br></pre></td></tr></table></figure><p>调用parallelize()时，有一个重要的参数可以指定，就是要将集合切分成多少个partition。Spark会为每一个partition运行一个task来进行处理。Spark官方的建议是，为集群中的每个CPU创建2~4个partition。Spark默认会根据集群的情况来设置partition的数量。但是也可以在调用parallelize()方法时，传入第二个参数，来设置RDD的partition数量。比如parallelize(arr,10)</p><h4 id="使用本地文件和HDFS创建RDD"><a href="#使用本地文件和HDFS创建RDD" class="headerlink" title="使用本地文件和HDFS创建RDD"></a>使用本地文件和HDFS创建RDD</h4><p>Spark是支持使用任何Hadoop支持的存储系统上的文件创建RDD的，比如说HDFS、Cassandra、HBase以及本地文件。通过调用SparkContext的textFile()方法，可以针对本地文件或HDFS文件创建RDD</p><p>有几个事项要需要注意的：</p><p>1、如果是针对本地文件的话，如果是在windows上本地测试，windows上有一份文件即可；如果是在Spark集群上针对linux本地文件，那么需要将文件拷贝到所有worker节点上。</p><p>2、Spark的textFile()方法支持针对目录、压缩文件以及通配符进行RDD创建</p><p>3、Spark默认会为hdfs文件的每一个block创建一个partition，但是也可以通过textFile()第二个参数手动设置分区数量，只能比block数量多，不能比block数量少。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val rdd = sc.textFile(&quot;data.txt&quot;)</span><br><span class="line"></span><br><span class="line">val wordCount = rdd.map(line =&gt; line.length).reduce(_+_)</span><br></pre></td></tr></table></figure><p>Spark的textFile()除了可以针对上述几种普通的文件创建RDD之外，还有一些特列的方法来创建RDD:</p><p>1、SparkContext.wholeTextFiles()方法，可以针对一个目录中的大量小文件，返回&lt;filename,fileContent&gt;组成的pair，作为一个PairRDD，而不是普通的RDD。普通的textFile()返回的RDD中，每个元素就是文件中的一行文本。</p><p>2、SparkContext.sequenceFile[K,V]()方法，可以针对SequenceFile创建RDD，K和V泛型类型就是SequenceFile的key和value的类型。K和V要求必须是Hadoop的序列化类型，比如IntWritable、Text等。</p><p>3、SparkContext.hadoopRDD()方法，对于Hadoop的自定义输入类型，可以创建RDD。该方法接收JobConf、InputFormatClass、Key和Value的Class。</p><p>4、SparkContext.objectFile()方法，可以针对之前调用RDD.saveAsObjectFile()创建的对象序列化的文件，反序列化文件中的数据，并创建一个RDD。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;创建RDD&quot;&gt;&lt;a href=&quot;#创建RDD&quot; class=&quot;headerlink&quot; title=&quot;创建RDD&quot;&gt;&lt;/a&gt;创建RDD&lt;/h3&gt;&lt;p&gt;进行Spark核心编程时，首先要做的第一件事，就是创建一个初始的RDD。该RDD中，通常就代表和包含了Spark应用程序的输入源数据。然后在创建了初始的RDD之后，才可以通过Spark Core提供的Transformation算子，对该RDD进行转换，来获取其他的RDD。&lt;/p&gt;
&lt;p&gt;Spark Core提供了三种创建RDD的方式，包括：使用程序中的集合创建RDD；使用本地文件创建RDD；使用HDFS文件创建RDD。&lt;/p&gt;
&lt;p&gt;1、使用程序中的集合创建RDD，主要用于进行测试，可以在实际部署到集群运行之前，自己使用集合构造测试数据，来测试后面的spark应用的流程&lt;/p&gt;
&lt;p&gt;2、使用本地文件创建RDD，主要用于临时性地处理一些存储了大量数据的文件&lt;/p&gt;
&lt;p&gt;3、使用HDFS文件创建RDD，应该是最常用的生产环境处理方式，主要可以针对HDFS上存储的大数据，进行离线批处理操作。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Spark" scheme="http://yoursite.com/categories/Spark/"/>
    
    
      <category term="Spark" scheme="http://yoursite.com/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>随笔(三)</title>
    <link href="http://yoursite.com/2018/06/04/jottings-3/"/>
    <id>http://yoursite.com/2018/06/04/jottings-3/</id>
    <published>2018-06-04T10:25:23.000Z</published>
    <updated>2018-06-21T12:27:20.307Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/06/04/jottings-3/jottings-3.jpg" alt="jottings"><br><a id="more"></a></p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=479598964&auto=1&height=66"></iframe><center>害怕岁月静好无人来扰<br>害怕诗人渐老穷困潦倒<br>害怕绿惹芭蕉晚风潇潇<br>害怕路途陡峭空水几瓢<br>害怕流年尽抛知音难找<br>害怕夜半轻悄同为寂寥<br>害怕共度一朝无人说道<br>害怕时光渐消不成玩笑<br>害怕孤独高傲酿成毒药<br>害怕青春走掉再无吵闹<br>害怕深夜嚎叫影过石桥<br>害怕自持年少过往焚烧<br>害怕无人依靠苦涩情调<br>害怕所有的以梦为马都没必要<br>终了</center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/06/04/jottings-3/jottings-3.jpg&quot; alt=&quot;jottings&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="thoughts" scheme="http://yoursite.com/categories/thoughts/"/>
    
    
      <category term="jottings" scheme="http://yoursite.com/tags/jottings/"/>
    
  </entry>
  
  <entry>
    <title>Spark生态圈之Spark(三) ----- Spark架构原理</title>
    <link href="http://yoursite.com/2018/05/25/BigData-Spark3/"/>
    <id>http://yoursite.com/2018/05/25/BigData-Spark3/</id>
    <published>2018-05-24T17:07:35.000Z</published>
    <updated>2018-05-24T17:18:21.535Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/05/25/BigData-Spark3/spark1.png" alt="Spark工作原理"><br><a id="more"></a></p><h3 id="Spark框架原理"><a href="#Spark框架原理" class="headerlink" title="Spark框架原理"></a>Spark框架原理</h3><p>Driver：我们编写的Spark程序就在Driver上</p><p>Master: 其实主要负责资源的调度和分配，还有集群的监控，等等职责</p><p>Worker：主要是负责两个，一个是用自己的内存存储RDD的某个或某些partition；另一个是启动其他进程和线程，对RDD上的partition进行版型的处理和计算</p><p>Executor和Task： Executor和Task，其实就是负责执行对RDD的partition进行并行的计算了，也就是执行我们对RDD定义的，比如map、flatMap、reduce等算子操作</p><p>1、Driver进程启动之后，会做一些初始化的操作；在这个过程中，就会发送请求到Master上，进行Spark应用程序的注册，说白了，就是让Master知道，有一个新的Spark应用程序要运行。</p><p>2、Master，在接收到了Spark应用程序的注册申请之后，会发送请求给Worker，进行资源的调度和分配，ok，说白了，说穿了，资源分配，就是executor的分配。</p><p>3、Worker接收到Master的请求之后，会为Spark应用程序启动Executor</p><p>4、Executor启动之后，会向Driver进行反注册。这样，Driver就知道，哪些Executor是为它进行服务的了。</p><p>5、Driver注册了一些executor之后，就可以开始正式执行我们的spark应用程序了，首先第一步，就是，创建初始RDD，读取数据源</p><p>6、HDFS文件内容被读取到多个worker节点上，形成内存中的分布式数据集，也就是初始RDD</p><p>7、Driver会根据我们对RDD定义的操作，提交一大堆task去executor上，executor接收到task之后，会启动多个线程来执行task</p><p>8、task就会对RDD的partition数据执行指定的算子操作，形成新的RDD的partition</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/05/25/BigData-Spark3/spark1.png&quot; alt=&quot;Spark工作原理&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Spark" scheme="http://yoursite.com/categories/Spark/"/>
    
    
      <category term="Spark" scheme="http://yoursite.com/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>Spark生态圈之Spark(二) ----- WordCount程序原理</title>
    <link href="http://yoursite.com/2018/05/25/BigData-Spark2/"/>
    <id>http://yoursite.com/2018/05/25/BigData-Spark2/</id>
    <published>2018-05-24T16:45:46.000Z</published>
    <updated>2018-05-24T17:20:02.310Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/05/25/BigData-Spark2/spark1.png" alt="Spark工作原理"><br><a id="more"></a></p><h3 id="Java开发WordCount"><a href="#Java开发WordCount" class="headerlink" title="Java开发WordCount"></a>Java开发WordCount</h3><p>用Java开发wordcount程序：<br>1、配置Maven环境<br>2、如何进行本地测试<br>3、如何使用spark-submit提交到spark集群进行执行(spark-submit常用参数说明，spark-submit其实就类似于hadoop的hadoop jar命令)</p><h4 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h4><p>创建SparkConf对象，设置spark应用的配置信息使用setMaster()可以设置Spark应用程序要连接的spark集群的master节点的url，但是如果设置为local则代表在本地运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SparkConf conf = new SparkConf().setAppName(&quot;SparkJava&quot;).setMaster(&quot;local&quot;);</span><br></pre></td></tr></table></figure></p><h4 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h4><p>创建JavaSparkContext对象</p><p>在Spark中，SparkContext是spark所有功能的一个入口，你无论是用java，scala，甚至是python编写<br>都必须要有一个SparkContext，他的主要作用，包括初始化Spark应用程序所需的一些核心组件，包括<br>调度器(DAGSchedule、TaskScheduler),还会去到Spark Master节点上进行注册，等等<br>一句话，SparkContext，是Spark应用中，可以说是最最重要的一个对象<br>但是呢，在spark中，编写不同类型的spark应用程序，使用的SparkContext是不同的，如果使用scala，<br>使用的就是原生的SparkContext对象<br>但是如果使用Java，那么就是JavaSparkContext对象<br>如果是开发Spark SQL程序，那么就是SQLContext、HiveContext<br>如果是开发 Spark Streaming程序，那么就是它独有的SparkContext以此类推<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JavaSparkContext sc = new JavaSparkContext(conf);</span><br></pre></td></tr></table></figure></p><h4 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h4><p>要针对输入源(HDFS、本地文件、等等)，创建一个初始的RDD</p><p>输入源中的数据会打散，分配到RDD的每个partition中，从而形成一个初始的分布式的数据集<br>我们这里呢，因为是本地测试，所以呢，就是针对本地文件<br>SparkContext中，用于根据文件类型的输入源创建RDD的方法，叫做textFile()方法<br>在Java中，创建的普通RDD，都叫做JavaRDD<br>在这里呢，RDD中，有元素这种概念，如果是HDFS或者本地文件呢，创建的RDD，每一个元素就相当于是文件里的一行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JavaRDD&lt;String&gt; lines = sc.textFile(&quot;C://MyWork-Study//Spark//课件//第29讲-Spark核心编程：使用Java、Scala和spark-shell开发wordcount程序//文档//spark.txt&quot;);</span><br></pre></td></tr></table></figure></p><h4 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h4><p>对初始RDD进行transformation操作，也就是一些计算操作</p><p>通常操作会通过创建function，并配合RDD的map、flatMap等算子来执行function<br>通常，如果比较简单，则创建指定Function的匿名内部类<br>但是如果function比较复杂，则会单独创建一个类，作为实现这个function接口的类<br>先将每一行拆分成单个的单词<br>FlatMapFunction，有两个泛型参数，分别代表了输入和输出<br>我们这里呢，输入肯定是String，因为是一行一行的文本，输出，其实也是String，因为是每一行的文本<br>这里先简要介绍flatMap算子的作用，其实就是，将RDD的一个元素，给拆分成一个或多个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JavaRDD&lt;String&gt; words = lines.flatMap(new FlatMapFunction&lt;String, String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">         private static final long servialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">           public Iterator&lt;String&gt; call(String line) throws Exception</span><br><span class="line">           &#123;</span><br><span class="line">               return (Iterator&lt;String&gt;) Arrays.asList(line.split(&quot; &quot;));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure></p><h4 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h4><p>接着，需要将每一个单词，映射为(单词，1))的这种格式<br>因为只有这样，后面才能根据单词作为key，来进行每个单词的出现次数的累加<br>mapToPair，其实就是将每个元素，映射为一个(v1,v2)这样的Tuple2类型的元素<br>如果大家还记得Scala里面讲的tuple，那么没错，这里的tuple2就是scala类型，包含了两个值<br>mapToPair这个算子，要求的是与PairFunction配合使用，第一个泛型参数代表了输入类型<br>第二个和第三个泛型参数，代表的输出的Tuple2的第一个值和第二个值的类型<br>JavaPairRDD的两个泛型参数，分别代表了Tuple元素的第一个值和第二个值的类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JavaPairRDD&lt;String, Integer&gt; pairs = words.mapToPair(</span><br><span class="line">        new PairFunction&lt;String, String, Integer&gt;() &#123;</span><br><span class="line">            private static final long serialVersionUDI = 1L;</span><br><span class="line"></span><br><span class="line">    public Tuple2&lt;String, Integer&gt; call(String word) throws Exception &#123;</span><br><span class="line">        return new Tuple2&lt;String, Integer&gt;(word,1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="第六步"><a href="#第六步" class="headerlink" title="第六步"></a>第六步</h4><p>接着，需要以单词作为key，统计每个单词出现的次数<br>这里要使用reduceByKey这个算子，对每个key对应的value，都进行reduce操作<br>比如JavaPairRDD中有几个元素，分别为(hello，1) (hello,1) (world,1)<br>比如这里的hello，那么就相当于是，首先是1 + 1 = 2，然后再将2 + 1 = 3<br>最后返回的JavaPairRDD中的元素，也是tuple，但是第一个值就是每个key，第二个值就是key的value<br>reduce之后的结果，相当于就是每个单词出现的次数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wordCounts.foreach(</span><br><span class="line">        new VoidFunction&lt;Tuple2&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">    public void call(Tuple2&lt;String, Integer&gt; wordcount) throws Exception &#123;</span><br><span class="line">        System.out.println(wordcount._1+&quot; appeared &quot;+wordcount._2+&quot; times.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">sc.close();</span><br></pre></td></tr></table></figure></p><h3 id="程序提交"><a href="#程序提交" class="headerlink" title="程序提交"></a>程序提交</h3><p>一旦打包好,就可以使用bin/spark-submit脚本启动应用了. 这个脚本负责设置spark使用的classpath和依赖,支持不同类型的集群管理器和发布模式:<br>./bin/spark-submit \<br>  --class <main-class><br>  --master <master-url> \<br>      --deploy-mode <deploy-mode> \<br>  --conf <key>=<value> \<br>  … # other options<br>  <application-jar> \<br>  [application-arguments]<br>一些常用选项:<br>1)    --class: 你的应用的启动类 (如 org.apache.spark.examples.SparkPi)<br>2)    --master: 集群的master URL (如 spark://23.195.26.187:7077)<br>3)    --deploy-mode: 是否发布你的驱动到worker节点(cluster) 或者作为一个本地客户端 (client) (default: client)*<br>4)    --conf: 任意的Spark配置属性， 格式key=value. 如果值包含空格，可以加引号“key=value”. 缺省的Spark配置<br>5)    application-jar: 打包好的应用jar,包含依赖. 这个URL在集群中全局可见。 比如hdfs:// 共享存储系统， 如果是 file:// path， 那么所有的节点的path都包含同样的jar.<br>6)    application-arguments: 传给main()方法的参数</application-jar></value></key></deploy-mode></master-url></main-class></p><p>local    本地以一个worker线程运行(例如非并行的情况).<br>local[K]    本地以K worker 线程 (理想情况下, K设置为你机器的CPU核数).<br>local[*]    本地以本机同样核数的线程运行.<br>spark://HOST:PORT    连接到指定的Spark standalone cluster master. 端口是你的master集群配置的端口，缺省值为7077.<br>mesos://HOST:PORT    连接到指定的Mesos 集群. Port是你配置的mesos端口， 缺省是5050. 或者如果Mesos使用ZOoKeeper,格式为 mesos://zk://….<br>yarn-client    以client模式连接到YARN cluster. 集群的位置基于HADOOP_CONF_DIR 变量找到.<br>yarn-cluster    以cluster模式连接到YARN cluster. 集群的位置基于HADOOP_CONF_DIR 变量找到.</p><p>例如：</p><blockquote><p><strong>$</strong> spark2-submit \<br>--class com.scala.wordcount.WordCount<br>--num-executors 3 \<br>--driver-memory 1G \<br>--executor-memory 1G \<br>--executor-cores 3 \<br>/home/richard/wordcount-jar-with-dependencies.jar \<br>100</p></blockquote><h3 id="WordCount程序原理"><a href="#WordCount程序原理" class="headerlink" title="WordCount程序原理"></a>WordCount程序原理</h3><p><img src="/2018/05/25/BigData-Spark2/spark1.png" alt="Spark工作原理"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">val conf = new SparkConf().setAppName(&quot;WordCount&quot;)</span><br><span class="line"></span><br><span class="line">val sc = new SparkContext(conf)</span><br><span class="line"></span><br><span class="line">val lines = sc.textFile(&quot;&quot;)</span><br><span class="line"></span><br><span class="line">val words = lines.flatMap(line =&gt; line.split(&quot; &quot;))</span><br><span class="line"></span><br><span class="line">val pairs = words.map(word =&gt; (word,1))</span><br><span class="line"></span><br><span class="line">val wordCounts = pairs.reduceByKey(\_+\_)</span><br><span class="line"></span><br><span class="line">wordCount.foreach(wordCount =&gt; println(wordCount._1 + &quot; appears &quot;+wordCount._2 + &quot; times.&quot;))</span><br></pre></td></tr></table></figure><p><img src="/2018/05/25/BigData-Spark2/spark2.png" alt="Spark工作原理"></p><p>这个过程，所有的算子，都是在相同节点内进行的，这里就体现出了分布式、内存、迭代式计算，等几个spark最显著的计算模型和特点。也是Spark叫MapReduce这种计算模型速度更快的原因，MR的话，实现这个过程，必须要跨节点，走磁盘读写，没有内存式、迭代式计算的特点。<br>这就是所谓Spark的分布式、内存式、迭代式的计算模型，也是Spark之所以速度比MapReduce更快的原因。如果是MR，就必须走磁盘读写，速度必然降低。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/05/25/BigData-Spark2/spark1.png&quot; alt=&quot;Spark工作原理&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Spark" scheme="http://yoursite.com/categories/Spark/"/>
    
    
      <category term="Spark" scheme="http://yoursite.com/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>Spark生态圈之Spark(一) ----- Spark工作原理与RDD</title>
    <link href="http://yoursite.com/2018/05/25/BigData-Spark1/"/>
    <id>http://yoursite.com/2018/05/25/BigData-Spark1/</id>
    <published>2018-05-24T16:27:24.000Z</published>
    <updated>2018-05-24T16:43:37.102Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/05/25/BigData-Spark1/spark1.png" alt="Spark工作原理"><br><a id="more"></a></p><h3 id="Spark工作原理"><a href="#Spark工作原理" class="headerlink" title="Spark工作原理"></a>Spark工作原理</h3><p>1、分布式<br>2、主要基于内存(少数情况基于磁盘)<br>3、迭代式运算</p><p>spark与MapReduce最大的不同在于，迭代式计算模型：Mapreduce，分为两个阶段，map和reduce，两个阶段完了，就结束了，所以我们在一个job里能做的处理很有限，spark计算模型，可以分为n个阶段，因为他是内存迭代式的，我们在处理完一个阶段以后，可以继续往下处理很多个阶段，而不只是两个阶段。所以，spark相较于Mapreduce来说，计算模型可以提供更强大的功能。</p><p><img src="/2018/05/25/BigData-Spark1/spark1.png" alt="Spark工作原理"></p><p>Spark的核心编程其实就是：</p><p>第一，定义初始的RDD，就是说，你要定义第一个RDD是从哪里读取数据，HDFS，linux本地文件，程序中的集合。<br>第二，定义对RDD的计算操作，这个在Spark里称之为算子，map，reduce，flatMap，groupByKey，比mapreduce提供的map和reduce强大的太多太多了。<br>第三，其实就是循环往复的过程，第一个计算完了以后，数据可能就会到了新的一批节点上，也就是变成一个新的RDD，然后再次反复，针对新的RDD定义计算操作。。。。<br>第四，最后获得最终的数据，将数据保存起来。</p><h3 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h3><p>1、RDD是spark提供的核心抽象，全称为Resillient Distributed Dataset，即弹性分布式数据集<br>2、RDD在抽象上来说是一种元素集合，包含了数据，它是被分区的，分为多个分区，每个分区分布在集群中的不同节点上，从而让RDD中的数据可以被并行操作(分布式数据集)<br>3、RDD通常通过Hadoop上的文件，即HDFS文件或者Hive表，来进行创建；有时也可以通过应用程序中的集合来创建。<br>4、RDD最重要的特性就是，提供了容错性，可以自动从节点失败中恢复过来。即如果某个节点上的RDD partition，因为节点故障，导致数据丢了，那么RDD会自动通过自己的数据来源重新计算该partition。这一切对使用者是透明的。<br>5、RDD的数据默认情况下存放在内存中的，但是在内存资源不足时，Spark会自动将RDD数据写入磁盘。(弹性)</p><p><img src="/2018/05/25/BigData-Spark1/spark2.png" alt="Spark工作原理"><br>一个RDD，在逻辑上，抽象地代表了一个HDFS文件，但是，它实际上是被分区得，分为多个分区。多个分区散落在Spark集群中，不同的节点上，比如说，RDD有90万数据；分为9个partition，9个分区。</p><p><img src="/2018/05/25/BigData-Spark1/spark3.png" alt="Spark工作原理"><br>现在，节点9出了些故障，导致partition9的数据丢失了，那么此时Spark会脆弱到直接报错，直接挂掉吗？不可能！！<br> RDD是有很强的容错性的，当它发现自己的数据丢失了以后，会自动从自己来源的数据进行重计算，重新获取自己这份数据，这一切对用户，都是完全透明的。</p><p><img src="/2018/05/25/BigData-Spark1/spark4.png" alt="Spark工作原理"><br>RDD的每个partition，在spark节点上存储时，默认都是放在内存中的，但是如果说内存放不下这么多数据时，比如每个节点最多放5万数据，结果你每个partition是10万数据，那么就会把partition中的部分数据写入磁盘上，进行保存。<br>而上述这一切对于用户来说，都是完全透明的。你不用去管RDD的数据存储在哪里，内存还是磁盘，只要关注，你针对RDD来进行计算和处理，等等操作即可。<br>所以说，RDD的这种自动进行内存和磁盘之间权衡和切换的机制，就是RDD的弹性的特点所在。</p><h3 id="Spark开发"><a href="#Spark开发" class="headerlink" title="Spark开发"></a>Spark开发</h3><p>1、核心开发：离线批处理 / 延迟性的交互式数据处理<br>2、SQL查询 ： 底层都是RDD和计算操作<br>3、实时计算 ： 底层都是RDD和计算操作</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/05/25/BigData-Spark1/spark1.png&quot; alt=&quot;Spark工作原理&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Spark" scheme="http://yoursite.com/categories/Spark/"/>
    
    
      <category term="Spark" scheme="http://yoursite.com/tags/Spark/"/>
    
  </entry>
  
  <entry>
    <title>随笔(二)</title>
    <link href="http://yoursite.com/2018/05/18/jottings-2/"/>
    <id>http://yoursite.com/2018/05/18/jottings-2/</id>
    <published>2018-05-18T00:54:17.000Z</published>
    <updated>2018-05-18T01:06:13.535Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/05/18/jottings-2/jottings2.jpg" alt="jottings"><br><a id="more"></a></p><p>太好了，太好了。我也算卸下包袱，这下总算可以回去了。<br>你这人还真是的，<br>又冒失，<br>又愚蠢，<br>又厌学，<br>有懦弱，<br>又懒惰，<br>又迟钝，<br>运动又不行，<br>又胆小，<br>又糊涂，<br>又不可靠….<br>又讨厌麻烦….<br>又没出息….<br>记性又差….<br>是个老好人….<br>还总是得意忘形….<br>又爱撒娇….</p><p>咦？</p><p>该怎么办呢？还真是伤脑筋啊！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2018/05/18/jottings-2/jottings2.jpg&quot; alt=&quot;jottings&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="thoughts" scheme="http://yoursite.com/categories/thoughts/"/>
    
    
      <category term="jottings" scheme="http://yoursite.com/tags/jottings/"/>
    
  </entry>
  
  <entry>
    <title>Python科学计算库 ----- Numpy</title>
    <link href="http://yoursite.com/2018/05/17/Python-Numpy/"/>
    <id>http://yoursite.com/2018/05/17/Python-Numpy/</id>
    <published>2018-05-17T08:57:43.000Z</published>
    <updated>2018-05-17T10:02:58.581Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Numpy基础结构"><a href="#Numpy基础结构" class="headerlink" title="Numpy基础结构"></a>Numpy基础结构</h3><p>按照”,”分隔，以str形式读取txt文件<br>type():数据类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import numpy</span><br><span class="line">world_alcohol = numpy.genfromtxt(&quot;world_alcohol.txt&quot;, delimiter=&quot;,&quot;,dtype=str)</span><br><span class="line">print(type(world_alcohol))</span><br><span class="line">print(world_alcohol)</span><br><span class="line">print(help(numpy.genfromtxt))</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>读取array数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector = numpy.array([5,10,15,20])</span><br><span class="line"></span><br><span class="line">matrix = numpy.array([[5,10,15],[20,25,30],[35,40,45]])</span><br><span class="line">print vector</span><br><span class="line">print matrix</span><br></pre></td></tr></table></figure></p><p>shape显示数组的维度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector = numpy.array([1,2,3,4])</span><br><span class="line">print(vector.shape)</span><br><span class="line"></span><br><span class="line">matrix = numpy.array([[5,10,15],[20,25,30]])</span><br><span class="line">print(matrix.shape)</span><br></pre></td></tr></table></figure></p><p>dtype:数组元素类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import numpy</span><br><span class="line">numbers = numpy.array([1,2,3,4])</span><br><span class="line"></span><br><span class="line">print(numbers)</span><br><span class="line">numbers.dtype</span><br></pre></td></tr></table></figure></p><p>skip_header:略过多少行从 n+1行开始读取数据<br>[m,n]\:第m+1行、第n+1列数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">world_alcohol = numpy.genfromtxt(&quot;world_alcohol.txt&quot;,delimiter=&quot;,&quot;,dtype=str,skip_header=1)</span><br><span class="line">print(world_alcohol)</span><br><span class="line"># print(world_alcohol.shape)</span><br><span class="line"></span><br><span class="line">uruguay_other_1986 = world_alcohol[1,4]</span><br><span class="line">third_country = world_alcohol[2,2]</span><br><span class="line">print(uruguay_other_1986)</span><br><span class="line">print(third_country)</span><br></pre></td></tr></table></figure></p><p>读取数组1~3列的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector = numpy.array([5,10,15,20])</span><br><span class="line">print(vector[0:3])</span><br></pre></td></tr></table></figure></p><p>[:,n] \: 读取所有行第n+1列的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">matrix = numpy.array([</span><br><span class="line">    [5,10,15],</span><br><span class="line">    [20,25,30],</span><br><span class="line">    [35,40,45]</span><br><span class="line">])</span><br><span class="line">print(matrix[:,1])</span><br></pre></td></tr></table></figure></p><p>[:,0:2] \: 读取所有行第1~2列的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">matrix = numpy.array([</span><br><span class="line">    [5,10,15],</span><br><span class="line">    [20,25,30],</span><br><span class="line">    [35,40,45]</span><br><span class="line">])</span><br><span class="line">print(matrix[:,0:2])</span><br></pre></td></tr></table></figure></p><p>[1:3,0:2] \: 读取数组的第2~3行，第1~2列数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">matrix = numpy.array([</span><br><span class="line">    [5,10,15],</span><br><span class="line">    [20,25,30],</span><br><span class="line">    [35,40,45]</span><br><span class="line">])</span><br><span class="line">print(matrix[1:3,0:2])</span><br></pre></td></tr></table></figure></p><h3 id="Numpy矩阵基础"><a href="#Numpy矩阵基础" class="headerlink" title="Numpy矩阵基础"></a>Numpy矩阵基础</h3><p>== : 返回boolean型 [False,True,False,False]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector = numpy.array([5,10,15,20])</span><br><span class="line">print(vector==10)</span><br><span class="line"></span><br><span class="line">matrix = numpy.array([</span><br><span class="line">    [5,10,15],</span><br><span class="line">    [20,25,30],</span><br><span class="line">    [35,40,45]</span><br><span class="line">])</span><br><span class="line">print(matrix == 25)</span><br></pre></td></tr></table></figure></p><p>根据==返回的boolean数组，可以通过boolean数组，从原数据中获取数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector = numpy.array([5,10,15,20])</span><br><span class="line">equal_to_ten = (vector == 10)</span><br><span class="line"></span><br><span class="line">print(equal_to_ten)</span><br><span class="line">print(vector[equal_to_ten])</span><br></pre></td></tr></table></figure></p><p>根据matrix[:,1]==25的条件获取所在列的boolean数组，可以根据boolean数组找到原数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">matrix = numpy.array([</span><br><span class="line">    [5,10,15],</span><br><span class="line">    [20,25,30],</span><br><span class="line">    [35,40,45]</span><br><span class="line">])</span><br><span class="line">second_column_25 = (matrix[:,1]==25)</span><br><span class="line">print(second_column_25)</span><br><span class="line">print(matrix[second_column_25,:])</span><br></pre></td></tr></table></figure></p><p>条件与 : &amp;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import numpy</span><br><span class="line">vector = numpy.array([5,10,15,20])</span><br><span class="line">equal_to_ten_and_five = (vector==10) &amp; (vector==5)</span><br><span class="line">print(equal_to_ten_and_five)</span><br></pre></td></tr></table></figure></p><p>条件或 ： |</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector = numpy.array([5,10,15,20])</span><br><span class="line">equal_to_ten_or_five = (vector == 10) | (vector == 5)</span><br><span class="line">print(equal_to_ten_or_five)</span><br></pre></td></tr></table></figure><p>根据[:,1]==25的boolean数据条件更改原数组数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">matrix = numpy.array([</span><br><span class="line">    [5,10,15],</span><br><span class="line">    [20,25,30],</span><br><span class="line">    [35,40,45]</span><br><span class="line">])</span><br><span class="line">second_column_25 = matrix[:,1] == 25</span><br><span class="line">print(second_column_25)</span><br><span class="line">matrix[second_column_25,1] = 10</span><br><span class="line">print(matrix)</span><br></pre></td></tr></table></figure></p><p>astype:类型转换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector = numpy.array([&quot;1&quot;,&quot;2&quot;,&quot;3&quot;])</span><br><span class="line">print(vector.dtype)</span><br><span class="line">print(vector)</span><br><span class="line">vector = vector.astype(float)</span><br><span class="line">print(vector.dtype)</span><br><span class="line">print(vector)</span><br></pre></td></tr></table></figure></p><h3 id="Numpy常用函数"><a href="#Numpy常用函数" class="headerlink" title="Numpy常用函数"></a>Numpy常用函数</h3><p>min:数组最小值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector = numpy.array([5,10,15,20])</span><br><span class="line">print(vector.min())</span><br></pre></td></tr></table></figure></p><p>axis=1 按行求和<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">matrix = numpy.array([</span><br><span class="line">    [5,10,15],</span><br><span class="line">    [20,25,30],</span><br><span class="line">    [35,40,45]</span><br><span class="line">])</span><br><span class="line">print(matrix.sum(axis=1))</span><br></pre></td></tr></table></figure></p><p>axis=0 按列求和<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">matrix = numpy.array([</span><br><span class="line">    [5,10,15],</span><br><span class="line">    [20,25,30],</span><br><span class="line">    [35,40,45]</span><br><span class="line">])</span><br><span class="line">print(matrix.sum(axis=0))</span><br></pre></td></tr></table></figure></p><p>arange(n): 0~n-1的值<br>reshape : 更改数组维度<br>ndim : 数组维度(比如二维数组、三维数组等)<br>dtype : 数据类型<br>size : 大小<br>zeros((m,n)) : 二维值都为0的数组<br>ones((a,b,c)):三维值都为1的数组</p><p>arange(a,b,c) :按照c跳值<br>np.random.random : 随机值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">print(np.arange(15))</span><br><span class="line">a = np.arange(15).reshape(3,5)</span><br><span class="line">print(a)</span><br><span class="line">print(a.shape)</span><br><span class="line"></span><br><span class="line">print(a.ndim) #维度</span><br><span class="line"></span><br><span class="line">print(a.dtype.name)</span><br><span class="line"></span><br><span class="line">print(a.size)</span><br><span class="line"></span><br><span class="line">print(np.zeros((3,4)))</span><br><span class="line"></span><br><span class="line">print(np.ones((2,3,4),dtype=np.int32))</span><br><span class="line"></span><br><span class="line">print(np.arange(10,30,5))</span><br><span class="line"></span><br><span class="line">print(np.arange(0,2,0.3))</span><br><span class="line"></span><br><span class="line">print(np.arange(12).reshape(4,3))</span><br><span class="line"></span><br><span class="line">print(np.random.random((2,3)))</span><br></pre></td></tr></table></figure></p><h3 id="矩阵常用操作"><a href="#矩阵常用操作" class="headerlink" title="矩阵常用操作"></a>矩阵常用操作</h3><p>**2 : 平方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([20,30,40,50])</span><br><span class="line">b = np.arange(4)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line">c= a-b</span><br><span class="line">print(c)</span><br><span class="line"></span><br><span class="line">b**2</span><br><span class="line">print(b**2)</span><br><span class="line">print(a&lt;35)</span><br></pre></td></tr></table></figure></p><p>.dot : 矩阵相乘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">A = np.array([[1,1],</span><br><span class="line">              [0,1]])</span><br><span class="line"></span><br><span class="line">B = np.array([[2,0],</span><br><span class="line">              [3,4]])</span><br><span class="line">print(A)</span><br><span class="line">print(&quot;--------&quot;)</span><br><span class="line">print(B)</span><br><span class="line">print(&quot;--------&quot;)</span><br><span class="line">print(A* B)</span><br><span class="line">print(&quot;--------&quot;)</span><br><span class="line">print(A.dot(B))</span><br><span class="line">print(&quot;--------&quot;)</span><br><span class="line">print(np.dot(A,B))</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">B = np.arange(3)</span><br><span class="line"></span><br><span class="line">print(B)</span><br><span class="line">print(np.exp(B))  # e的多少次幂</span><br><span class="line">print(np.sqrt(B))  # 开根号</span><br><span class="line"></span><br><span class="line">print(&quot;-----------------------&quot;)</span><br><span class="line">a = np.floor(10*np.random.random((3,4)))</span><br><span class="line">print(a)</span><br><span class="line">print(&quot;-----------------------&quot;)</span><br><span class="line"></span><br><span class="line">print(a.ravel())   #把矩阵拉成向量</span><br><span class="line">print(&quot;-----------------------&quot;)</span><br><span class="line"></span><br><span class="line">a.shape = (6,2)</span><br><span class="line">print(a)</span><br><span class="line">print(&quot;-----------------&quot;)</span><br><span class="line">print(a.T)</span><br><span class="line"></span><br><span class="line">print(a.reshape(4,-1))</span><br></pre></td></tr></table></figure><p>hstack : 矩阵拼接<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;---&quot;)</span><br><span class="line">a = np.floor(10*np.random.random((2,3)))</span><br><span class="line">b = np.floor(10*np.random.random((2,2)))</span><br><span class="line">print(a)</span><br><span class="line">print(&quot;---&quot;)</span><br><span class="line">print(b)</span><br><span class="line">print(&quot;---&quot;)</span><br><span class="line">print(np.hstack((a,b)))   #横着对矩阵进行拼接</span><br><span class="line"></span><br><span class="line">a = np.floor(10*np.random.random((2,2)))</span><br><span class="line">b = np.floor(10*np.random.random((2,2)))</span><br><span class="line">print(a)</span><br><span class="line">print(&quot;----&quot;)</span><br><span class="line">print(b)</span><br><span class="line">print(&quot;----&quot;)</span><br><span class="line">print(np.vstack((a,b)))     #竖着对矩阵进行拼接</span><br></pre></td></tr></table></figure></p><p>hsplit:矩阵切割<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;=========&quot;)</span><br><span class="line">a = np.floor(10*np.random.random((2,12)))</span><br><span class="line">print(a)</span><br><span class="line">print(&quot;-----&quot;)</span><br><span class="line">print(np.hsplit(a,3))</span><br><span class="line">print(&quot;-----&quot;)</span><br><span class="line">print(np.hsplit(a,(3,4)))</span><br><span class="line">a = np.floor(10*np.random.random((12,2)))</span><br><span class="line">print(&quot;-----&quot;)</span><br><span class="line">print(a)</span><br><span class="line">print(np.vsplit(a,3))</span><br></pre></td></tr></table></figure></p><p>矩阵的arg找index、排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">data = np.sin(np.arange(20)).reshape(5,4)</span><br><span class="line">print(data)</span><br><span class="line">ind = data.argmax(axis=0)                  #axis = 0 按照列，找每一列的最大值所在的index</span><br><span class="line">print(ind)</span><br><span class="line">data_max = data[ind,range(data.shape[1])]</span><br><span class="line">print(data_max)</span><br><span class="line"></span><br><span class="line">a = np.arange(0,40,10)</span><br><span class="line">print(a)</span><br><span class="line">b = np.tile(a,(3,5))     #对矩阵进行扩展</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = np.array(\[[4,3,5\],\[1,2,1\]])</span><br><span class="line">print(a)</span><br><span class="line">print(&quot;---------&quot;)</span><br><span class="line">b = np.sort(a,axis=1)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">a.sort(axis=1)</span><br><span class="line">print(&quot;---------&quot;)</span><br><span class="line">print(a)</span><br><span class="line">a = np.array(\[4,3,1,2\])</span><br><span class="line">j = np.argsort(a)          #找的index</span><br><span class="line">print(&quot;---------&quot;)</span><br><span class="line">print(j)</span><br><span class="line">print(&quot;---------&quot;)</span><br><span class="line">print(a[j])</span><br></pre></td></tr></table></figure></p><h3 id="不同复制操作对比"><a href="#不同复制操作对比" class="headerlink" title="不同复制操作对比"></a>不同复制操作对比</h3><p>矩阵中的值的复制：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">a = np.arange(12)</span><br><span class="line">b = a</span><br><span class="line">print(b is a)</span><br><span class="line">b.shape = (3,4)</span><br><span class="line">print(a.shape)</span><br><span class="line">print(id(a))</span><br><span class="line">print(id(b))</span><br><span class="line"></span><br><span class="line">c = a.view()</span><br><span class="line">print(c is a )</span><br><span class="line">c.shape = 2,6</span><br><span class="line">print(a.shape)</span><br><span class="line">c[0,4]=1234    #指向的位置不相同，但是共用的是一套值</span><br><span class="line">print(a)</span><br><span class="line">print(id(a))</span><br><span class="line">print(id(c))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d = a.copy()</span><br><span class="line">print(d is a)</span><br><span class="line">d[0,0] = 9999</span><br><span class="line">print(d)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Numpy基础结构&quot;&gt;&lt;a href=&quot;#Numpy基础结构&quot; class=&quot;headerlink&quot; title=&quot;Numpy基础结构&quot;&gt;&lt;/a&gt;Numpy基础结构&lt;/h3&gt;&lt;p&gt;按照”,”分隔，以str形式读取txt文件&lt;br&gt;type():数据类型&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;import numpy&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;world_alcohol = numpy.genfromtxt(&amp;quot;world_alcohol.txt&amp;quot;, delimiter=&amp;quot;,&amp;quot;,dtype=str)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(type(world_alcohol))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(world_alcohol)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(help(numpy.genfromtxt))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Spark生态圈之Scala(十四) ----- Scala中的函数式编程之隐式转换</title>
    <link href="http://yoursite.com/2018/05/17/BigData-Scala8/"/>
    <id>http://yoursite.com/2018/05/17/BigData-Scala8/</id>
    <published>2018-05-17T08:29:48.000Z</published>
    <updated>2018-05-17T08:44:23.268Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Scala" scheme="http://yoursite.com/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Spark生态圈之Scala(十三) ----- Scala中的函数式编程之类型参数</title>
    <link href="http://yoursite.com/2018/05/17/BigData-Scala7/"/>
    <id>http://yoursite.com/2018/05/17/BigData-Scala7/</id>
    <published>2018-05-17T08:29:43.000Z</published>
    <updated>2018-05-17T09:01:57.785Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Scala" scheme="http://yoursite.com/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Spark生态圈之Scala(十二) ----- Scala中的函数式编程之模式匹配</title>
    <link href="http://yoursite.com/2018/05/17/BigData-Scala6/"/>
    <id>http://yoursite.com/2018/05/17/BigData-Scala6/</id>
    <published>2018-05-17T08:29:36.000Z</published>
    <updated>2018-05-17T10:02:04.394Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h3><p>scala是没有Java中的switch case语法的，相对应的，Scala提供了更加强大的match case语法，即模式匹配，类代替switch case，match case也被称为模式匹配<br>Scala的match case与Java的switch case最大的不同点在于，Java的switch case仅能匹配变量的值，比如1、2、3等；而Scala的match case可以匹配各种情况，比如变量的类型、集合的元素、有值或无值<br>match case的语法如下 : 变量match{case 值=&gt; 语法}。如果值为下划线，则代表了不满足以上所有情况下的默认情况如何处理。此外，match case中，主要一个case分支满足并处理了，就不会继续判断下一个case分支了。（与Java不同，java的switch case需要用break阻止）<br>match case语法最基本的应用，就是对变量的值进行模式匹配</p><p>案例：成绩评价<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def judgeGrade(grade:String)&#123;</span><br><span class="line"> grade match&#123;</span><br><span class="line">      case &quot;A&quot; =&gt; println(&quot;Excellent&quot;)</span><br><span class="line">      case &quot;B&quot;=&gt; println(&quot;Good&quot;)</span><br><span class="line">      case &quot;C&quot;=&gt; println(&quot;Just so so&quot;)</span><br><span class="line">      case _ =&gt; println(&quot;you need work harder&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="在模式匹配中使用if守卫"><a href="#在模式匹配中使用if守卫" class="headerlink" title="在模式匹配中使用if守卫"></a>在模式匹配中使用if守卫</h3><p>Scala的模式匹配语法，有一个特点在于，可以在case后的条件判断中，不仅仅只是提供一个值，而是可以在值后面再加一个if守卫，进行双重过滤</p><p>案例：成绩评价（升级版）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def judgeGrade(name:String,grade:String)&#123;</span><br><span class="line">  grade match&#123;</span><br><span class="line">    case &quot;A&quot;=&gt;println(name+&quot;,you are excellent&quot;)</span><br><span class="line">    case &quot;B&quot;=&gt;println(name+&quot;,you are good&quot;)</span><br><span class="line">    case &quot;C&quot;=&gt;println(name+&quot;,you are just so so&quot;)</span><br><span class="line">    case \_if name==&quot;leo&quot; =&gt;println(name+&quot;,you are a good boy,come on&quot;)</span><br><span class="line">    case \_ =&gt;println(&quot;you need to work harder&quot;)  </span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="在模式匹配中进行变量赋值"><a href="#在模式匹配中进行变量赋值" class="headerlink" title="在模式匹配中进行变量赋值"></a>在模式匹配中进行变量赋值</h3><p>Scala的模式匹配语法，有一个特点在于，可以将模式匹配的默认情况，下划线，替换为一个变量名，此时模式匹配语法就会将要匹配的值赋值给这个变量，从而可以在后面的处理语句中使用要匹配的值</p><p>为什么有这种语法？？思考一下。因为只要使用用case匹配到的值，是不是我们就知道这个值啦！在这个case的处理语句中，是不是就直接可以使用写程序时就已知的值！<br>但是对于下划线<em>这种情况，所有不满足前面的case的值，都会进行</em>这种默认情况进行处理，此时如果我们在处理语句中需要拿到具体的值进行处理呢？那就需要使用这种在模式匹配中进行变量赋值的语法！！</p><p>案例：成绩评价（升级版）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def juegeGrade(name:String,grade:String)&#123;</span><br><span class="line">  grade match&#123;</span><br><span class="line">    case &quot;A&quot; =&gt; println(name+&quot;,you are excellent&quot;)</span><br><span class="line">    case &quot;B&quot;=&gt; println(name+&quot;, you are good&quot;)</span><br><span class="line">    case &quot;C&quot; =&gt; println(name+&quot;,you are just so so&quot;)</span><br><span class="line">    case \_grade if name == &quot;leo&quot; =&gt; println(name+&quot;,you are a good boy,come on,your grade is&quot;+\_grade)</span><br><span class="line">    case \_grade =&gt; println(&quot;you need to work harder,your grade is &quot;+\_grade)</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="对类型进行模式匹配"><a href="#对类型进行模式匹配" class="headerlink" title="对类型进行模式匹配"></a>对类型进行模式匹配</h3><p>Scala的模式匹配一个强大之处就在于，可以直接匹配类型，而不是值！！！这点是java的switch case绝对做不到的。</p><p> 理论知识：对类型如何进行匹配？其他语法与匹配值其实是一样的，但是匹配类型的话，就是要用“case变量：类型=&gt;代码”这种语法，而不是匹配值的“case值=&gt; 代码”这种语法</p><p>案例：异常处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import java.io._</span><br><span class="line"></span><br><span class="line">def processException(e:Exception)</span><br><span class="line">&#123;</span><br><span class="line">  e match&#123;</span><br><span class="line">    case e1 : lllegalArgumentException =&gt; println(&quot;you have illegal arguments! exception is :&quot;+e1)</span><br><span class="line"></span><br><span class="line">    case e2 : FileNotFoundException =&gt; println(&quot;cannot find the file you need read or write!, exception is :&quot;+e2)</span><br><span class="line"></span><br><span class="line">    case e3 : IOException =&gt; println(&quot;you got an error while you were doing IO operation! exception is:&quot;+e3)</span><br><span class="line"></span><br><span class="line">    case _ : Exception =&gt; println(&quot;cannot know which exception you have!&quot;)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">processException(new IllegalArgumentException(&quot;except two arguments,but found one argument.&quot;))</span><br><span class="line"></span><br><span class="line">processException(new FileNotFoundException(&quot;text.txt not found&quot;))</span><br><span class="line"></span><br><span class="line">processException(new IOException(&quot;get data from socket fail.&quot;))</span><br><span class="line"></span><br><span class="line">processException(new ArrayIndexOutOfBoundsException(&quot;array is null&quot;))</span><br></pre></td></tr></table></figure></p><h3 id="对Array和List进行模式匹配"><a href="#对Array和List进行模式匹配" class="headerlink" title="对Array和List进行模式匹配"></a>对Array和List进行模式匹配</h3><p>对Array进行模式匹配，分别可以匹配带有指定元素的数组、带有指定个数元素的数组、以某元素打头的数组<br>对List进行模式匹配，与Array类似，但是需要使用List特有的::操作符</p><p>案例：对朋友打招呼<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def greeting(arr:Array[String])&#123;</span><br><span class="line">  arr match&#123;</span><br><span class="line">    case Array(&quot;Leo&quot;) =&gt; println(&quot;Hi,Leo!&quot;)</span><br><span class="line">    case Array(girl1,girl2,girl3) =&gt; println(&quot;Hi,girls,nice to meet you.&quot;+girl1+&quot;and&quot;+girl2+&quot;and&quot;+girl3)</span><br><span class="line">    case Array(&quot;Leo&quot;,\_*) =&gt; println(&quot;Hi,Leo,please introduce you friends to me&quot;)</span><br><span class="line">    case \_ =&gt; println(&quot;hey,who are you?&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def greeting(list:List[String])&#123;</span><br><span class="line">  list match&#123;</span><br><span class="line">    case &quot;Leo&quot;::Nil =&gt; println(&quot;Hi,Leo!&quot;)</span><br><span class="line">    case girl1::girl2::girl3::Nil =&gt; println(&quot;Hi,girls,nice to meet you.&quot;+girl1+&quot;and&quot;+girl2+&quot;and&quot;+girl3)</span><br><span class="line">    case &quot;Leo&quot;::tail =&gt; println(&quot;Hi,Leo,please introduce your friends to me&quot;)</span><br><span class="line">    case \_=&gt; println(&quot;hey,who are you?&quot;)</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="case-class与模式匹配"><a href="#case-class与模式匹配" class="headerlink" title="case class与模式匹配"></a>case class与模式匹配</h3><p>Scala中提供了一种特殊的类，用case class进行声明，中文也可以称作样例类。case class其实有点类似于Java中的JavaBean的概念。即只定义field，并且由Scala编译时自动提供getter和setter方法，但是没有method</p><p>case class的主构造函数接收的参数通常不需要使用var或val修饰，Scala自动就会使用val修饰（但是如果你自己使用var修饰，那么还是会按照var来）</p><p>Scala自动为case class定义了伴生对象，也就是object，并且定义了apply()方法，该方法接收主构造函数中相同的参数，并返回case class对象</p><p>//案例:学校门禁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line"></span><br><span class="line">case class Teacher(name:String,subject:String) extends Person</span><br><span class="line">case class Studnet(name:String,classroom:String) extends Person</span><br><span class="line"></span><br><span class="line">def judgeIdentify(p:Person)&#123;</span><br><span class="line">  p match&#123;</span><br><span class="line">     case Teacher(name,subject)=&gt; println(&quot;Teacher,name is &quot;+name+&quot;,subject is &quot;+subject)</span><br><span class="line">     case Student(name,classroom)=&gt; println(&quot;Student,name is &quot;+name+&quot;,classroom is&quot;+classroom)</span><br><span class="line">     case \_=&gt; println(&quot;illegal access,please go out of the school!&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">val leo:Person = Student(&quot;leo&quot;,&quot;class1&quot;)</span><br><span class="line">val tom:Person =Teacher(&quot;tom&quot;,&quot;Math&quot;)</span><br><span class="line"></span><br><span class="line">case class Worker(name:String) extends Person</span><br><span class="line"></span><br><span class="line">val jack:Person = Worker(&quot;jack&quot;)</span><br><span class="line"></span><br><span class="line">judgeIdentify(leo)</span><br><span class="line">judgeIdentify(tom)</span><br><span class="line">judgeIdentify(jack)</span><br></pre></td></tr></table></figure></p><h3 id="Option与模式匹配"><a href="#Option与模式匹配" class="headerlink" title="Option与模式匹配"></a>Option与模式匹配</h3><p>Scala有一种特殊的类型，叫做Option。Option有两种值，一种是Some，表示有值，一种是None，表示没有值</p><p>Option通常会用于模式匹配中，用于判断某个变量是有值还是没有值，这比null来的更加简洁明了<br>Option的用法必须掌握，因为Spark源码中大量地使用了Option，比如Some(a),None这种语法，因此必须看得懂Option模式匹配，才能够读懂Spark源码</p><p>//案例：成绩查询<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val grades = Map(&quot;Leo&quot;-&gt;&quot;A&quot;,&quot;Jack&quot;-&gt;&quot;B&quot;,&quot;Jen&quot;-&gt;&quot;C&quot;)</span><br><span class="line"></span><br><span class="line">def getGrade(name:String)&#123;</span><br><span class="line">    val grade = grades.get(name)</span><br><span class="line">    grade match&#123;</span><br><span class="line">      case Some(grade) =&gt; println(&quot;your grade is &quot;+grade)</span><br><span class="line">      case None =&gt; println(&quot;Sorry , your grade information is not in the system&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;模式匹配&quot;&gt;&lt;a href=&quot;#模式匹配&quot; class=&quot;headerlink&quot; title=&quot;模式匹配&quot;&gt;&lt;/a&gt;模式匹配&lt;/h3&gt;&lt;p&gt;scala是没有Java中的switch case语法的，相对应的，Scala提供了更加强大的match case语法，即模式匹配，类代替switch case，match case也被称为模式匹配&lt;br&gt;Scala的match case与Java的switch case最大的不同点在于，Java的switch case仅能匹配变量的值，比如1、2、3等；而Scala的match case可以匹配各种情况，比如变量的类型、集合的元素、有值或无值&lt;br&gt;match case的语法如下 : 变量match{case 值=&amp;gt; 语法}。如果值为下划线，则代表了不满足以上所有情况下的默认情况如何处理。此外，match case中，主要一个case分支满足并处理了，就不会继续判断下一个case分支了。（与Java不同，java的switch case需要用break阻止）&lt;br&gt;match case语法最基本的应用，就是对变量的值进行模式匹配&lt;/p&gt;
&lt;p&gt;案例：成绩评价&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;def judgeGrade(grade:String)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; grade match&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      case &amp;quot;A&amp;quot; =&amp;gt; println(&amp;quot;Excellent&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      case &amp;quot;B&amp;quot;=&amp;gt; println(&amp;quot;Good&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      case &amp;quot;C&amp;quot;=&amp;gt; println(&amp;quot;Just so so&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      case _ =&amp;gt; println(&amp;quot;you need work harder&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Scala" scheme="http://yoursite.com/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Spark生态圈之Scala(十一) ----- Scala中的函数式编程之集合操作</title>
    <link href="http://yoursite.com/2018/05/17/BigData-Scala5-2/"/>
    <id>http://yoursite.com/2018/05/17/BigData-Scala5-2/</id>
    <published>2018-05-17T08:25:19.000Z</published>
    <updated>2018-05-17T08:39:01.202Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Scala的集合体系"><a href="#Scala的集合体系" class="headerlink" title="Scala的集合体系"></a>Scala的集合体系</h3><p>Scala中的集合体系主要包括:Iterable、Seq、Set、Map。其中Iterable是所有集合Trait的根trai。这个结构与Java的集合体系非常相似。<br>Scala中的集合是分成可变和不可变两类集合的，其中可变集合就是说，集合的元素可以动态修改，而不可变集合的元素在初始化之后，就无法修改了。分别对应scala.collection.mutable和scala.collection.immutable两个包<br>Seq下包含了Range、ArrayBuffer、List等子trait。其中Range就代表了一个序列，通常可以使用“1  to 10”这种语法来产生一个Range。ArrayBuffer就类似于Java中的ArrayList<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">range: 1 to 10  1.to(10)   1.until(10)</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>List 代表一个不可变的列表<br>List的创建，val list = List(1,2,3,4)<br>List有head和tail，head代表Lit的第一个元素，tail代表第一个元素之后的所有元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.head , list.tail</span><br></pre></td></tr></table></figure><p>List有特殊的::操作符，可以用于将head和tail合并成一个List,0::list</p><p>::这种操作符要清楚，在spark源码中都是有体现的，一定要能够看懂！</p><p>如果一个List只有一个元素，那么它的head就是这个元素，它的tail就是Nil</p><p>案例：用递归函数来给List中每个元素都加上指定前缀，并打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def decorator(l:List[Int],prefix:String)&#123;</span><br><span class="line">  if(l ! = Nil)</span><br><span class="line">  &#123;</span><br><span class="line">     println(prefix+l.head)</span><br><span class="line">     decorator(l.tail,prefix)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>LinkedList代表一个可变的列表，使用elem可以引用其头部，使用next可以引用其尾部<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">val l = scala.collection.LinkedList(1,2,3,4,5);  l.elem;l.next</span><br><span class="line"></span><br><span class="line">//案例：使用while循环将LinkedList中的每个元素都乘以2</span><br><span class="line">val list = scala.collection.mutable.LinkedList(1,2,3,4,5)</span><br><span class="line">var currentList = list</span><br><span class="line">while(currentList !=Nil)</span><br><span class="line">&#123;</span><br><span class="line">  currentList.elem = currentList.elem * 2</span><br><span class="line">  currentList.elem = currentList.elem * 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>案例：使用while循环将LinkedList中，从第一个元素开始，每隔一个元素，乘以2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">val list = scala.collection.mutable.LinkedList(1,2,3,4,5,6,7,8,9,10)</span><br><span class="line">var currentList = list</span><br><span class="line">var first = true</span><br><span class="line">while(currentList !=Nil &amp;&amp; currentList.next!=Nil)</span><br><span class="line">&#123;</span><br><span class="line">  if(first) &#123;currentList.elem = currentList.elem * 2;first = false &#125;</span><br><span class="line">  currentList = currentList.next.next</span><br><span class="line"></span><br><span class="line">  if(currentList != Nil)</span><br><span class="line">  currentList.elem = currentList.elem * 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set代表一个没有重复元素的集合<br>将重复元素加入Set是没有用的，比如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val s = Set(1,2,3);s+1;s+4</span><br></pre></td></tr></table></figure><p>而且Set是不保证插入顺序的，也就是说，Set中的元素是乱序的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val s = new scala.collection.mutable.HashSet[Int] ; s+=1;s+=2;s+=5</span><br></pre></td></tr></table></figure><p>LinkedHashSet会用一个链表维护插入顺序，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val s = new scala.collection.mutable.LinkedHashSet[Int]()；i+=1;s+=2;s+=5</span><br></pre></td></tr></table></figure><p>SortedSet会自动根据key来进行排序，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val s = scala.collection.mutable.SortedSet(&quot;orange&quot;,&quot;apple&quot;,&quot;banana&quot;)</span><br></pre></td></tr></table></figure><h3 id="集合的函数式编程"><a href="#集合的函数式编程" class="headerlink" title="集合的函数式编程"></a>集合的函数式编程</h3><p>集合的函数式编程非常非常之重要<br>必须完全掌握和理解Scala的高阶函数是什么意思，Scala的集合类的map、flatMap、reduce、reduceLeft、foreach等这些函数，就是高阶函数，因为可以接收其他函数作为参数</p><p>高阶函数的使用，也是Scala与Java最大的一点不同！！！因为Java里面是没有函数式编程的，也肯定没有高阶函数，也肯定无法直接将函数传入一个方法，或者让一个方法返回一个函数<br>对Scala高阶函数的理解、掌握和使用，可以大大增强你的技术，而且也是Scala最有诱惑力、最有优势的一个功能！！！</p><p>此外，在Spark源码中，有大量的函数式编程，以及基于集合的高阶函数的使用！！！所以必须掌握，才能看懂spark源码</p><p>map案例实战：为List中每个元素都添加一个前缀<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List(&quot;Leo&quot;,&quot;Jen&quot;,&quot;Peter&quot;,&quot;Jack&quot;).map(&quot;name  is &quot;+ \_)</span><br></pre></td></tr></table></figure></p><p>flatMap案例实战：将List中的多行句子拆分成单词<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List(&quot;Hello World&quot;,&quot;You Me&quot;).flatMap(\_.split(&quot; &quot;))</span><br></pre></td></tr></table></figure></p><p>foreach案例实战：打印List中的每个单词<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List(&quot;I&quot;,&quot;have&quot;,&quot;a&quot;,&quot;beautiful&quot;,&quot;house&quot;).foreach(println(\_))</span><br></pre></td></tr></table></figure></p><p>zip案例实战：对学生姓名和学生成绩进行关联<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List(&quot;Leo&quot;,&quot;Jen&quot;,&quot;Peter&quot;,&quot;Jack&quot;).zip(List(100,90,75,83))</span><br></pre></td></tr></table></figure></p><h3 id="综合案例：单词计数"><a href="#综合案例：单词计数" class="headerlink" title="综合案例：单词计数"></a>综合案例：单词计数</h3><p>使用scala的io包将文本文件内的数据读取出来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val lines1 = scala.io.Source.fromFile(&quot;&quot;).mkString</span><br><span class="line">val lines2 = scala.io.Source.fromFile(&quot;&quot;).mkString</span><br></pre></td></tr></table></figure></p><p>使用List的伴生对象，将多个文件内的内容创建为一个List<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val lines = List(lines1,lines2)</span><br></pre></td></tr></table></figure></p><p>下面这一行才是我们的案例的核心和重点，因为有多个高阶函数的链式调用，以及大量下划线的使用，如果没有透彻掌握之前的课程讲解的Scala函数式编程，那么下面这一行代码，完全可能会看不懂！！！<br>但是下面这行代码其实就是Scala编程的精髓所在，就是函数式编程，也是Scala相较于Java等编程员最大的功能优势所在<br>而且，spark的源码中大量使用了这种复杂的链式调用的函数式编程<br>而且，spark本身提供的开发人员使用的编程api的风格，完全沿用了Scala的函数式编程，比如Spark本身的api中就提供了map、flatMap、reduce、foreach，以及更高级的reduceByKey、groupbyKey等高阶函数<br>如果要使用Scala进行spark工程的开发，那么就必须掌握这种复杂的高阶函数的链式调用！！！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lines.flatMap(_.split(&quot; &quot;)).map((\_,1)).map(\_.\_2).reduceLeft(\_ + \_)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Scala的集合体系&quot;&gt;&lt;a href=&quot;#Scala的集合体系&quot; class=&quot;headerlink&quot; title=&quot;Scala的集合体系&quot;&gt;&lt;/a&gt;Scala的集合体系&lt;/h3&gt;&lt;p&gt;Scala中的集合体系主要包括:Iterable、Seq、Set、Map。其中Iterable是所有集合Trait的根trai。这个结构与Java的集合体系非常相似。&lt;br&gt;Scala中的集合是分成可变和不可变两类集合的，其中可变集合就是说，集合的元素可以动态修改，而不可变集合的元素在初始化之后，就无法修改了。分别对应scala.collection.mutable和scala.collection.immutable两个包&lt;br&gt;Seq下包含了Range、ArrayBuffer、List等子trait。其中Range就代表了一个序列，通常可以使用“1  to 10”这种语法来产生一个Range。ArrayBuffer就类似于Java中的ArrayList&lt;br&gt; &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;range: 1 to 10  1.to(10)   1.until(10)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Scala" scheme="http://yoursite.com/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Spark生态圈之Scala(十) ----- Scala中的函数式编程</title>
    <link href="http://yoursite.com/2018/05/17/BigData-Scala5-1/"/>
    <id>http://yoursite.com/2018/05/17/BigData-Scala5-1/</id>
    <published>2018-05-17T08:14:16.000Z</published>
    <updated>2018-05-17T08:39:02.131Z</updated>
    
    <content type="html"><![CDATA[<h3 id="将函数赋值给变量"><a href="#将函数赋值给变量" class="headerlink" title="将函数赋值给变量"></a>将函数赋值给变量</h3><p>Scala中的函数是一等公民，可以独立定义，独立存在，而且直接将函数作为值赋值给变量<br>Scala的语法规定，将函数复制给变量时，必须在函数后面加上空格和下划线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def sayHello(name:String) &#123;println(&quot;Hello,&quot;+name)&#125;</span><br><span class="line"></span><br><span class="line">val sayHelloFunc = sayHello _</span><br><span class="line"></span><br><span class="line">sayHelloFunc(&quot;leo&quot;)</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>Scala中，函数也可以不需要命名，此时函数被称为匿名函数。<br>可以直接定义函数之后，将函数赋值给某个变量；也可以将直接定义的匿名函数传入其他函数之中<br>Scala定义匿名函数的语法规则就是:(参数名:参数类型) =&gt; 函数体<br>这种匿名函数的语法必须深刻理解和掌握，在spark的中有大量这样的语法，如果没有掌握，是看不懂spark源码的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val sayHelloFunc = (name:String) =&gt; println(&quot;Hello,&quot;+name)</span><br></pre></td></tr></table></figure></p><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>Scala中，由于函数是一等公民，因此可以直接将某个函数传入其他函数，作为参数。这个功能是极其强大的，也是Java这种面向对象的编程语言所不具备的。<br>接收其他函数作为参数的函数，也被称作高阶函数(higher-order function)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val sayHelloFunc = (name:String) =&gt; println(&quot;Hello,&quot;+name)</span><br><span class="line">def greeting(func:(String) =&gt;Unit , name:String) &#123;func(name)&#125;</span><br><span class="line">greeting(sayeHelloFunc,&quot;leo&quot;)</span><br><span class="line"></span><br><span class="line">Array(1,2,3,4,5).map((num:Int) =&gt; num*num)</span><br></pre></td></tr></table></figure></p><p>高阶函数的另外一个功能是将函数作为返回值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def getGreetingFunc(msg:String) = (name:String) =&gt; println(msg+&quot;,&quot;+name)</span><br><span class="line">val greetingFunc = getGreetingFunc(&quot;hello&quot;)</span><br><span class="line">greetingFunc(&quot;leo&quot;)</span><br></pre></td></tr></table></figure></p><h3 id="高阶函数的类型推断"><a href="#高阶函数的类型推断" class="headerlink" title="高阶函数的类型推断"></a>高阶函数的类型推断</h3><p>高阶函数可以自动推断出参数类型，而不需要写明类型；而且对于只有一个参数的函数，还可以省去其小括号；如果仅有的一个参数在右侧的函数体内只使用一次，则还可以将接收参数省略，并且将参数用<em>来代替<br> 诸如3*\</em>的这种语法，必须掌握！！Spark源码中大量使用了这种语法！！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def greeting(func:(String) =&gt; Unit,name:String) &#123;func(name)&#125;</span><br><span class="line"></span><br><span class="line">greeting((name:String) =&gt; println(&quot;Hello,&quot;+name),&quot;leo&quot;)</span><br><span class="line"></span><br><span class="line">greeting((name)=&gt;println(&quot;Hello&quot;+name),&quot;leo&quot;)</span><br><span class="line"></span><br><span class="line">greeting(name=&gt;println(&quot;Hello,&quot;+name),&quot;leo&quot;)</span><br><span class="line"></span><br><span class="line">def triple(func:(Int)=&gt;Int)=&#123;func(3)&#125;</span><br><span class="line"></span><br><span class="line">triple(3*_)</span><br></pre></td></tr></table></figure></p><h3 id="Scala的常用高阶函数"><a href="#Scala的常用高阶函数" class="headerlink" title="Scala的常用高阶函数"></a>Scala的常用高阶函数</h3><p>map:对传入的每个元素都进行映射，返回一个处理后的元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array(1,2,3,4,5).map(2*\_)</span><br></pre></td></tr></table></figure></p><p>foreach:对传入的每个元素都进行处理，但是没有返回值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1 to 9).map(&quot;*&quot; \* \_).foreach(println)</span><br></pre></td></tr></table></figure></p><p>filter:对传入的每个元素都进行条件判断，如果对元素返回true，则保留该元素，否则过滤掉该元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1 to 20).filter(_ % 2 == 0 )</span><br></pre></td></tr></table></figure></p><p>reduceLeft:从左侧元素开始，进行reduce操作，即先对元素1和元素2进行处理，然后将结果与元素3处理，再将结果与元素4处理，依次类推，即为reduce<br>下面这个操作就相当于1<em>2</em>3<em>4</em>5<em>6</em>7<em>8</em>9<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1 to 9).reduceLeft(\_*\_)</span><br></pre></td></tr></table></figure></p><p>sortWith:对元素进行两两比较，进行排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array(3,2,5,4,10,1).sortWith(\_&lt;\_)</span><br></pre></td></tr></table></figure></p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包最简洁的解释，函数在变量不处于其有效作用域时，还能够对变量进行访问，即为闭包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def getGreetingFunc(msg:String) = (name:String) =&gt; println(msg+&quot;,&quot;+name)</span><br><span class="line"></span><br><span class="line">val greetingFuncHello = getGreetingFunc(&quot;hello&quot;)</span><br><span class="line"></span><br><span class="line">val greetingFuncHi = getGreetingFunc(&quot;hi&quot;)</span><br></pre></td></tr></table></figure></p><p>两次调用getGreetingFunc函数，传入不同的msg，并创建不同的函数返回<br>然而，msg只有一个局部变量，却在getGreetingFunc执行完之后，还可以继续存在创建的函数之中；greetingFuncHello(“leo”)，调用时，值为”hello”的msg被保留在了函数体内部，可以反复的使用</p><p>这种变量超出了其作用域，还可以使用的情况，即为闭包<br>Scala通过为每个函数创建对象来实现闭包，实际上对于getGreetingFunc函数创建的函数，msg是作为函数对象的变量存在的，因此每个函数才可以拥有不同的msg<br>Scala编译器会确保上述闭包机制</p><h3 id="SAM转换"><a href="#SAM转换" class="headerlink" title="SAM转换"></a>SAM转换</h3><p>在Java中，不支持直接将函数传入一个方法作为参数，通常来说，唯一的方法就是定义一个实现了某个接口的类的实例对象，该对象只有一个方法；而这些接口都只有单个的抽象方法，也就是single abstract method，简称为SAM</p><p>由于Scala是可以调用Java的代码的，因此当我们调用Java的某个方法时，可能就不得不创建SAM传递给方法，非常麻烦；但是Scala又是支持直接传递函数的。此时就可以使用Scala提供的，在调用Java方法时，使用的功能，SAM转换，即将SAM转换为Scala函数</p><p>要使用SAM转换，需要使用Scala提供的特性，隐式转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import javax.swing._</span><br><span class="line">import java.awt.event._</span><br><span class="line"></span><br><span class="line">val button = new JButton(&quot;Click&quot;)</span><br><span class="line">button.addActionListener(new ActionListener&#123;</span><br><span class="line">  override def actionPerformed(event:ActionEvent)&#123;</span><br><span class="line">    println(&quot;Click Me!!!&quot;)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">implicit def getActionListener(actionProcessFunc:(ActionEvent)=&gt;Unit) = new ActionListener&#123;</span><br><span class="line">  override def actionPerformed(event:ActionEvent)&#123;</span><br><span class="line">    actionProcessFunc(event)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Currying函数"><a href="#Currying函数" class="headerlink" title="Currying函数"></a>Currying函数</h3><p>Curring函数，指的是，将原来接收两个参数的一个函数，转换为两个函数，第一个函数接收原先的第一个参数，然后返回接收原先第二个参数的第二个函数。<br>在函数调用的过程中，就变为两个函数连续调用的形式<br>在Spark的源码中也有体现，所以对()()这种形式的Curring函数，必须掌握！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def sum(a:Int,b:Int)=a+b</span><br><span class="line">sum(1,1)</span><br><span class="line"></span><br><span class="line">def sum2(a:Int) = (b:Int)=&gt;a+b</span><br><span class="line">sum2(1)(1)</span><br><span class="line"></span><br><span class="line">def sum3(a:Int)(b:Int)=a+b</span><br></pre></td></tr></table></figure><h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>Scala中，不需要使用return来返回函数的值，函数最后一行语句的值，就是函数的返回值。在Scala中，return用于在匿名函数中返回值给包含匿名函数的带名函数，并作为带名函数的返回值。<br>使用return的匿名函数，是必须给出返回类型的，否则无法通过编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def greeting(name:String)=&#123;</span><br><span class="line"> def sayHello(name:String):String=&#123;</span><br><span class="line">     return &quot;Hello,&quot;+name</span><br><span class="line">  &#125;</span><br><span class="line"> sayHello(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;将函数赋值给变量&quot;&gt;&lt;a href=&quot;#将函数赋值给变量&quot; class=&quot;headerlink&quot; title=&quot;将函数赋值给变量&quot;&gt;&lt;/a&gt;将函数赋值给变量&lt;/h3&gt;&lt;p&gt;Scala中的函数是一等公民，可以独立定义，独立存在，而且直接将函数作为值赋值给变量&lt;br&gt;Scala的语法规定，将函数复制给变量时，必须在函数后面加上空格和下划线&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;def sayHello(name:String) &amp;#123;println(&amp;quot;Hello,&amp;quot;+name)&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;val sayHelloFunc = sayHello _&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sayHelloFunc(&amp;quot;leo&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Scala" scheme="http://yoursite.com/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Spark生态圈之Scala(九) ----- Scala中的面向对象编程之Trait</title>
    <link href="http://yoursite.com/2018/05/17/BigData-Scala4-4/"/>
    <id>http://yoursite.com/2018/05/17/BigData-Scala4-4/</id>
    <published>2018-05-17T08:13:01.000Z</published>
    <updated>2018-05-17T08:39:02.957Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Scala" scheme="http://yoursite.com/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Spark生态圈之Scala(八) ----- Scala中的面向对象编程之继承</title>
    <link href="http://yoursite.com/2018/05/17/BigData-Scala4-3/"/>
    <id>http://yoursite.com/2018/05/17/BigData-Scala4-3/</id>
    <published>2018-05-17T08:04:10.000Z</published>
    <updated>2018-05-17T08:39:17.363Z</updated>
    
    <content type="html"><![CDATA[<h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><p>scala中，让子类继承父类，与Java一样，也是使用extends关键字<br>继承就代表，子类可以从父类继承父类的field和method，然后子类可以在自己内部放入父类所没有，子类特有的field和method；使用继承可以有效复用代码<br>子类可以覆盖父类的field和method；但是如果父类用final修饰，field和method用final修饰，则该类是无法被继承的，field和method是无法被覆盖的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  private var name = &quot;leo&quot;</span><br><span class="line">  def getName = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">  private var score = &quot;A&quot;</span><br><span class="line">  def getScore = score</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="override和super"><a href="#override和super" class="headerlink" title="override和super"></a>override和super</h3><p>Scala中，如果子类要覆盖一个父类中的非抽象方法，则必须使用override关键字<br>override关键字可以帮助我们尽早地发现代码里的错误，比如:override修饰的父类方法的方法名我们拼写错了；比如要覆盖的父类方法的参数我们写错了；等等<br>此外，在子类覆盖父类方法之后，如果我们在子类中就是要调用父类的被覆盖的方法呢？那就可以使用super关键字。显式地指定要调用父类的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  private var name = &quot;leo&quot;</span><br><span class="line">  def getName = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">  private var score = &quot;A&quot;</span><br><span class="line">  def getScore = score</span><br><span class="line">  override def getName = &quot;Hi,I&apos;m &quot;+super.getName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="override-field"><a href="#override-field" class="headerlink" title="override field"></a>override field</h3><p>Scala中，子类可以覆盖父类的val field，而且子类的val field还可以覆盖父类的val field的getter方法；只要在子类中使用override关键字即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  val name:String = &quot;Person&quot;</span><br><span class="line">  def age:Int = 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person&#123;</span><br><span class="line"> override val name:String = &quot;leo&quot;</span><br><span class="line"> override val age:Int = 30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="isInstanceOf和asInstanceOf"><a href="#isInstanceOf和asInstanceOf" class="headerlink" title="isInstanceOf和asInstanceOf"></a>isInstanceOf和asInstanceOf</h3><p>如果我们创建了子类的对象，但是又将其赋予了父类类型的变量。则在后续的程序中，我们又需要将父类类型的变量转换为子类类型的变量，应该如何做?<br>首先，需要使用isInstanceOf判断对象是否是指定类的对象，如果是的话，则可以使用asInstanceOf将对象转换为指定类型<br>注意，如果对象时null,则isInstanceOf一定返回false，asInstanceOf一定返回null<br>注意，如果没有用isInstanceOf先判断对象是否为指定类的实例，就直接用asInstanceOf转换，则可能抛出异常<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">class Student extends Person</span><br><span class="line"></span><br><span class="line">val p:Person  = new Student</span><br><span class="line"></span><br><span class="line">val s:Student = null</span><br><span class="line">if(p.isInstanceOf[Student]) s = p.asInstanceOf[Student]</span><br></pre></td></tr></table></figure></p><h3 id="getClass和classOf"><a href="#getClass和classOf" class="headerlink" title="getClass和classOf"></a>getClass和classOf</h3><p>isInstanceOf只能判断出对象是否是指定类以及其子类的对象，而不能精确判断出，对象就是指定类的对象<br>如果要求精确地判断对象就是指定类的对象，那么就只能使用getClass和classOf了<br>对象.getClass可以精确获取对象的类，classOf[类]可以精确获取类，然后使用==操作符即可判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line"></span><br><span class="line">class Student extends Person</span><br><span class="line"></span><br><span class="line">val p:Person = new Student</span><br><span class="line"></span><br><span class="line">p.isInstanceOf[Person]</span><br><span class="line"></span><br><span class="line">p.getClass == classOf[Person]</span><br><span class="line"></span><br><span class="line">p.getClass == classOf[Student]</span><br></pre></td></tr></table></figure></p><h3 id="使用模式匹配进行类型判断"><a href="#使用模式匹配进行类型判断" class="headerlink" title="使用模式匹配进行类型判断"></a>使用模式匹配进行类型判断</h3><p>但是在实际开发中，比如spark的源码中，大量的地方都是使用了模式匹配的方式来进行类型的判断，这种方式更加地简介明了，而且代码得可维护性和可扩展性也非常的高<br>使用模式匹配，功能性上来说，与isInstanceOf一样，也是判断主要是该类以及该类的子类的对象即可，不是精确判断的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line"></span><br><span class="line">class Student extends Person</span><br><span class="line"></span><br><span class="line">val p:Person = new Student</span><br><span class="line"></span><br><span class="line">p match&#123;</span><br><span class="line"> case per:Person =&gt; println(&quot;it&apos;s Person&apos;s object&quot;)</span><br><span class="line"> case_ =&gt; println(&quot;unknown type&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h3><p>跟java一样，scala中同样可以使用protected关键字来修饰field和method，这样在子类中就不需要super关键字，直接就可以访问field和method<br>还可以使用protected[this]，则只能在当前子类对象中访问父类的field和method，无法通过其他子类对象访问父类的field和method<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  protected var name:String = &quot;leo&quot;</span><br><span class="line">  protected[this] var hobby:String = &quot;game&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person</span><br><span class="line">&#123;</span><br><span class="line">  def sayHello=println(&quot;Hello,&quot;+name)</span><br><span class="line">  def makeFriends(s:Student)&#123;</span><br><span class="line">   println(&quot;my hobby is &quot;+hobby+&quot;,your hobby is&quot;+s.hobby)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其它实例可以访问:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  protected var name:String = &quot;leo&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">  def makeFriends(s:Student): Unit =&#123;</span><br><span class="line">    println(&quot;Hi,my name is &quot;+name+&quot;,your name is &quot;+s.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val s1 = new Student</span><br><span class="line">val s2 = new Student</span><br><span class="line">s1.makeFriends(s2)</span><br></pre></td></tr></table></figure></p><p>其他实例不能访问 : (使用protected[this])</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">  protected[this] var name:String = &quot;leo&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Person&#123;</span><br><span class="line">  def makeFriends(s:Student): Unit =&#123;</span><br><span class="line">    println(&quot;Hi,my name is &quot;+name+&quot;,your name is &quot;+s.name)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val s1 = new Student</span><br><span class="line">val s2 = new Student</span><br><span class="line">s1.makeFriends(s2)</span><br></pre></td></tr></table></figure><h3 id="调用父类的constructor"><a href="#调用父类的constructor" class="headerlink" title="调用父类的constructor"></a>调用父类的constructor</h3><p>Scala中，每个类可以有一个主constructor和任意多个辅助constructor，而每个辅助constructor的第一行都必须是调用其他辅助constructor或者是主constructor；因此子类的辅助constructor是一定不可能直接调用父类的constructor的<br>只能在子类的主constructor中调用父类的constructor，以下这种语法，就是通过子类的主构造函数来调用父类的构造函数<br>注意！如果是父类中接收的参数，比如name和age，子类中接收时，就不要用任何val或var来修饰了，否则会认为是子类要覆盖父类的field<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person(val name:String,val age:Int)</span><br><span class="line"></span><br><span class="line">class Student(name:String,age:Int,var score:Double) extends Person(name,age)&#123;</span><br><span class="line">    def this(name:String)&#123;</span><br><span class="line">     this(name,0,0)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def this(age:Int)</span><br><span class="line">  &#123;</span><br><span class="line">    this(&quot;leo&quot;,age,0)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;extends&quot;&gt;&lt;a href=&quot;#extends&quot; class=&quot;headerlink&quot; title=&quot;extends&quot;&gt;&lt;/a&gt;extends&lt;/h3&gt;&lt;p&gt;scala中，让子类继承父类，与Java一样，也是使用extends关键字&lt;br&gt;继承就代表，子类可以从父类继承父类的field和method，然后子类可以在自己内部放入父类所没有，子类特有的field和method；使用继承可以有效复用代码&lt;br&gt;子类可以覆盖父类的field和method；但是如果父类用final修饰，field和method用final修饰，则该类是无法被继承的，field和method是无法被覆盖的&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class Person&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  private var name = &amp;quot;leo&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  def getName = name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class Student extends Person&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  private var score = &amp;quot;A&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  def getScore = score&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Scala" scheme="http://yoursite.com/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Spark生态圈之Scala(七) ----- Scala中的面向对象编程之对象</title>
    <link href="http://yoursite.com/2018/05/17/BigData-Scala4-2/"/>
    <id>http://yoursite.com/2018/05/17/BigData-Scala4-2/</id>
    <published>2018-05-17T07:53:35.000Z</published>
    <updated>2018-05-17T08:39:59.063Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>object,相当于class的单个实例，通常在里面放一些静态的field或者method<br>第一次调用Object的方法时，就会执行object的constructor，也就是object内部不在method中的代码；但是object不能定义接受参数的constructor<br>注意，object的constructor只会在其第一次被调用时执行一次，以后再次调用就不会再次执行constructor了<br>object通常用于作为单例模式的实现，或者放class的静态成员，比如工具方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">object Person&#123;</span><br><span class="line">  private var eyeNum = 2</span><br><span class="line">  println(&quot;this Person object!&quot;)</span><br><span class="line">  def getEysNum = eyeNum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="Object继承抽象类"><a href="#Object继承抽象类" class="headerlink" title="Object继承抽象类"></a>Object继承抽象类</h3><p>object 的功能其实和class类似，除了不能定义接受参数的constructor之外<br>object也可以继承抽象类，并覆盖抽象类中的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">abstract class Hello(var message:String)&#123;</span><br><span class="line">  def sayHello(name:String):Unit</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object HelloImpl extends Hello(&quot;Hello&quot;)&#123;</span><br><span class="line">  override def sayHello(name:String)=&#123;</span><br><span class="line">    println(message+&quot;,&quot;+name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="伴生对象"><a href="#伴生对象" class="headerlink" title="伴生对象"></a>伴生对象</h3><p>如果有一个class,还有一个与class同名的object，那么就称这个object是class的伴生对象，class是object的伴生类<br> 伴生类和伴生对象必须存放在一个.scala文件之中<br>伴生类和伴生对象，最大的特点就在于，互相可以访问private field<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person(val name:String,val age:Int)&#123;</span><br><span class="line">  def sayHello = println(&quot;Hi,&quot;+name+&quot;,I guess you are&quot;+age+&quot;years old!&quot;+&quot;,and usually you must have &quot;+Person.eyeNum+&quot; eyes.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object Person&#123;</span><br><span class="line">  private val eyeNum = 2</span><br><span class="line">  def getEyeNum = eyeNum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="apply方法"><a href="#apply方法" class="headerlink" title="apply方法"></a>apply方法</h3><p>object 中非常重要的一个特殊方法，就是apply方法<br>通常在伴生对象中实现apply方法，并在其中实现构造半生类的对象的功能<br>而创建伴生类的对象时，通常不会使用new Class的方式，而是使用Class()的方式，隐式地调用伴生对象得apply方法，这样会让对象创建更加简洁<br>比如，Array类的伴生对象得apply方法就实现了接收可变数量的参数，并创建一个Array对象的功能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val a = Array(1,2,3,4,5)</span><br></pre></td></tr></table></figure></p><p>比如，定义自己的伴生类和伴生对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Person(val name:String)</span><br><span class="line">object Person&#123;</span><br><span class="line">  def apply(name:String) = new Person(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h3><p>就如同java中，如果要运行一个程序，必须编写一个包含main方法类一样；在scala中，如果要运行一个应用程序，那么必须有一个main方法，作为入口<br>scala中的main方法定义为def main(args:Array[String]),并且必须定义在object中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">object HelloWorld&#123;</span><br><span class="line">  def main(args:Array[String])&#123;</span><br><span class="line">    println(&quot;Hello World!!!&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除了自己实现main方法之外，还可以继承App Trait，然后将需要在main方法中运行的代码，直接作为object的constructor代码；而且用args可以接受传入的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">object HelloWorld extends App&#123;</span><br><span class="line">  if(args.length&gt;0) println(&quot;hello,&quot;+args(0))</span><br><span class="line">  else println(&quot;Hello World!!!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果要运行上述代码，需要将其方法.scala文件，然后先使用scalac编译，再用scala执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scalac HelloWorld.scala</span><br><span class="line">scala -Dscala.time HelloWorld</span><br></pre></td></tr></table></figure></p><p>App Trait的工作原理为：App Trait继承自DeployedInit Trait,scalac命令进行编译时，会把继承App Trait的object的constructor代码放到DeplayedInit Trait的deplayedInit方法中执行</p><h3 id="Object实现枚举功能"><a href="#Object实现枚举功能" class="headerlink" title="Object实现枚举功能"></a>Object实现枚举功能</h3><p>Scala没有直接提供类似于java中的Enum这样的枚举特性，如果要实现枚举，则需要用object继承Enumerationlei，并且调用value方法来初始化枚举值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">object Season extends Enumeration&#123;</span><br><span class="line">  val SPRING,SUMMER,AUTUMN,WINTER = Value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还可以通过Value传入枚举值的id和name，通过id和toString可以获取，还可以通过id和name来查找枚举值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">object Season extends Enumeration&#123;</span><br><span class="line">  val SPRING = Value(0,&quot;spring&quot;)</span><br><span class="line">  val SUMMER = Value(1,&quot;summer&quot;)</span><br><span class="line">  val AUTUMN = Value(2,&quot;autumn&quot;)</span><br><span class="line">  val WINTER = Value(3,&quot;winter&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Season(0)</span><br><span class="line">Season.withName(&quot;spring&quot;)</span><br></pre></td></tr></table></figure></p><p>使用枚举object.values可以遍历枚举值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(ele &lt;- Season.values) println(ele)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Object&quot;&gt;&lt;a href=&quot;#Object&quot; class=&quot;headerlink&quot; title=&quot;Object&quot;&gt;&lt;/a&gt;Object&lt;/h3&gt;&lt;p&gt;object,相当于class的单个实例，通常在里面放一些静态的field或者method&lt;br&gt;第一次调用Object的方法时，就会执行object的constructor，也就是object内部不在method中的代码；但是object不能定义接受参数的constructor&lt;br&gt;注意，object的constructor只会在其第一次被调用时执行一次，以后再次调用就不会再次执行constructor了&lt;br&gt;object通常用于作为单例模式的实现，或者放class的静态成员，比如工具方法&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;object Person&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  private var eyeNum = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  println(&amp;quot;this Person object!&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  def getEysNum = eyeNum&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Scala" scheme="http://yoursite.com/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
  <entry>
    <title>Spark生态圈之Scala(六) ----- Scala中的面向对象编程之类</title>
    <link href="http://yoursite.com/2018/05/17/BigData-Scala4-1/"/>
    <id>http://yoursite.com/2018/05/17/BigData-Scala4-1/</id>
    <published>2018-05-17T07:44:10.000Z</published>
    <updated>2018-05-17T08:39:09.105Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><p>定义类，包含field以及方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class HelloWorld</span><br><span class="line">&#123;</span><br><span class="line">   private var name = &quot;leo&quot;</span><br><span class="line">   def sayHello() &#123; print(&quot;Hello , &quot;+name)&#125;</span><br><span class="line">   def getName = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//创建类的对象，并调用其方法</span><br><span class="line">val helloWorld = new HelloWorld</span><br><span class="line">helloWorld.sayHello()</span><br><span class="line"></span><br><span class="line">//也可以不加括号，如果定义方法时不带括号，则调用方法时也不能带括号</span><br><span class="line">print(helloWorld.getName)</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="field的getter与setter"><a href="#field的getter与setter" class="headerlink" title="field的getter与setter"></a>field的getter与setter</h3><p>定义不带private的var field，此时scala生成的面向JVM的类时，会定义为private的name字段，并提供public的getter和setter方法,而如果使用private修饰field，则生成的getter和setter也是private的,如果定义val field，则只会生成getter方法,如果不希望生成setter和getter方法，则将field声明为private[this]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Student&#123;</span><br><span class="line">    var name = &quot;leo&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用getter和setter方法，分别叫做name和name_ =</span><br><span class="line"></span><br><span class="line">val leo = new Student</span><br><span class="line">print(leo.name)</span><br><span class="line">leo.name = &quot;leo1&quot;</span><br></pre></td></tr></table></figure><h3 id="自定义getter和setter方法"><a href="#自定义getter和setter方法" class="headerlink" title="自定义getter和setter方法"></a>自定义getter和setter方法</h3><p>如果只是希望拥有简单的getter和setter方法，那么就按照scala提供的语法规则，根据需求为field选择合适的修饰符就好:var、val、private、private[this]<br>但是如果希望能够自己对getter与setter进行控制，则可以自定义getter和setter方法<br>自定义setter方法的时候一定需要注意scala的语法限制，签名、=、参数间不能有空格<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Student&#123;</span><br><span class="line">    private var myName = &quot;leo&quot;</span><br><span class="line">    def name = &quot;your name is &quot; + myName</span><br><span class="line">    def name_=(newValue:String)&#123;</span><br><span class="line">     print(&quot;you cannot edit your name !!!&quot;)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val leo = new Student</span><br><span class="line">print(leo.name)</span><br><span class="line">leo.name = &quot;leo1&quot;</span><br></pre></td></tr></table></figure></p><h3 id="private-this-的使用"><a href="#private-this-的使用" class="headerlink" title="private[this]的使用"></a>private[this]的使用</h3><p>如果将field使用private来修饰，那么代表这个field是类私有的，在类的方法中，可以直接访问类的其他对象的private field<br>这种情况下，如果不希望field被其他对象访问到，那么可以使用private[this]，意味着对象私有的field，只有本对象内可以访问到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Student&#123;</span><br><span class="line">   private var myAge = 0</span><br><span class="line">   def age_ = (newValue:Int)&#123;</span><br><span class="line">   if(newValue&gt;0) myAge = newValue</span><br><span class="line">     else print(&quot;illegal age!&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  def age = myAge</span><br><span class="line">  def older(s:Student) = &#123;</span><br><span class="line">     myAge &gt; s.myAge</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java风格的getter和setter方法"><a href="#Java风格的getter和setter方法" class="headerlink" title="Java风格的getter和setter方法"></a>Java风格的getter和setter方法</h3><p>Scala的getter和setter方法的命名与java是不同的，是field和field_=的方式<br>如果要让scala自动生成java风格的getter和setter方法，只要给field添加@BeanProperty注解即可<br>此时会生成4个方法，name:String、name_=(newValue:String):Unit、getName():String、setName(newValue:String):Unit<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import scala.reflect.BeanProperty</span><br><span class="line">class Student&#123;</span><br><span class="line">   @BeanProperty var name:String =_</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student(@BeanProperty var name:String)</span><br><span class="line"></span><br><span class="line">val s = new Student</span><br><span class="line">s.getName(&quot;leo&quot;)</span><br><span class="line">s.getName()</span><br></pre></td></tr></table></figure></p><h3 id="辅助constructor"><a href="#辅助constructor" class="headerlink" title="辅助constructor"></a>辅助constructor</h3><p>Scala中，可以给类定义多个辅助constructor，类似于java中的构造函数重载<br>辅助constructor之间可以互相调用，而且必须第一行调用主constructor<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Student</span><br><span class="line">&#123;</span><br><span class="line">  private var name =&quot;&quot;</span><br><span class="line">  private var age = 0</span><br><span class="line">   def this(name:String)</span><br><span class="line">  &#123;</span><br><span class="line">     this()</span><br><span class="line">     this.name = name</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    def this(name:String,age:Int)</span><br><span class="line">   &#123;</span><br><span class="line">     this(name)</span><br><span class="line">     this.age = age</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;定义类&quot;&gt;&lt;a href=&quot;#定义类&quot; class=&quot;headerlink&quot; title=&quot;定义类&quot;&gt;&lt;/a&gt;定义类&lt;/h3&gt;&lt;p&gt;定义类，包含field以及方法&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class HelloWorld&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   private var name = &amp;quot;leo&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   def sayHello() &amp;#123; print(&amp;quot;Hello , &amp;quot;+name)&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   def getName = name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//创建类的对象，并调用其方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;val helloWorld = new HelloWorld&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;helloWorld.sayHello()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//也可以不加括号，如果定义方法时不带括号，则调用方法时也不能带括号&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(helloWorld.getName)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Scala" scheme="http://yoursite.com/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
  </entry>
  
</feed>
